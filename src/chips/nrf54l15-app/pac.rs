#![doc = "Peripheral access API (generated using chiptool v0.1.0 (26983da 2025-01-02))"]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum Interrupt {
    #[doc = "28 - SWI00"]
    SWI00 = 28,
    #[doc = "29 - SWI01"]
    SWI01 = 29,
    #[doc = "30 - SWI02"]
    SWI02 = 30,
    #[doc = "31 - SWI03"]
    SWI03 = 31,
    #[doc = "64 - SPU00"]
    SPU00 = 64,
    #[doc = "65 - MPC00"]
    MPC00 = 65,
    #[doc = "70 - AAR00_CCM00"]
    AAR00_CCM00 = 70,
    #[doc = "71 - ECB00"]
    ECB00 = 71,
    #[doc = "72 - CRACEN"]
    CRACEN = 72,
    #[doc = "74 - SERIAL00"]
    SERIAL00 = 74,
    #[doc = "75 - RRAMC"]
    RRAMC = 75,
    #[doc = "76 - VPR00"]
    VPR00 = 76,
    #[doc = "82 - CTRLAP"]
    CTRLAP = 82,
    #[doc = "85 - TIMER00"]
    TIMER00 = 85,
    #[doc = "128 - SPU10"]
    SPU10 = 128,
    #[doc = "133 - TIMER10"]
    TIMER10 = 133,
    #[doc = "134 - RTC10"]
    RTC10 = 134,
    #[doc = "135 - EGU10"]
    EGU10 = 135,
    #[doc = "138 - RADIO_0"]
    RADIO_0 = 138,
    #[doc = "139 - RADIO_1"]
    RADIO_1 = 139,
    #[doc = "192 - SPU20"]
    SPU20 = 192,
    #[doc = "198 - SERIAL20"]
    SERIAL20 = 198,
    #[doc = "199 - SERIAL21"]
    SERIAL21 = 199,
    #[doc = "200 - SERIAL22"]
    SERIAL22 = 200,
    #[doc = "201 - EGU20"]
    EGU20 = 201,
    #[doc = "202 - TIMER20"]
    TIMER20 = 202,
    #[doc = "203 - TIMER21"]
    TIMER21 = 203,
    #[doc = "204 - TIMER22"]
    TIMER22 = 204,
    #[doc = "205 - TIMER23"]
    TIMER23 = 205,
    #[doc = "206 - TIMER24"]
    TIMER24 = 206,
    #[doc = "208 - PDM20"]
    PDM20 = 208,
    #[doc = "209 - PDM21"]
    PDM21 = 209,
    #[doc = "210 - PWM20"]
    PWM20 = 210,
    #[doc = "211 - PWM21"]
    PWM21 = 211,
    #[doc = "212 - PWM22"]
    PWM22 = 212,
    #[doc = "213 - SAADC"]
    SAADC = 213,
    #[doc = "214 - NFCT"]
    NFCT = 214,
    #[doc = "215 - TEMP"]
    TEMP = 215,
    #[doc = "218 - GPIOTE20_0"]
    GPIOTE20_0 = 218,
    #[doc = "219 - GPIOTE20_1"]
    GPIOTE20_1 = 219,
    #[doc = "220 - TAMPC"]
    TAMPC = 220,
    #[doc = "221 - I2S20"]
    I2S20 = 221,
    #[doc = "224 - QDEC20"]
    QDEC20 = 224,
    #[doc = "225 - QDEC21"]
    QDEC21 = 225,
    #[doc = "226 - GRTC_0"]
    GRTC_0 = 226,
    #[doc = "227 - GRTC_1"]
    GRTC_1 = 227,
    #[doc = "228 - GRTC_2"]
    GRTC_2 = 228,
    #[doc = "229 - GRTC_3"]
    GRTC_3 = 229,
    #[doc = "256 - SPU30"]
    SPU30 = 256,
    #[doc = "260 - SERIAL30"]
    SERIAL30 = 260,
    #[doc = "261 - RTC30"]
    RTC30 = 261,
    #[doc = "262 - COMP_LPCOMP"]
    COMP_LPCOMP = 262,
    #[doc = "264 - WDT30"]
    WDT30 = 264,
    #[doc = "265 - WDT31"]
    WDT31 = 265,
    #[doc = "268 - GPIOTE30_0"]
    GPIOTE30_0 = 268,
    #[doc = "269 - GPIOTE30_1"]
    GPIOTE30_1 = 269,
    #[doc = "270 - CLOCK_POWER"]
    CLOCK_POWER = 270,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[cfg(feature = "rt")]
mod _vectors {
    extern "C" {
        fn SWI00();
        fn SWI01();
        fn SWI02();
        fn SWI03();
        fn SPU00();
        fn MPC00();
        fn AAR00_CCM00();
        fn ECB00();
        fn CRACEN();
        fn SERIAL00();
        fn RRAMC();
        fn VPR00();
        fn CTRLAP();
        fn TIMER00();
        fn SPU10();
        fn TIMER10();
        fn RTC10();
        fn EGU10();
        fn RADIO_0();
        fn RADIO_1();
        fn SPU20();
        fn SERIAL20();
        fn SERIAL21();
        fn SERIAL22();
        fn EGU20();
        fn TIMER20();
        fn TIMER21();
        fn TIMER22();
        fn TIMER23();
        fn TIMER24();
        fn PDM20();
        fn PDM21();
        fn PWM20();
        fn PWM21();
        fn PWM22();
        fn SAADC();
        fn NFCT();
        fn TEMP();
        fn GPIOTE20_0();
        fn GPIOTE20_1();
        fn TAMPC();
        fn I2S20();
        fn QDEC20();
        fn QDEC21();
        fn GRTC_0();
        fn GRTC_1();
        fn GRTC_2();
        fn GRTC_3();
        fn SPU30();
        fn SERIAL30();
        fn RTC30();
        fn COMP_LPCOMP();
        fn WDT30();
        fn WDT31();
        fn GPIOTE30_0();
        fn GPIOTE30_1();
        fn CLOCK_POWER();
    }
    pub union Vector {
        _handler: unsafe extern "C" fn(),
        _reserved: u32,
    }
    #[link_section = ".vector_table.interrupts"]
    #[no_mangle]
    pub static __INTERRUPTS: [Vector; 271] = [
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SWI00 },
        Vector { _handler: SWI01 },
        Vector { _handler: SWI02 },
        Vector { _handler: SWI03 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU00 },
        Vector { _handler: MPC00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: AAR00_CCM00,
        },
        Vector { _handler: ECB00 },
        Vector { _handler: CRACEN },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL00 },
        Vector { _handler: RRAMC },
        Vector { _handler: VPR00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: CTRLAP },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER00 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU10 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: TIMER10 },
        Vector { _handler: RTC10 },
        Vector { _handler: EGU10 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: RADIO_0 },
        Vector { _handler: RADIO_1 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU20 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL20 },
        Vector { _handler: SERIAL21 },
        Vector { _handler: SERIAL22 },
        Vector { _handler: EGU20 },
        Vector { _handler: TIMER20 },
        Vector { _handler: TIMER21 },
        Vector { _handler: TIMER22 },
        Vector { _handler: TIMER23 },
        Vector { _handler: TIMER24 },
        Vector { _reserved: 0 },
        Vector { _handler: PDM20 },
        Vector { _handler: PDM21 },
        Vector { _handler: PWM20 },
        Vector { _handler: PWM21 },
        Vector { _handler: PWM22 },
        Vector { _handler: SAADC },
        Vector { _handler: NFCT },
        Vector { _handler: TEMP },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: GPIOTE20_0,
        },
        Vector {
            _handler: GPIOTE20_1,
        },
        Vector { _handler: TAMPC },
        Vector { _handler: I2S20 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: QDEC20 },
        Vector { _handler: QDEC21 },
        Vector { _handler: GRTC_0 },
        Vector { _handler: GRTC_1 },
        Vector { _handler: GRTC_2 },
        Vector { _handler: GRTC_3 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SPU30 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector { _handler: SERIAL30 },
        Vector { _handler: RTC30 },
        Vector {
            _handler: COMP_LPCOMP,
        },
        Vector { _reserved: 0 },
        Vector { _handler: WDT30 },
        Vector { _handler: WDT31 },
        Vector { _reserved: 0 },
        Vector { _reserved: 0 },
        Vector {
            _handler: GPIOTE30_0,
        },
        Vector {
            _handler: GPIOTE30_1,
        },
        Vector {
            _handler: CLOCK_POWER,
        },
    ];
}
#[doc = "Factory Information Configuration Registers"]
pub const FICR_NS: ficr::Ficr = unsafe { ficr::Ficr::from_ptr(0x00ff_c000usize as _) };
#[doc = "User Information Configuration Registers"]
pub const UICR_S: uicr::Uicr = unsafe { uicr::Uicr::from_ptr(0x00ff_d000usize as _) };
#[doc = "Factory Information Configuration Registers"]
pub const SICR_S: sicr::Sicr = unsafe { sicr::Sicr::from_ptr(0x00ff_e000usize as _) };
#[doc = "CACHEDATA"]
pub const ICACHEDATA_S: cachedata::Cachedata =
    unsafe { cachedata::Cachedata::from_ptr(0x12f0_0000usize as _) };
#[doc = "CACHEINFO"]
pub const ICACHEINFO_S: cacheinfo::Cacheinfo =
    unsafe { cacheinfo::Cacheinfo::from_ptr(0x12f1_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 0"]
pub const DPPIC00_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4004_2000usize as _) };
#[doc = "PPIB APB registers 0"]
pub const PPIB00_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4004_3000usize as _) };
#[doc = "PPIB APB registers 2"]
pub const PPIB01_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4004_4000usize as _) };
#[doc = "Accelerated Address Resolver 0"]
pub const AAR00_NS: aar::Aar = unsafe { aar::Aar::from_ptr(0x4004_6000usize as _) };
#[doc = "AES CCM Mode Encryption 0"]
pub const CCM00_NS: ccm::Ccm = unsafe { ccm::Ccm::from_ptr(0x4004_6000usize as _) };
#[doc = "AES ECB Mode Encryption 0"]
pub const ECB00_NS: ecb::Ecb = unsafe { ecb::Ecb::from_ptr(0x4004_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
pub const SPIM00_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4004_a000usize as _) };
#[doc = "SPI Slave 0"]
pub const SPIS00_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4004_a000usize as _) };
#[doc = "UART with EasyDMA 0"]
pub const UARTE00_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4004_a000usize as _) };
#[doc = "VPR peripheral registers 0"]
pub const VPR00_NS: vpr::Vpr = unsafe { vpr::Vpr::from_ptr(0x4004_c000usize as _) };
#[doc = "GPIO Port 0"]
pub const P2_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4005_0400usize as _) };
#[doc = "Control access port 0"]
pub const CTRLAP_NS: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x4005_2000usize as _) };
#[doc = "Trace and debug control 0"]
pub const TAD_NS: tad::Tad = unsafe { tad::Tad::from_ptr(0x4005_3000usize as _) };
#[doc = "Timer/Counter 0"]
pub const TIMER00_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4005_5000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 2"]
pub const DPPIC10_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4008_2000usize as _) };
#[doc = "PPIB APB registers 4"]
pub const PPIB10_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4008_3000usize as _) };
#[doc = "PPIB APB registers 6"]
pub const PPIB11_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4008_4000usize as _) };
#[doc = "Timer/Counter 2"]
pub const TIMER10_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x4008_5000usize as _) };
#[doc = "Real-time counter 0"]
pub const RTC10_NS: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4008_6000usize as _) };
#[doc = "Event generator unit 0"]
pub const EGU10_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x4008_7000usize as _) };
#[doc = "2.4 GHz radio 0"]
pub const RADIO_NS: radio::Radio = unsafe { radio::Radio::from_ptr(0x4008_a000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 4"]
pub const DPPIC20_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x400c_2000usize as _) };
#[doc = "PPIB APB registers 8"]
pub const PPIB20_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_3000usize as _) };
#[doc = "PPIB APB registers 10"]
pub const PPIB21_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_4000usize as _) };
#[doc = "PPIB APB registers 12"]
pub const PPIB22_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x400c_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 2"]
pub const SPIM20_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_6000usize as _) };
#[doc = "SPI Slave 2"]
pub const SPIS20_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
pub const TWIM20_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
pub const TWIS20_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_6000usize as _) };
#[doc = "UART with EasyDMA 2"]
pub const UARTE20_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 4"]
pub const SPIM21_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_7000usize as _) };
#[doc = "SPI Slave 4"]
pub const SPIS21_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 2"]
pub const TWIM21_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 2"]
pub const TWIS21_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_7000usize as _) };
#[doc = "UART with EasyDMA 4"]
pub const UARTE21_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 6"]
pub const SPIM22_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x400c_8000usize as _) };
#[doc = "SPI Slave 6"]
pub const SPIS22_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x400c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 4"]
pub const TWIM22_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x400c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 4"]
pub const TWIS22_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x400c_8000usize as _) };
#[doc = "UART with EasyDMA 6"]
pub const UARTE22_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x400c_8000usize as _) };
#[doc = "Event generator unit 2"]
pub const EGU20_NS: egu::Egu = unsafe { egu::Egu::from_ptr(0x400c_9000usize as _) };
#[doc = "Timer/Counter 4"]
pub const TIMER20_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_a000usize as _) };
#[doc = "Timer/Counter 6"]
pub const TIMER21_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_b000usize as _) };
#[doc = "Timer/Counter 8"]
pub const TIMER22_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_c000usize as _) };
#[doc = "Timer/Counter 10"]
pub const TIMER23_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_d000usize as _) };
#[doc = "Timer/Counter 12"]
pub const TIMER24_NS: timer::Timer = unsafe { timer::Timer::from_ptr(0x400c_e000usize as _) };
#[doc = "Memory configuration 0"]
pub const MEMCONF_NS: memconf::Memconf =
    unsafe { memconf::Memconf::from_ptr(0x400c_f000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
pub const PDM20_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x400d_0000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 2"]
pub const PDM21_NS: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x400d_1000usize as _) };
#[doc = "Pulse width modulation unit 0"]
pub const PWM20_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_2000usize as _) };
#[doc = "Pulse width modulation unit 2"]
pub const PWM21_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_3000usize as _) };
#[doc = "Pulse width modulation unit 4"]
pub const PWM22_NS: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x400d_4000usize as _) };
#[doc = "Analog to Digital Converter 0"]
pub const SAADC_NS: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x400d_5000usize as _) };
#[doc = "NFC-A compatible radio NFC-A compatible radio 0"]
pub const NFCT_NS: nfct::Nfct = unsafe { nfct::Nfct::from_ptr(0x400d_6000usize as _) };
#[doc = "Temperature Sensor 0"]
pub const TEMP_NS: temp::Temp = unsafe { temp::Temp::from_ptr(0x400d_7000usize as _) };
#[doc = "GPIO Port 2"]
pub const P1_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x400d_8200usize as _) };
#[doc = "GPIO Tasks and Events 0"]
pub const GPIOTE20_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x400d_a000usize as _) };
#[doc = "Inter-IC Sound 0"]
pub const I2S20_NS: i2s::I2s = unsafe { i2s::I2s::from_ptr(0x400d_d000usize as _) };
#[doc = "Quadrature Decoder 0"]
pub const QDEC20_NS: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x400e_0000usize as _) };
#[doc = "Quadrature Decoder 2"]
pub const QDEC21_NS: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x400e_1000usize as _) };
#[doc = "Global Real-time counter 0"]
pub const GRTC_NS: grtc::Grtc = unsafe { grtc::Grtc::from_ptr(0x400e_2000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 6"]
pub const DPPIC30_NS: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x4010_2000usize as _) };
#[doc = "PPIB APB registers 14"]
pub const PPIB30_NS: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x4010_3000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 8"]
pub const SPIM30_NS: spim::Spim = unsafe { spim::Spim::from_ptr(0x4010_4000usize as _) };
#[doc = "SPI Slave 8"]
pub const SPIS30_NS: spis::Spis = unsafe { spis::Spis::from_ptr(0x4010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 6"]
pub const TWIM30_NS: twim::Twim = unsafe { twim::Twim::from_ptr(0x4010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 6"]
pub const TWIS30_NS: twis::Twis = unsafe { twis::Twis::from_ptr(0x4010_4000usize as _) };
#[doc = "UART with EasyDMA 8"]
pub const UARTE30_NS: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x4010_4000usize as _) };
#[doc = "Real-time counter 2"]
pub const RTC30_NS: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x4010_5000usize as _) };
#[doc = "Comparator 0"]
pub const COMP_NS: comp::Comp = unsafe { comp::Comp::from_ptr(0x4010_6000usize as _) };
#[doc = "Low-power comparator 0"]
pub const LPCOMP_NS: lpcomp::Lpcomp = unsafe { lpcomp::Lpcomp::from_ptr(0x4010_6000usize as _) };
#[doc = "Watchdog Timer 1"]
pub const WDT31_NS: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x4010_9000usize as _) };
#[doc = "GPIO Port 4"]
pub const P0_NS: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x4010_a000usize as _) };
#[doc = "GPIO Tasks and Events 2"]
pub const GPIOTE30_NS: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x4010_c000usize as _) };
#[doc = "Clock management 0"]
pub const CLOCK_NS: clock::Clock = unsafe { clock::Clock::from_ptr(0x4010_e000usize as _) };
#[doc = "Power control 0"]
pub const POWER_NS: power::Power = unsafe { power::Power::from_ptr(0x4010_e000usize as _) };
#[doc = "Reset control 0"]
pub const RESET_NS: reset::Reset = unsafe { reset::Reset::from_ptr(0x4010_e000usize as _) };
#[doc = "Oscillator control 0"]
pub const OSCILLATORS_NS: oscillators::Oscillators =
    unsafe { oscillators::Oscillators::from_ptr(0x4012_0000usize as _) };
#[doc = "Voltage regulators 0"]
pub const REGULATORS_NS: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x4012_0000usize as _) };
#[doc = "Software interrupt 0"]
pub const SWI00_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_c000usize as _) };
#[doc = "Software interrupt 1"]
pub const SWI01_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_d000usize as _) };
#[doc = "Software interrupt 2"]
pub const SWI02_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_e000usize as _) };
#[doc = "Software interrupt 3"]
pub const SWI03_S: swi::Swi = unsafe { swi::Swi::from_ptr(0x5001_f000usize as _) };
#[doc = "System protection unit 0"]
pub const SPU00_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5004_0000usize as _) };
#[doc = "Memory Privilege Controller"]
pub const MPC00_S: mpc::Mpc = unsafe { mpc::Mpc::from_ptr(0x5004_1000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 1"]
pub const DPPIC00_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5004_2000usize as _) };
#[doc = "PPIB APB registers 1"]
pub const PPIB00_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5004_3000usize as _) };
#[doc = "PPIB APB registers 3"]
pub const PPIB01_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5004_4000usize as _) };
#[doc = "Key management unit"]
pub const KMU_S: kmu::Kmu = unsafe { kmu::Kmu::from_ptr(0x5004_5000usize as _) };
#[doc = "Accelerated Address Resolver 1"]
pub const AAR00_S: aar::Aar = unsafe { aar::Aar::from_ptr(0x5004_6000usize as _) };
#[doc = "AES CCM Mode Encryption 1"]
pub const CCM00_S: ccm::Ccm = unsafe { ccm::Ccm::from_ptr(0x5004_6000usize as _) };
#[doc = "AES ECB Mode Encryption 1"]
pub const ECB00_S: ecb::Ecb = unsafe { ecb::Ecb::from_ptr(0x5004_7000usize as _) };
#[doc = "CRACEN"]
pub const CRACEN_S: cracen::Cracen = unsafe { cracen::Cracen::from_ptr(0x5004_8000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 1"]
pub const SPIM00_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5004_a000usize as _) };
#[doc = "SPI Slave 1"]
pub const SPIS00_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5004_a000usize as _) };
#[doc = "UART with EasyDMA 1"]
pub const UARTE00_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5004_a000usize as _) };
#[doc = "Voltage glitch detectors"]
pub const GLITCHDET_S: glitchdet::Glitchdet =
    unsafe { glitchdet::Glitchdet::from_ptr(0x5004_b000usize as _) };
#[doc = "RRAM controller GLITCH detector"]
pub const RRAMC_S: rramc::Rramc = unsafe { rramc::Rramc::from_ptr(0x5004_b000usize as _) };
#[doc = "VPR peripheral registers 1"]
pub const VPR00_S: vpr::Vpr = unsafe { vpr::Vpr::from_ptr(0x5004_c000usize as _) };
#[doc = "GPIO Port 1"]
pub const P2_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5005_0400usize as _) };
#[doc = "Control access port 1"]
pub const CTRLAP_S: ctrlapperi::Ctrlapperi =
    unsafe { ctrlapperi::Ctrlapperi::from_ptr(0x5005_2000usize as _) };
#[doc = "Trace and debug control 1"]
pub const TAD_S: tad::Tad = unsafe { tad::Tad::from_ptr(0x5005_3000usize as _) };
#[doc = "Timer/Counter 1"]
pub const TIMER00_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5005_5000usize as _) };
#[doc = "System protection unit 1"]
pub const SPU10_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5008_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 3"]
pub const DPPIC10_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5008_2000usize as _) };
#[doc = "PPIB APB registers 5"]
pub const PPIB10_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5008_3000usize as _) };
#[doc = "PPIB APB registers 7"]
pub const PPIB11_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5008_4000usize as _) };
#[doc = "Timer/Counter 3"]
pub const TIMER10_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x5008_5000usize as _) };
#[doc = "Real-time counter 1"]
pub const RTC10_S: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x5008_6000usize as _) };
#[doc = "Event generator unit 1"]
pub const EGU10_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x5008_7000usize as _) };
#[doc = "2.4 GHz radio 1"]
pub const RADIO_S: radio::Radio = unsafe { radio::Radio::from_ptr(0x5008_a000usize as _) };
#[doc = "System protection unit 2"]
pub const SPU20_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x500c_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 5"]
pub const DPPIC20_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x500c_2000usize as _) };
#[doc = "PPIB APB registers 9"]
pub const PPIB20_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_3000usize as _) };
#[doc = "PPIB APB registers 11"]
pub const PPIB21_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_4000usize as _) };
#[doc = "PPIB APB registers 13"]
pub const PPIB22_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x500c_5000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 3"]
pub const SPIM20_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_6000usize as _) };
#[doc = "SPI Slave 3"]
pub const SPIS20_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 1"]
pub const TWIM20_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_6000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 1"]
pub const TWIS20_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_6000usize as _) };
#[doc = "UART with EasyDMA 3"]
pub const UARTE20_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_6000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 5"]
pub const SPIM21_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_7000usize as _) };
#[doc = "SPI Slave 5"]
pub const SPIS21_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 3"]
pub const TWIM21_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_7000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 3"]
pub const TWIS21_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_7000usize as _) };
#[doc = "UART with EasyDMA 5"]
pub const UARTE21_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_7000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 7"]
pub const SPIM22_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x500c_8000usize as _) };
#[doc = "SPI Slave 7"]
pub const SPIS22_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x500c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 5"]
pub const TWIM22_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x500c_8000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 5"]
pub const TWIS22_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x500c_8000usize as _) };
#[doc = "UART with EasyDMA 7"]
pub const UARTE22_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x500c_8000usize as _) };
#[doc = "Event generator unit 3"]
pub const EGU20_S: egu::Egu = unsafe { egu::Egu::from_ptr(0x500c_9000usize as _) };
#[doc = "Timer/Counter 5"]
pub const TIMER20_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_a000usize as _) };
#[doc = "Timer/Counter 7"]
pub const TIMER21_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_b000usize as _) };
#[doc = "Timer/Counter 9"]
pub const TIMER22_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_c000usize as _) };
#[doc = "Timer/Counter 11"]
pub const TIMER23_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_d000usize as _) };
#[doc = "Timer/Counter 13"]
pub const TIMER24_S: timer::Timer = unsafe { timer::Timer::from_ptr(0x500c_e000usize as _) };
#[doc = "Memory configuration 1"]
pub const MEMCONF_S: memconf::Memconf =
    unsafe { memconf::Memconf::from_ptr(0x500c_f000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 1"]
pub const PDM20_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x500d_0000usize as _) };
#[doc = "Pulse Density Modulation (Digital Microphone) Interface 3"]
pub const PDM21_S: pdm::Pdm = unsafe { pdm::Pdm::from_ptr(0x500d_1000usize as _) };
#[doc = "Pulse width modulation unit 1"]
pub const PWM20_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_2000usize as _) };
#[doc = "Pulse width modulation unit 3"]
pub const PWM21_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_3000usize as _) };
#[doc = "Pulse width modulation unit 5"]
pub const PWM22_S: pwm::Pwm = unsafe { pwm::Pwm::from_ptr(0x500d_4000usize as _) };
#[doc = "Analog to Digital Converter 1"]
pub const SAADC_S: saadc::Saadc = unsafe { saadc::Saadc::from_ptr(0x500d_5000usize as _) };
#[doc = "NFC-A compatible radio NFC-A compatible radio 1"]
pub const NFCT_S: nfct::Nfct = unsafe { nfct::Nfct::from_ptr(0x500d_6000usize as _) };
#[doc = "Temperature Sensor 1"]
pub const TEMP_S: temp::Temp = unsafe { temp::Temp::from_ptr(0x500d_7000usize as _) };
#[doc = "GPIO Port 3"]
pub const P1_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x500d_8200usize as _) };
#[doc = "GPIO Tasks and Events 1"]
pub const GPIOTE20_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x500d_a000usize as _) };
#[doc = "Tamper controller"]
pub const TAMPC_S: tampc::Tampc = unsafe { tampc::Tampc::from_ptr(0x500d_c000usize as _) };
#[doc = "Inter-IC Sound 1"]
pub const I2S20_S: i2s::I2s = unsafe { i2s::I2s::from_ptr(0x500d_d000usize as _) };
#[doc = "Quadrature Decoder 1"]
pub const QDEC20_S: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x500e_0000usize as _) };
#[doc = "Quadrature Decoder 3"]
pub const QDEC21_S: qdec::Qdec = unsafe { qdec::Qdec::from_ptr(0x500e_1000usize as _) };
#[doc = "Global Real-time counter 1"]
pub const GRTC_S: grtc::Grtc = unsafe { grtc::Grtc::from_ptr(0x500e_2000usize as _) };
#[doc = "System protection unit 3"]
pub const SPU30_S: spu::Spu = unsafe { spu::Spu::from_ptr(0x5010_0000usize as _) };
#[doc = "Distributed programmable peripheral interconnect controller 7"]
pub const DPPIC30_S: dppic::Dppic = unsafe { dppic::Dppic::from_ptr(0x5010_2000usize as _) };
#[doc = "PPIB APB registers 15"]
pub const PPIB30_S: ppib::Ppib = unsafe { ppib::Ppib::from_ptr(0x5010_3000usize as _) };
#[doc = "Serial Peripheral Interface Master with EasyDMA 9"]
pub const SPIM30_S: spim::Spim = unsafe { spim::Spim::from_ptr(0x5010_4000usize as _) };
#[doc = "SPI Slave 9"]
pub const SPIS30_S: spis::Spis = unsafe { spis::Spis::from_ptr(0x5010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 7"]
pub const TWIM30_S: twim::Twim = unsafe { twim::Twim::from_ptr(0x5010_4000usize as _) };
#[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 7"]
pub const TWIS30_S: twis::Twis = unsafe { twis::Twis::from_ptr(0x5010_4000usize as _) };
#[doc = "UART with EasyDMA 9"]
pub const UARTE30_S: uarte::Uarte = unsafe { uarte::Uarte::from_ptr(0x5010_4000usize as _) };
#[doc = "Real-time counter 3"]
pub const RTC30_S: rtc::Rtc = unsafe { rtc::Rtc::from_ptr(0x5010_5000usize as _) };
#[doc = "Comparator 1"]
pub const COMP_S: comp::Comp = unsafe { comp::Comp::from_ptr(0x5010_6000usize as _) };
#[doc = "Low-power comparator 1"]
pub const LPCOMP_S: lpcomp::Lpcomp = unsafe { lpcomp::Lpcomp::from_ptr(0x5010_6000usize as _) };
#[doc = "Watchdog Timer 0"]
pub const WDT30_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5010_8000usize as _) };
#[doc = "Watchdog Timer 2"]
pub const WDT31_S: wdt::Wdt = unsafe { wdt::Wdt::from_ptr(0x5010_9000usize as _) };
#[doc = "GPIO Port 5"]
pub const P0_S: gpio::Gpio = unsafe { gpio::Gpio::from_ptr(0x5010_a000usize as _) };
#[doc = "GPIO Tasks and Events 3"]
pub const GPIOTE30_S: gpiote::Gpiote = unsafe { gpiote::Gpiote::from_ptr(0x5010_c000usize as _) };
#[doc = "Clock management 1"]
pub const CLOCK_S: clock::Clock = unsafe { clock::Clock::from_ptr(0x5010_e000usize as _) };
#[doc = "Power control 1"]
pub const POWER_S: power::Power = unsafe { power::Power::from_ptr(0x5010_e000usize as _) };
#[doc = "Reset control 1"]
pub const RESET_S: reset::Reset = unsafe { reset::Reset::from_ptr(0x5010_e000usize as _) };
#[doc = "Oscillator control 1"]
pub const OSCILLATORS_S: oscillators::Oscillators =
    unsafe { oscillators::Oscillators::from_ptr(0x5012_0000usize as _) };
#[doc = "Voltage regulators 1"]
pub const REGULATORS_S: regulators::Regulators =
    unsafe { regulators::Regulators::from_ptr(0x5012_0000usize as _) };
#[doc = "CRACENCORE"]
pub const CRACENCORE_S: cracencore::Cracencore =
    unsafe { cracencore::Cracencore::from_ptr(0x5180_0000usize as _) };
#[doc = "Trace Port Interface Unit"]
pub const TPIU_NS: tpiu::Tpiu = unsafe { tpiu::Tpiu::from_ptr(0xe004_0000usize as _) };
#[doc = "Embedded Trace Macrocell"]
pub const ETM_NS: etm::Etm = unsafe { etm::Etm::from_ptr(0xe004_1000usize as _) };
#[doc = "CPU control"]
pub const CPUC_S: cpuc::Cpuc = unsafe { cpuc::Cpuc::from_ptr(0xe008_0000usize as _) };
#[doc = "Cache"]
pub const ICACHE_S: cache::Cache = unsafe { cache::Cache::from_ptr(0xe008_2000usize as _) };
#[doc = r" Number available in the NVIC for configuring priority"]
// #[cfg(feature = "rt")]
pub const NVIC_PRIO_BITS: u8 = 3;
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[cfg(feature = "rt")]
pub use Interrupt as interrupt;
pub mod aar {
    #[doc = "Accelerated Address Resolver 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Aar {
        ptr: *mut u8,
    }
    unsafe impl Send for Aar {}
    unsafe impl Sync for Aar {}
    impl Aar {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start resolving addresses based on IRKs specified in the IRK data structure"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop resolving addresses"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Address resolution procedure complete or ended due to an error"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Address resolved"]
        #[inline(always)]
        pub const fn events_resolved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Address not resolved"]
        #[inline(always)]
        pub const fn events_notresolved(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Operation aborted because of a STOP task or due to an error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event RESOLVED"]
        #[inline(always)]
        pub const fn publish_resolved(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event NOTRESOLVED"]
        #[inline(always)]
        pub const fn publish_notresolved(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Enable AAR"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Maximum number of IRKs to resolve"]
        #[inline(always)]
        pub const fn maxresolved(self) -> crate::common::Reg<regs::Maxresolved, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes written to memory after triggering the START task."]
            #[inline(always)]
            pub const fn amount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Number of bytes written to memory after triggering the START task."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Amount {
                    amount: u8,
                }
                let proxy = Amount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable AAR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable AAR"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable AAR"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorstatus {
                    errorstatus: super::vals::Errorstatus,
                }
                let proxy = Errorstatus {
                    errorstatus: self.errorstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event RESOLVED"]
            #[inline(always)]
            pub const fn resolved(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RESOLVED"]
            #[inline(always)]
            pub fn set_resolved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event NOTRESOLVED"]
            #[inline(always)]
            pub const fn notresolved(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event NOTRESOLVED"]
            #[inline(always)]
            pub fn set_notresolved(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("resolved", &self.resolved())
                    .field("notresolved", &self.notresolved())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    end: bool,
                    resolved: bool,
                    notresolved: bool,
                    error: bool,
                }
                let proxy = Int {
                    end: self.end(),
                    resolved: self.resolved(),
                    notresolved: self.notresolved(),
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of IRKs to resolve"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxresolved(pub u32);
        impl Maxresolved {
            #[doc = "The maximum number of IRKs to resolve"]
            #[inline(always)]
            pub const fn maxresolved(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "The maximum number of IRKs to resolve"]
            #[inline(always)]
            pub fn set_maxresolved(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Maxresolved {
            #[inline(always)]
            fn default() -> Maxresolved {
                Maxresolved(0)
            }
        }
        impl core::fmt::Debug for Maxresolved {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxresolved")
                    .field("maxresolved", &self.maxresolved())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxresolved {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxresolved {
                    maxresolved: u16,
                }
                let proxy = Maxresolved {
                    maxresolved: self.maxresolved(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Enable"]
            ENABLED = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
    }
}
pub mod cache {
    #[doc = "Cache"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cache {
        ptr: *mut u8,
    }
    unsafe impl Send for Cache {}
    unsafe impl Sync for Cache {}
    impl Cache {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Invalidate the cache."]
        #[inline(always)]
        pub const fn tasks_invalidatecache(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Invalidate the line."]
        #[inline(always)]
        pub const fn tasks_invalidateline(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Erase the cache."]
        #[inline(always)]
        pub const fn tasks_erase(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Status of the cache activities."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable cache."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::CacheEnable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Cache mode."]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0408usize) as _) }
        }
        #[doc = "Memory address covered by the line to be maintained."]
        #[inline(always)]
        pub const fn lineaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn profiling(self) -> Profiling {
            unsafe { Profiling::from_ptr(self.ptr.add(0x0414usize) as _) }
        }
        #[doc = "Lock debug mode."]
        #[inline(always)]
        pub const fn debuglock(self) -> crate::common::Reg<regs::Debuglock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0430usize) as _) }
        }
        #[doc = "Lock cache updates."]
        #[inline(always)]
        pub const fn writelock(self) -> crate::common::Reg<regs::Writelock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0434usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Profiling {
        ptr: *mut u8,
    }
    unsafe impl Send for Profiling {}
    unsafe impl Sync for Profiling {}
    impl Profiling {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable the profiling counters."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::ProfilingEnable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Clear the profiling counters."]
        #[inline(always)]
        pub const fn clear(self) -> crate::common::Reg<regs::Clear, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The cache hit counter for cache region."]
        #[inline(always)]
        pub const fn hit(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "The cache miss counter for cache region."]
        #[inline(always)]
        pub const fn miss(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "The cache line miss counter for cache region."]
        #[inline(always)]
        pub const fn lmiss(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Number of reads for cache region."]
        #[inline(always)]
        pub const fn reads(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Number of writes for cache region."]
        #[inline(always)]
        pub const fn writes(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable cache."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CacheEnable(pub u32);
        impl CacheEnable {
            #[doc = "Enable cache"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable cache"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for CacheEnable {
            #[inline(always)]
            fn default() -> CacheEnable {
                CacheEnable(0)
            }
        }
        impl core::fmt::Debug for CacheEnable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CacheEnable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CacheEnable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct CacheEnable {
                    enable: bool,
                }
                let proxy = CacheEnable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Clear the profiling counters."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clear(pub u32);
        impl Clear {
            #[doc = "Clearing the profiling counters"]
            #[inline(always)]
            pub const fn clear(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Clearing the profiling counters"]
            #[inline(always)]
            pub fn set_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Clear {
            #[inline(always)]
            fn default() -> Clear {
                Clear(0)
            }
        }
        impl core::fmt::Debug for Clear {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clear")
                    .field("clear", &self.clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clear {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Clear {
                    clear: bool,
                }
                let proxy = Clear {
                    clear: self.clear(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Lock debug mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Debuglock(pub u32);
        impl Debuglock {
            #[doc = "Lock debug mode"]
            #[inline(always)]
            pub const fn debuglock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock debug mode"]
            #[inline(always)]
            pub fn set_debuglock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Debuglock {
            #[inline(always)]
            fn default() -> Debuglock {
                Debuglock(0)
            }
        }
        impl core::fmt::Debug for Debuglock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Debuglock")
                    .field("debuglock", &self.debuglock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Debuglock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Debuglock {
                    debuglock: bool,
                }
                let proxy = Debuglock {
                    debuglock: self.debuglock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Cache mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Cache mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Cache mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "RAM size"]
            #[inline(always)]
            pub const fn ramsize(&self) -> super::vals::Ramsize {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Ramsize::from_bits(val as u8)
            }
            #[doc = "RAM size"]
            #[inline(always)]
            pub fn set_ramsize(&mut self, val: super::vals::Ramsize) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("mode", &self.mode())
                    .field("ramsize", &self.ramsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    mode: super::vals::Mode,
                    ramsize: super::vals::Ramsize,
                }
                let proxy = Mode {
                    mode: self.mode(),
                    ramsize: self.ramsize(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable the profiling counters."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ProfilingEnable(pub u32);
        impl ProfilingEnable {
            #[doc = "Enable the profiling counters"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the profiling counters"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ProfilingEnable {
            #[inline(always)]
            fn default() -> ProfilingEnable {
                ProfilingEnable(0)
            }
        }
        impl core::fmt::Debug for ProfilingEnable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ProfilingEnable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ProfilingEnable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ProfilingEnable {
                    enable: bool,
                }
                let proxy = ProfilingEnable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status of the cache activities."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Ready status."]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Ready status."]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Status {
                    ready: bool,
                }
                let proxy = Status {
                    ready: self.ready(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Lock cache updates."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Writelock(pub u32);
        impl Writelock {
            #[doc = "Lock cache updates"]
            #[inline(always)]
            pub const fn writelock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock cache updates"]
            #[inline(always)]
            pub fn set_writelock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Writelock {
            #[inline(always)]
            fn default() -> Writelock {
                Writelock(0)
            }
        }
        impl core::fmt::Debug for Writelock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Writelock")
                    .field("writelock", &self.writelock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writelock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Writelock {
                    writelock: bool,
                }
                let proxy = Writelock {
                    writelock: self.writelock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Cache mode"]
            CACHE = 0x0,
            #[doc = "RAM mode"]
            RAM = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ramsize {
            #[doc = "All RAM is used for cache memory"]
            ALL = 0x0,
            #[doc = "Half of the RAM is used for cache memory"]
            HALF = 0x01,
            #[doc = "Quarter of the RAM is used for cache memory"]
            QUARTER = 0x02,
            #[doc = "None of the RAM is used for cache memory"]
            NONE = 0x03,
        }
        impl Ramsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ramsize {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ramsize {
            #[inline(always)]
            fn from(val: u8) -> Ramsize {
                Ramsize::from_bits(val)
            }
        }
        impl From<Ramsize> for u8 {
            #[inline(always)]
            fn from(val: Ramsize) -> u8 {
                Ramsize::to_bits(val)
            }
        }
    }
}
pub mod cachedata {
    #[doc = "CACHEDATA"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cachedata {
        ptr: *mut u8,
    }
    unsafe impl Send for Cachedata {}
    unsafe impl Sync for Cachedata {}
    impl Cachedata {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn set(self, n: usize) -> Set {
            assert!(n < 128usize);
            unsafe { Set::from_ptr(self.ptr.add(0x0usize + n * 64usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Du {
        ptr: *mut u8,
    }
    unsafe impl Send for Du {}
    unsafe impl Sync for Du {}
    impl Du {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Cache data bits for DATA\\[q\\] in DU\\[p\\] (DataUnit) of SET\\[n\\], WAY\\[o\\]."]
        #[inline(always)]
        pub const fn data(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Set {
        ptr: *mut u8,
    }
    unsafe impl Send for Set {}
    unsafe impl Sync for Set {}
    impl Set {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn way(self, n: usize) -> Way {
            assert!(n < 2usize);
            unsafe { Way::from_ptr(self.ptr.add(0x0usize + n * 32usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Way {
        ptr: *mut u8,
    }
    unsafe impl Send for Way {}
    unsafe impl Sync for Way {}
    impl Way {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn du(self, n: usize) -> Du {
            assert!(n < 4usize);
            unsafe { Du::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
}
pub mod cacheinfo {
    #[doc = "CACHEINFO"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cacheinfo {
        ptr: *mut u8,
    }
    unsafe impl Send for Cacheinfo {}
    unsafe impl Sync for Cacheinfo {}
    impl Cacheinfo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn set(self, n: usize) -> Set {
            assert!(n < 128usize);
            unsafe { Set::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Set {
        ptr: *mut u8,
    }
    unsafe impl Send for Set {}
    unsafe impl Sync for Set {}
    impl Set {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn way(self, n: usize) -> Way {
            assert!(n < 2usize);
            unsafe { Way::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Way {
        ptr: *mut u8,
    }
    unsafe impl Send for Way {}
    unsafe impl Sync for Way {}
    impl Way {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Cache information for SET\\[n\\], WAY\\[o\\]."]
        #[inline(always)]
        pub const fn info(self) -> crate::common::Reg<regs::Info, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Cache information for SET\\[n\\], WAY\\[o\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Info(pub u32);
        impl Info {
            #[doc = "Cache tag."]
            #[inline(always)]
            pub const fn tag(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Cache tag."]
            #[inline(always)]
            pub fn set_tag(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn duv_0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub fn set_duv_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn duv_1(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub fn set_duv_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn duv_2(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub fn set_duv_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub const fn duv_3(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Data unit valid info."]
            #[inline(always)]
            pub fn set_duv_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Line valid bit."]
            #[inline(always)]
            pub const fn v(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Line valid bit."]
            #[inline(always)]
            pub fn set_v(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Most recently used way."]
            #[inline(always)]
            pub const fn mru(&self) -> super::vals::Mru {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Mru::from_bits(val as u8)
            }
            #[doc = "Most recently used way."]
            #[inline(always)]
            pub fn set_mru(&mut self, val: super::vals::Mru) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Info {
            #[inline(always)]
            fn default() -> Info {
                Info(0)
            }
        }
        impl core::fmt::Debug for Info {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Info")
                    .field("tag", &self.tag())
                    .field("duv_0", &self.duv_0())
                    .field("duv_1", &self.duv_1())
                    .field("duv_2", &self.duv_2())
                    .field("duv_3", &self.duv_3())
                    .field("v", &self.v())
                    .field("mru", &self.mru())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Info {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Info {
                    tag: u32,
                    duv_0: bool,
                    duv_1: bool,
                    duv_2: bool,
                    duv_3: bool,
                    v: bool,
                    mru: super::vals::Mru,
                }
                let proxy = Info {
                    tag: self.tag(),
                    duv_0: self.duv_0(),
                    duv_1: self.duv_1(),
                    duv_2: self.duv_2(),
                    duv_3: self.duv_3(),
                    v: self.v(),
                    mru: self.mru(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mru {
            #[doc = "Way0 was most recently used"]
            WAY0 = 0x0,
            #[doc = "Way1 was most recently used"]
            WAY1 = 0x01,
        }
        impl Mru {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mru {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mru {
            #[inline(always)]
            fn from(val: u8) -> Mru {
                Mru::from_bits(val)
            }
        }
        impl From<Mru> for u8 {
            #[inline(always)]
            fn from(val: Mru) -> u8 {
                Mru::to_bits(val)
            }
        }
    }
}
pub mod ccm {
    #[doc = "AES CCM Mode Encryption 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ccm {
        ptr: *mut u8,
    }
    unsafe impl Send for Ccm {}
    unsafe impl Sync for Ccm {}
    impl Ccm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start encryption/decryption. This operation will stop by itself when completed."]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop encryption/decryption"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Override DATARATE setting in MODE register with the contents of the RATEOVERRIDE register for any ongoing encryption/decryption"]
        #[inline(always)]
        pub const fn tasks_rateoverride(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task RATEOVERRIDE"]
        #[inline(always)]
        pub const fn subscribe_rateoverride(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Encrypt/decrypt complete or ended because of an error"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "CCM error event"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "MAC check result"]
        #[inline(always)]
        pub const fn macstatus(self) -> crate::common::Reg<regs::Macstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Enable"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Operation mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self) -> Key {
            unsafe { Key::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nonce(self) -> Nonce {
            unsafe { Nonce::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Data rate override setting."]
        #[inline(always)]
        pub const fn rateoverride(
            self,
        ) -> crate::common::Reg<regs::Rateoverride, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0544usize) as _) }
        }
        #[doc = "CCM adata mask."]
        #[inline(always)]
        pub const fn adatamask(self) -> crate::common::Reg<regs::Adatamask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0548usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer Points to a job list containing unencrypted CCM data structure in Encryption mode Points to a job list containing encrypted CCM data structure in Decryption mode"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 128-bit AES key"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nonce {
        ptr: *mut u8,
    }
    unsafe impl Send for Nonce {}
    unsafe impl Sync for Nonce {}
    impl Nonce {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 13-byte NONCE vector Only the lower 13 bytes are used"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer Points to a job list containing encrypted CCM data structure in Encryption mode Points to a job list containing decrypted CCM data structure in Decryption mode"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "CCM adata mask."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Adatamask(pub u32);
        impl Adatamask {
            #[doc = "CCM adata mask."]
            #[inline(always)]
            pub const fn adatamask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "CCM adata mask."]
            #[inline(always)]
            pub fn set_adatamask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Adatamask {
            #[inline(always)]
            fn default() -> Adatamask {
                Adatamask(0)
            }
        }
        impl core::fmt::Debug for Adatamask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Adatamask")
                    .field("adatamask", &self.adatamask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Adatamask {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Adatamask {
                    adatamask: u8,
                }
                let proxy = Adatamask {
                    adatamask: self.adatamask(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable CCM"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable CCM"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorstatus {
                    errorstatus: super::vals::Errorstatus,
                }
                let proxy = Errorstatus {
                    errorstatus: self.errorstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    end: bool,
                    error: bool,
                }
                let proxy = Int {
                    end: self.end(),
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "MAC check result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Macstatus(pub u32);
        impl Macstatus {
            #[doc = "The result of the MAC check performed during the previous decryption operation"]
            #[inline(always)]
            pub const fn macstatus(&self) -> super::vals::Macstatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Macstatus::from_bits(val as u8)
            }
            #[doc = "The result of the MAC check performed during the previous decryption operation"]
            #[inline(always)]
            pub fn set_macstatus(&mut self, val: super::vals::Macstatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Macstatus {
            #[inline(always)]
            fn default() -> Macstatus {
                Macstatus(0)
            }
        }
        impl core::fmt::Debug for Macstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Macstatus")
                    .field("macstatus", &self.macstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Macstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Macstatus {
                    macstatus: super::vals::Macstatus,
                }
                let proxy = Macstatus {
                    macstatus: self.macstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Operation mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "The mode of operation to be used. The settings in this register apply when the CRYPT task is triggered."]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "The mode of operation to be used. The settings in this register apply when the CRYPT task is triggered."]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Protocol and packet format selection"]
            #[inline(always)]
            pub const fn protocol(&self) -> super::vals::Protocol {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Protocol::from_bits(val as u8)
            }
            #[doc = "Protocol and packet format selection"]
            #[inline(always)]
            pub fn set_protocol(&mut self, val: super::vals::Protocol) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Radio data rate that the CCM shall run synchronous with"]
            #[inline(always)]
            pub const fn datarate(&self) -> super::vals::Datarate {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Datarate::from_bits(val as u8)
            }
            #[doc = "Radio data rate that the CCM shall run synchronous with"]
            #[inline(always)]
            pub fn set_datarate(&mut self, val: super::vals::Datarate) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "CCM MAC length (bytes)"]
            #[inline(always)]
            pub const fn maclen(&self) -> super::vals::Maclen {
                let val = (self.0 >> 24usize) & 0x07;
                super::vals::Maclen::from_bits(val as u8)
            }
            #[doc = "CCM MAC length (bytes)"]
            #[inline(always)]
            pub fn set_maclen(&mut self, val: super::vals::Maclen) {
                self.0 =
                    (self.0 & !(0x07 << 24usize)) | (((val.to_bits() as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("mode", &self.mode())
                    .field("protocol", &self.protocol())
                    .field("datarate", &self.datarate())
                    .field("maclen", &self.maclen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    mode: super::vals::Mode,
                    protocol: super::vals::Protocol,
                    datarate: super::vals::Datarate,
                    maclen: super::vals::Maclen,
                }
                let proxy = Mode {
                    mode: self.mode(),
                    protocol: self.protocol(),
                    datarate: self.datarate(),
                    maclen: self.maclen(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Data rate override setting."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rateoverride(pub u32);
        impl Rateoverride {
            #[doc = "Data rate override setting."]
            #[inline(always)]
            pub const fn rateoverride(&self) -> super::vals::Rateoverride {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Rateoverride::from_bits(val as u8)
            }
            #[doc = "Data rate override setting."]
            #[inline(always)]
            pub fn set_rateoverride(&mut self, val: super::vals::Rateoverride) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rateoverride {
            #[inline(always)]
            fn default() -> Rateoverride {
                Rateoverride(0)
            }
        }
        impl core::fmt::Debug for Rateoverride {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rateoverride")
                    .field("rateoverride", &self.rateoverride())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rateoverride {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rateoverride {
                    rateoverride: super::vals::Rateoverride,
                }
                let proxy = Rateoverride {
                    rateoverride: self.rateoverride(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Datarate {
            #[doc = "125 Kbps"]
            _125KBIT = 0x0,
            #[doc = "250 Kbps"]
            _250KBIT = 0x01,
            #[doc = "500 Kbps"]
            _500KBIT = 0x02,
            #[doc = "1 Mbps"]
            _1MBIT = 0x03,
            #[doc = "2 Mbps"]
            _2MBIT = 0x04,
            #[doc = "4 Mbps"]
            _4MBIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Datarate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Datarate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Datarate {
            #[inline(always)]
            fn from(val: u8) -> Datarate {
                Datarate::from_bits(val)
            }
        }
        impl From<Datarate> for u8 {
            #[inline(always)]
            fn from(val: Datarate) -> u8 {
                Datarate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before CCM data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before CCM data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            #[doc = "Encryption of the unencrypted CCM data structure did not complete in time."]
            ENCRYPTION_TOO_SLOW = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Maclen {
            #[doc = "M = 0 This is a special case for CCM* where encryption is required but not authentication"]
            M0 = 0x0,
            #[doc = "M = 4"]
            M4 = 0x01,
            #[doc = "M = 6"]
            M6 = 0x02,
            #[doc = "M = 8"]
            M8 = 0x03,
            #[doc = "M = 10"]
            M10 = 0x04,
            #[doc = "M = 12"]
            M12 = 0x05,
            #[doc = "M = 14"]
            M14 = 0x06,
            #[doc = "M = 16"]
            M16 = 0x07,
        }
        impl Maclen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Maclen {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Maclen {
            #[inline(always)]
            fn from(val: u8) -> Maclen {
                Maclen::from_bits(val)
            }
        }
        impl From<Maclen> for u8 {
            #[inline(always)]
            fn from(val: Maclen) -> u8 {
                Maclen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Macstatus {
            #[doc = "MAC check failed"]
            CHECK_FAILED = 0x0,
            #[doc = "MAC check passed"]
            CHECK_PASSED = 0x01,
        }
        impl Macstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Macstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Macstatus {
            #[inline(always)]
            fn from(val: u8) -> Macstatus {
                Macstatus::from_bits(val)
            }
        }
        impl From<Macstatus> for u8 {
            #[inline(always)]
            fn from(val: Macstatus) -> u8 {
                Macstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "AES CCM packet encryption mode"]
            ENCRYPTION = 0x0,
            #[doc = "Deprecated enumerator - This mode will run CCM decryption in the speed of the DATARATE field."]
            DECRYPTION = 0x01,
            #[doc = "AES CCM decryption mode."]
            FAST_DECRYPTION = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Protocol {
            #[doc = "Bluetooth Low Energy packet format"]
            BLE = 0x0,
            #[doc = "802.15.4 packet format"]
            IEEE802154 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Protocol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Protocol {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Protocol {
            #[inline(always)]
            fn from(val: u8) -> Protocol {
                Protocol::from_bits(val)
            }
        }
        impl From<Protocol> for u8 {
            #[inline(always)]
            fn from(val: Protocol) -> u8 {
                Protocol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rateoverride {
            #[doc = "125 Kbps"]
            _125KBIT = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "500 Kbps"]
            _500KBIT = 0x02,
            #[doc = "1 Mbps"]
            _1MBIT = 0x03,
            #[doc = "2 Mbps"]
            _2MBIT = 0x04,
            #[doc = "4 Mbps"]
            _4MBIT = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Rateoverride {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rateoverride {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rateoverride {
            #[inline(always)]
            fn from(val: u8) -> Rateoverride {
                Rateoverride::from_bits(val)
            }
        }
        impl From<Rateoverride> for u8 {
            #[inline(always)]
            fn from(val: Rateoverride) -> u8 {
                Rateoverride::to_bits(val)
            }
        }
    }
}
pub mod clock {
    #[doc = "Clock management 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Clock {
        ptr: *mut u8,
    }
    unsafe impl Send for Clock {}
    unsafe impl Sync for Clock {}
    impl Clock {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start crystal oscillator (HFXO)"]
        #[inline(always)]
        pub const fn tasks_xostart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop crystal oscillator (HFXO)"]
        #[inline(always)]
        pub const fn tasks_xostop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Start PLL and keep it running, regardless of the automatic clock requests"]
        #[inline(always)]
        pub const fn tasks_pllstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Stop PLL"]
        #[inline(always)]
        pub const fn tasks_pllstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Start LFCLK source as selected in LFCLK.SRC"]
        #[inline(always)]
        pub const fn tasks_lfclkstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Stop LFCLK source"]
        #[inline(always)]
        pub const fn tasks_lfclkstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Start calibration of LFRC oscillator"]
        #[inline(always)]
        pub const fn tasks_cal(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Request tuning for HFXO"]
        #[inline(always)]
        pub const fn tasks_xotune(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Abort tuning for HFXO"]
        #[inline(always)]
        pub const fn tasks_xotuneabort(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOSTART"]
        #[inline(always)]
        pub const fn subscribe_xostart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOSTOP"]
        #[inline(always)]
        pub const fn subscribe_xostop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLSTART"]
        #[inline(always)]
        pub const fn subscribe_pllstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task PLLSTOP"]
        #[inline(always)]
        pub const fn subscribe_pllstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTART"]
        #[inline(always)]
        pub const fn subscribe_lfclkstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task LFCLKSTOP"]
        #[inline(always)]
        pub const fn subscribe_lfclkstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task CAL"]
        #[inline(always)]
        pub const fn subscribe_cal(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Subscribe configuration for task XOTUNE"]
        #[inline(always)]
        pub const fn subscribe_xotune(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task XOTUNEABORT"]
        #[inline(always)]
        pub const fn subscribe_xotuneabort(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "Crystal oscillator has started"]
        #[inline(always)]
        pub const fn events_xostarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "PLL started"]
        #[inline(always)]
        pub const fn events_pllstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "LFCLK source started"]
        #[inline(always)]
        pub const fn events_lfclkstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Calibration of LFRC oscillator complete event"]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "HFXO tuning is done. XOTUNED is generated after TASKS_XOSTART or after TASKS_XOTUNE has completed"]
        #[inline(always)]
        pub const fn events_xotuned(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "HFXO quality issue detected, XOTUNE is needed"]
        #[inline(always)]
        pub const fn events_xotuneerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "HFXO tuning could not be completed"]
        #[inline(always)]
        pub const fn events_xotunefailed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Publish configuration for event XOSTARTED"]
        #[inline(always)]
        pub const fn publish_xostarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event PLLSTARTED"]
        #[inline(always)]
        pub const fn publish_pllstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event LFCLKSTARTED"]
        #[inline(always)]
        pub const fn publish_lfclkstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNED"]
        #[inline(always)]
        pub const fn publish_xotuned(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNEERROR"]
        #[inline(always)]
        pub const fn publish_xotuneerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event XOTUNEFAILED"]
        #[inline(always)]
        pub const fn publish_xotunefailed(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn xo(self) -> Xo {
            unsafe { Xo::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pll(self) -> Pll {
            unsafe { Pll::from_ptr(self.ptr.add(0x0420usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn lfclk(self) -> Lfclk {
            unsafe { Lfclk::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lfclk {
        ptr: *mut u8,
    }
    unsafe impl Send for Lfclk {}
    unsafe impl Sync for Lfclk {}
    impl Lfclk {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Clock source for LFCLK"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<regs::Src, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Indicates that LFCLKSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::LfclkRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Copy of LFCLK.SRCCOPY register, set when LFCLKSTARTED event is triggered."]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::LfclkStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Copy of LFCLK.SRC register, set when LFCLKSTART task is triggered"]
        #[inline(always)]
        pub const fn srccopy(self) -> crate::common::Reg<regs::Srccopy, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll {}
    unsafe impl Sync for Pll {}
    impl Pll {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that PLLSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::PllRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::PllStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xo {
        ptr: *mut u8,
    }
    unsafe impl Send for Xo {}
    unsafe impl Sync for Xo {}
    impl Xo {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Indicates that XOSTART task was triggered"]
        #[inline(always)]
        pub const fn run(self) -> crate::common::Reg<regs::XoRun, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "XO status"]
        #[inline(always)]
        pub const fn stat(self) -> crate::common::Reg<regs::XoStat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event XOSTARTED"]
            #[inline(always)]
            pub const fn xostarted(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOSTARTED"]
            #[inline(always)]
            pub fn set_xostarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event PLLSTARTED"]
            #[inline(always)]
            pub const fn pllstarted(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PLLSTARTED"]
            #[inline(always)]
            pub fn set_pllstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[inline(always)]
            pub const fn lfclkstarted(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LFCLKSTARTED"]
            #[inline(always)]
            pub fn set_lfclkstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNED"]
            #[inline(always)]
            pub const fn xotuned(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNED"]
            #[inline(always)]
            pub fn set_xotuned(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNEERROR"]
            #[inline(always)]
            pub const fn xotuneerror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNEERROR"]
            #[inline(always)]
            pub fn set_xotuneerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event XOTUNEFAILED"]
            #[inline(always)]
            pub const fn xotunefailed(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event XOTUNEFAILED"]
            #[inline(always)]
            pub fn set_xotunefailed(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("xostarted", &self.xostarted())
                    .field("pllstarted", &self.pllstarted())
                    .field("lfclkstarted", &self.lfclkstarted())
                    .field("done", &self.done())
                    .field("xotuned", &self.xotuned())
                    .field("xotuneerror", &self.xotuneerror())
                    .field("xotunefailed", &self.xotunefailed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    xostarted: bool,
                    pllstarted: bool,
                    lfclkstarted: bool,
                    done: bool,
                    xotuned: bool,
                    xotuneerror: bool,
                    xotunefailed: bool,
                }
                let proxy = Int {
                    xostarted: self.xostarted(),
                    pllstarted: self.pllstarted(),
                    lfclkstarted: self.lfclkstarted(),
                    done: self.done(),
                    xotuned: self.xotuned(),
                    xotuneerror: self.xotuneerror(),
                    xotunefailed: self.xotunefailed(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates that LFCLKSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LfclkRun(pub u32);
        impl LfclkRun {
            #[doc = "LFCLKSTART task triggered or not"]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLKSTART task triggered or not"]
            #[inline(always)]
            pub fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for LfclkRun {
            #[inline(always)]
            fn default() -> LfclkRun {
                LfclkRun(0)
            }
        }
        impl core::fmt::Debug for LfclkRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LfclkRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LfclkRun {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct LfclkRun {
                    status: bool,
                }
                let proxy = LfclkRun {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Copy of LFCLK.SRCCOPY register, set when LFCLKSTARTED event is triggered."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct LfclkStat(pub u32);
        impl LfclkStat {
            #[doc = "Value of LFCLK.SRCCOPY register when LFCLKSTARTED event was triggered"]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Value of LFCLK.SRCCOPY register when LFCLKSTARTED event was triggered"]
            #[inline(always)]
            pub fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "ALWAYSRUN activated"]
            #[inline(always)]
            pub const fn alwaysrunning(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "ALWAYSRUN activated"]
            #[inline(always)]
            pub fn set_alwaysrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LFCLK state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "LFCLK state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for LfclkStat {
            #[inline(always)]
            fn default() -> LfclkStat {
                LfclkStat(0)
            }
        }
        impl core::fmt::Debug for LfclkStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("LfclkStat")
                    .field("src", &self.src())
                    .field("alwaysrunning", &self.alwaysrunning())
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LfclkStat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct LfclkStat {
                    src: super::vals::Lfclksrc,
                    alwaysrunning: bool,
                    state: bool,
                }
                let proxy = LfclkStat {
                    src: self.src(),
                    alwaysrunning: self.alwaysrunning(),
                    state: self.state(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates that PLLSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllRun(pub u32);
        impl PllRun {
            #[doc = "PLLSTART task triggered or not"]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "PLLSTART task triggered or not"]
            #[inline(always)]
            pub fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for PllRun {
            #[inline(always)]
            fn default() -> PllRun {
                PllRun(0)
            }
        }
        impl core::fmt::Debug for PllRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllRun {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PllRun {
                    status: bool,
                }
                let proxy = PllRun {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Which PLL settings were selected when triggering START task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PllStat(pub u32);
        impl PllStat {
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "PLL state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for PllStat {
            #[inline(always)]
            fn default() -> PllStat {
                PllStat(0)
            }
        }
        impl core::fmt::Debug for PllStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PllStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PllStat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PllStat {
                    state: bool,
                }
                let proxy = PllStat {
                    state: self.state(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Clock source for LFCLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Src(pub u32);
        impl Src {
            #[doc = "Select which LFCLK source is started by the LFCLKSTART task"]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Select which LFCLK source is started by the LFCLKSTART task"]
            #[inline(always)]
            pub fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Src {
            #[inline(always)]
            fn default() -> Src {
                Src(0)
            }
        }
        impl core::fmt::Debug for Src {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Src").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Src {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Src {
                    src: super::vals::Lfclksrc,
                }
                let proxy = Src { src: self.src() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Copy of LFCLK.SRC register, set when LFCLKSTART task is triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Srccopy(pub u32);
        impl Srccopy {
            #[doc = "Value of LFCLK.SRC register when LFCLKSTART task was triggered"]
            #[inline(always)]
            pub const fn src(&self) -> super::vals::Lfclksrc {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lfclksrc::from_bits(val as u8)
            }
            #[doc = "Value of LFCLK.SRC register when LFCLKSTART task was triggered"]
            #[inline(always)]
            pub fn set_src(&mut self, val: super::vals::Lfclksrc) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Srccopy {
            #[inline(always)]
            fn default() -> Srccopy {
                Srccopy(0)
            }
        }
        impl core::fmt::Debug for Srccopy {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Srccopy").field("src", &self.src()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Srccopy {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Srccopy {
                    src: super::vals::Lfclksrc,
                }
                let proxy = Srccopy { src: self.src() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates that XOSTART task was triggered"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct XoRun(pub u32);
        impl XoRun {
            #[doc = "XOSTART task triggered or not"]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "XOSTART task triggered or not"]
            #[inline(always)]
            pub fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for XoRun {
            #[inline(always)]
            fn default() -> XoRun {
                XoRun(0)
            }
        }
        impl core::fmt::Debug for XoRun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("XoRun")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for XoRun {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct XoRun {
                    status: bool,
                }
                let proxy = XoRun {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "XO status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct XoStat(pub u32);
        impl XoStat {
            #[doc = "XO state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub const fn state(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "XO state (Running between START task and STOPPED event)"]
            #[inline(always)]
            pub fn set_state(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
        }
        impl Default for XoStat {
            #[inline(always)]
            fn default() -> XoStat {
                XoStat(0)
            }
        }
        impl core::fmt::Debug for XoStat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("XoStat")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for XoStat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct XoStat {
                    state: bool,
                }
                let proxy = XoStat {
                    state: self.state(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lfclksrc {
            #[doc = "32.768 kHz RC oscillator"]
            LFRC = 0x0,
            #[doc = "32.768 kHz crystal oscillator"]
            LFXO = 0x01,
            #[doc = "32.768 kHz synthesized from HFCLK"]
            LFSYNT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Lfclksrc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lfclksrc {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lfclksrc {
            #[inline(always)]
            fn from(val: u8) -> Lfclksrc {
                Lfclksrc::from_bits(val)
            }
        }
        impl From<Lfclksrc> for u8 {
            #[inline(always)]
            fn from(val: Lfclksrc) -> u8 {
                Lfclksrc::to_bits(val)
            }
        }
    }
}
pub mod common {
    use core::marker::PhantomData;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct RW;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct R;
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct W;
    mod sealed {
        use super::*;
        pub trait Access {}
        impl Access for R {}
        impl Access for W {}
        impl Access for RW {}
    }
    pub trait Access: sealed::Access + Copy {}
    impl Access for R {}
    impl Access for W {}
    impl Access for RW {}
    pub trait Read: Access {}
    impl Read for RW {}
    impl Read for R {}
    pub trait Write: Access {}
    impl Write for RW {}
    impl Write for W {}
    #[derive(Copy, Clone, PartialEq, Eq)]
    pub struct Reg<T: Copy, A: Access> {
        ptr: *mut u8,
        phantom: PhantomData<*mut (T, A)>,
    }
    unsafe impl<T: Copy, A: Access> Send for Reg<T, A> {}
    unsafe impl<T: Copy, A: Access> Sync for Reg<T, A> {}
    impl<T: Copy, A: Access> Reg<T, A> {
        #[allow(clippy::missing_safety_doc)]
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut T) -> Self {
            Self {
                ptr: ptr as _,
                phantom: PhantomData,
            }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut T {
            self.ptr as _
        }
    }
    impl<T: Copy, A: Read> Reg<T, A> {
        #[inline(always)]
        pub fn read(&self) -> T {
            unsafe { (self.ptr as *mut T).read_volatile() }
        }
    }
    impl<T: Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write_value(&self, val: T) {
            unsafe { (self.ptr as *mut T).write_volatile(val) }
        }
    }
    impl<T: Default + Copy, A: Write> Reg<T, A> {
        #[inline(always)]
        pub fn write<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = Default::default();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
    impl<T: Copy, A: Read + Write> Reg<T, A> {
        #[inline(always)]
        pub fn modify<R>(&self, f: impl FnOnce(&mut T) -> R) -> R {
            let mut val = self.read();
            let res = f(&mut val);
            self.write_value(val);
            res
        }
    }
}
pub mod comp {
    #[doc = "Comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Comp {
        ptr: *mut u8,
    }
    unsafe impl Send for Comp {}
    unsafe impl Sync for Comp {}
    impl Comp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start comparator"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop comparator"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Sample comparator value. This task requires that COMP has been started by the START Task."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "COMP is ready and output is valid"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Downward crossing"]
        #[inline(always)]
        pub const fn events_down(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Upward crossing"]
        #[inline(always)]
        pub const fn events_up(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Downward or upward crossing"]
        #[inline(always)]
        pub const fn events_cross(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event DOWN"]
        #[inline(always)]
        pub const fn publish_down(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event UP"]
        #[inline(always)]
        pub const fn publish_up(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event CROSS"]
        #[inline(always)]
        pub const fn publish_cross(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Compare result"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<regs::Result, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "COMP enable"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Pin select"]
        #[inline(always)]
        pub const fn psel(self) -> crate::common::Reg<regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Reference source select for single-ended mode"]
        #[inline(always)]
        pub const fn refsel(self) -> crate::common::Reg<regs::Refsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "External reference select"]
        #[inline(always)]
        pub const fn extrefsel(self) -> crate::common::Reg<regs::Extrefsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Threshold configuration for hysteresis unit"]
        #[inline(always)]
        pub const fn th(self) -> crate::common::Reg<regs::Th, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "Mode configuration"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0534usize) as _) }
        }
        #[doc = "Comparator hysteresis enable"]
        #[inline(always)]
        pub const fn hyst(self) -> crate::common::Reg<regs::Hyst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Current source select on analog input"]
        #[inline(always)]
        pub const fn isource(self) -> crate::common::Reg<regs::Isource, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x053cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "COMP enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable COMP"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable COMP"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "External reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extrefsel(pub u32);
        impl Extrefsel {
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Extrefsel {
            #[inline(always)]
            fn default() -> Extrefsel {
                Extrefsel(0)
            }
        }
        impl core::fmt::Debug for Extrefsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extrefsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extrefsel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Extrefsel {
                    pin: u8,
                    port: u8,
                }
                let proxy = Extrefsel {
                    pin: self.pin(),
                    port: self.port(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Comparator hysteresis enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hyst(pub u32);
        impl Hyst {
            #[doc = "Comparator hysteresis"]
            #[inline(always)]
            pub const fn hyst(&self) -> super::vals::Hyst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Hyst::from_bits(val as u8)
            }
            #[doc = "Comparator hysteresis"]
            #[inline(always)]
            pub fn set_hyst(&mut self, val: super::vals::Hyst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hyst {
            #[inline(always)]
            fn default() -> Hyst {
                Hyst(0)
            }
        }
        impl core::fmt::Debug for Hyst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hyst").field("hyst", &self.hyst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hyst {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Hyst {
                    hyst: super::vals::Hyst,
                }
                let proxy = Hyst { hyst: self.hyst() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub const fn down(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub fn set_down(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub const fn up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub fn set_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub const fn cross(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub fn set_cross(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("down", &self.down())
                    .field("up", &self.up())
                    .field("cross", &self.cross())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    ready: bool,
                    down: bool,
                    up: bool,
                    cross: bool,
                }
                let proxy = Int {
                    ready: self.ready(),
                    down: self.down(),
                    up: self.up(),
                    cross: self.cross(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Current source select on analog input"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Isource(pub u32);
        impl Isource {
            #[doc = "Current source select on analog input"]
            #[inline(always)]
            pub const fn isource(&self) -> super::vals::Isource {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Isource::from_bits(val as u8)
            }
            #[doc = "Current source select on analog input"]
            #[inline(always)]
            pub fn set_isource(&mut self, val: super::vals::Isource) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Isource {
            #[inline(always)]
            fn default() -> Isource {
                Isource(0)
            }
        }
        impl core::fmt::Debug for Isource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Isource")
                    .field("isource", &self.isource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Isource {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Isource {
                    isource: super::vals::Isource,
                }
                let proxy = Isource {
                    isource: self.isource(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Speed and power modes"]
            #[inline(always)]
            pub const fn sp(&self) -> super::vals::Sp {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Sp::from_bits(val as u8)
            }
            #[doc = "Speed and power modes"]
            #[inline(always)]
            pub fn set_sp(&mut self, val: super::vals::Sp) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Main operation modes"]
            #[inline(always)]
            pub const fn main(&self) -> super::vals::Main {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Main::from_bits(val as u8)
            }
            #[doc = "Main operation modes"]
            #[inline(always)]
            pub fn set_main(&mut self, val: super::vals::Main) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("sp", &self.sp())
                    .field("main", &self.main())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    sp: super::vals::Sp,
                    main: super::vals::Main,
                }
                let proxy = Mode {
                    sp: self.sp(),
                    main: self.main(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Pin select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Psel {
                    pin: u8,
                    port: u8,
                }
                let proxy = Psel {
                    pin: self.pin(),
                    port: self.port(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Reference source select for single-ended mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refsel(pub u32);
        impl Refsel {
            #[doc = "Reference select"]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference select"]
            #[inline(always)]
            pub fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Refsel {
            #[inline(always)]
            fn default() -> Refsel {
                Refsel(0)
            }
        }
        impl core::fmt::Debug for Refsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refsel")
                    .field("refsel", &self.refsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refsel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Refsel {
                    refsel: super::vals::Refsel,
                }
                let proxy = Refsel {
                    refsel: self.refsel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Compare result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result(pub u32);
        impl Result {
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub const fn result(&self) -> super::vals::Result {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Result::from_bits(val as u8)
            }
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub fn set_result(&mut self, val: super::vals::Result) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result {
            #[inline(always)]
            fn default() -> Result {
                Result(0)
            }
        }
        impl core::fmt::Debug for Result {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result")
                    .field("result", &self.result())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Result {
                    result: super::vals::Result,
                }
                let proxy = Result {
                    result: self.result(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub const fn ready_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub fn set_ready_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub const fn ready_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub fn set_ready_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub const fn down_stop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub fn set_down_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub const fn up_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub fn set_up_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub const fn cross_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub fn set_cross_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_sample", &self.ready_sample())
                    .field("ready_stop", &self.ready_stop())
                    .field("down_stop", &self.down_stop())
                    .field("up_stop", &self.up_stop())
                    .field("cross_stop", &self.cross_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    ready_sample: bool,
                    ready_stop: bool,
                    down_stop: bool,
                    up_stop: bool,
                    cross_stop: bool,
                }
                let proxy = Shorts {
                    ready_sample: self.ready_sample(),
                    ready_stop: self.ready_stop(),
                    down_stop: self.down_stop(),
                    up_stop: self.up_stop(),
                    cross_stop: self.cross_stop(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Threshold configuration for hysteresis unit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Th(pub u32);
        impl Th {
            #[doc = "VDOWN = (THDOWN+1)/64*VREF"]
            #[inline(always)]
            pub const fn thdown(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "VDOWN = (THDOWN+1)/64*VREF"]
            #[inline(always)]
            pub fn set_thdown(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "VUP = (THUP+1)/64*VREF"]
            #[inline(always)]
            pub const fn thup(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x3f;
                val as u8
            }
            #[doc = "VUP = (THUP+1)/64*VREF"]
            #[inline(always)]
            pub fn set_thup(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val as u32) & 0x3f) << 8usize);
            }
        }
        impl Default for Th {
            #[inline(always)]
            fn default() -> Th {
                Th(0)
            }
        }
        impl core::fmt::Debug for Th {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Th")
                    .field("thdown", &self.thdown())
                    .field("thup", &self.thup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Th {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Th {
                    thdown: u8,
                    thup: u8,
                }
                let proxy = Th {
                    thdown: self.thdown(),
                    thup: self.thup(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hyst {
            #[doc = "Comparator hysteresis disabled"]
            NO_HYST = 0x0,
            #[doc = "Comparator hysteresis enabled"]
            HYST40M_V = 0x01,
        }
        impl Hyst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hyst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hyst {
            #[inline(always)]
            fn from(val: u8) -> Hyst {
                Hyst::from_bits(val)
            }
        }
        impl From<Hyst> for u8 {
            #[inline(always)]
            fn from(val: Hyst) -> u8 {
                Hyst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Isource {
            #[doc = "Current source disabled"]
            OFF = 0x0,
            #[doc = "Current source enabled (+/- 2.5 uA)"]
            IEN2U_A5 = 0x01,
            #[doc = "Current source enabled (+/- 5 uA)"]
            IEN5U_A = 0x02,
            #[doc = "Current source enabled (+/- 10 uA)"]
            IEN10U_A = 0x03,
        }
        impl Isource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Isource {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Isource {
            #[inline(always)]
            fn from(val: u8) -> Isource {
                Isource::from_bits(val)
            }
        }
        impl From<Isource> for u8 {
            #[inline(always)]
            fn from(val: Isource) -> u8 {
                Isource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Main {
            #[doc = "Single-ended mode"]
            SE = 0x0,
            #[doc = "Differential mode"]
            DIFF = 0x01,
        }
        impl Main {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Main {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Main {
            #[inline(always)]
            fn from(val: u8) -> Main {
                Main::from_bits(val)
            }
        }
        impl From<Main> for u8 {
            #[inline(always)]
            fn from(val: Main) -> u8 {
                Main::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "VREF = internal 1.2 V reference"]
            INT1V2 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "VREF = VDD"]
            VDD = 0x04,
            #[doc = "VREF = AREF"]
            AREF = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Result {
            #[doc = "Input voltage is below the threshold (VIN+ &lt; VIN-)"]
            BELOW = 0x0,
            #[doc = "Input voltage is above the threshold (VIN+ &gt; VIN-)"]
            ABOVE = 0x01,
        }
        impl Result {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Result {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Result {
            #[inline(always)]
            fn from(val: u8) -> Result {
                Result::from_bits(val)
            }
        }
        impl From<Result> for u8 {
            #[inline(always)]
            fn from(val: Result) -> u8 {
                Result::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sp {
            #[doc = "Low-power mode"]
            LOW = 0x0,
            #[doc = "Normal mode"]
            NORMAL = 0x01,
            #[doc = "High-speed mode"]
            HIGH = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sp {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sp {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sp {
            #[inline(always)]
            fn from(val: u8) -> Sp {
                Sp::from_bits(val)
            }
        }
        impl From<Sp> for u8 {
            #[inline(always)]
            fn from(val: Sp) -> u8 {
                Sp::to_bits(val)
            }
        }
    }
}
pub mod cpuc {
    #[doc = "CPU control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cpuc {
        ptr: *mut u8,
    }
    unsafe impl Send for Cpuc {}
    unsafe impl Sync for Cpuc {}
    impl Cpuc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "An invalid operation exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuioc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "A floating-point divide-by-zero exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpudzc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "A floating-point overflow exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuofc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "A floating-point underflow exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuufc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "A floating-point inexact exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuixc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "A floating-point input denormal exception has occurred in the FPU."]
        #[inline(always)]
        pub const fn events_fpuidc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Register to lock the certain parts of the CPU from being modified."]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "The identifier for the CPU in this subsystem."]
        #[inline(always)]
        pub const fn cpuid(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event FPUIOC"]
            #[inline(always)]
            pub const fn fpuioc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUIOC"]
            #[inline(always)]
            pub fn set_fpuioc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event FPUDZC"]
            #[inline(always)]
            pub const fn fpudzc(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUDZC"]
            #[inline(always)]
            pub fn set_fpudzc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event FPUOFC"]
            #[inline(always)]
            pub const fn fpuofc(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUOFC"]
            #[inline(always)]
            pub fn set_fpuofc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event FPUUFC"]
            #[inline(always)]
            pub const fn fpuufc(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUUFC"]
            #[inline(always)]
            pub fn set_fpuufc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event FPUIXC"]
            #[inline(always)]
            pub const fn fpuixc(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUIXC"]
            #[inline(always)]
            pub fn set_fpuixc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event FPUIDC"]
            #[inline(always)]
            pub const fn fpuidc(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FPUIDC"]
            #[inline(always)]
            pub fn set_fpuidc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("fpuioc", &self.fpuioc())
                    .field("fpudzc", &self.fpudzc())
                    .field("fpuofc", &self.fpuofc())
                    .field("fpuufc", &self.fpuufc())
                    .field("fpuixc", &self.fpuixc())
                    .field("fpuidc", &self.fpuidc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    fpuioc: bool,
                    fpudzc: bool,
                    fpuofc: bool,
                    fpuufc: bool,
                    fpuixc: bool,
                    fpuidc: bool,
                }
                let proxy = Int {
                    fpuioc: self.fpuioc(),
                    fpudzc: self.fpudzc(),
                    fpuofc: self.fpuofc(),
                    fpuufc: self.fpuufc(),
                    fpuixc: self.fpuixc(),
                    fpuidc: self.fpuidc(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Register to lock the certain parts of the CPU from being modified."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Locks both the Vector table Offset Register (VTOR) and Application Interrupt and Reset Control Register (AIRCR) for secure mode."]
            #[inline(always)]
            pub const fn lockvtoraircrs(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Locks both the Vector table Offset Register (VTOR) and Application Interrupt and Reset Control Register (AIRCR) for secure mode."]
            #[inline(always)]
            pub fn set_lockvtoraircrs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Locks the Vector table Offset Register (VTOR) for non-secure mode."]
            #[inline(always)]
            pub const fn lockvtorns(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Vector table Offset Register (VTOR) for non-secure mode."]
            #[inline(always)]
            pub fn set_lockvtorns(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for secure mode."]
            #[inline(always)]
            pub const fn lockmpus(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for secure mode."]
            #[inline(always)]
            pub fn set_lockmpus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for non secure mode."]
            #[inline(always)]
            pub const fn lockmpuns(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Memory Protection Unit (MPU) for non secure mode."]
            #[inline(always)]
            pub fn set_lockmpuns(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Locks the Security Attribution Unit (SAU)"]
            #[inline(always)]
            pub const fn locksau(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the Security Attribution Unit (SAU)"]
            #[inline(always)]
            pub fn set_locksau(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock")
                    .field("lockvtoraircrs", &self.lockvtoraircrs())
                    .field("lockvtorns", &self.lockvtorns())
                    .field("lockmpus", &self.lockmpus())
                    .field("lockmpuns", &self.lockmpuns())
                    .field("locksau", &self.locksau())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lock {
                    lockvtoraircrs: bool,
                    lockvtorns: bool,
                    lockmpus: bool,
                    lockmpuns: bool,
                    locksau: bool,
                }
                let proxy = Lock {
                    lockvtoraircrs: self.lockvtoraircrs(),
                    lockvtorns: self.lockvtorns(),
                    lockmpus: self.lockmpus(),
                    lockmpuns: self.lockmpuns(),
                    locksau: self.locksau(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod cracen {
    #[doc = "CRACEN"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracen {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracen {}
    unsafe impl Sync for Cracen {}
    impl Cracen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Event indicating that interrupt triggered at Cryptomaster"]
        #[inline(always)]
        pub const fn events_cryptomaster(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Event indicating that interrupt triggered at RNG"]
        #[inline(always)]
        pub const fn events_rng(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Event indicating that interrupt triggered at PKE or IKG"]
        #[inline(always)]
        pub const fn events_pkeikg(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Enable CRACEN peripheral modules."]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Marks the SEED register as valid"]
        #[inline(always)]
        pub const fn seedvalid(self) -> crate::common::Reg<regs::Seedvalid, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Description collection: Seed word \\[n\\] for symmetric and asymmetric key generation. This register is only writable from KMU."]
        #[inline(always)]
        pub const fn seed(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize + n * 4usize) as _) }
        }
        #[doc = "Lock the access to the SEED register."]
        #[inline(always)]
        pub const fn seedlock(self) -> crate::common::Reg<regs::Seedlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Lock the access to the protected RAM."]
        #[inline(always)]
        pub const fn protectedramlock(
            self,
        ) -> crate::common::Reg<regs::Protectedramlock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0444usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable CRACEN peripheral modules."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable cryptomaster"]
            #[inline(always)]
            pub const fn cryptomaster(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable cryptomaster"]
            #[inline(always)]
            pub fn set_cryptomaster(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable RNG"]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RNG"]
            #[inline(always)]
            pub fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable PKE and IKG"]
            #[inline(always)]
            pub const fn pkeikg(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable PKE and IKG"]
            #[inline(always)]
            pub fn set_pkeikg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("cryptomaster", &self.cryptomaster())
                    .field("rng", &self.rng())
                    .field("pkeikg", &self.pkeikg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    cryptomaster: bool,
                    rng: bool,
                    pkeikg: bool,
                }
                let proxy = Enable {
                    cryptomaster: self.cryptomaster(),
                    rng: self.rng(),
                    pkeikg: self.pkeikg(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CRYPTOMASTER"]
            #[inline(always)]
            pub const fn cryptomaster(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CRYPTOMASTER"]
            #[inline(always)]
            pub fn set_cryptomaster(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event RNG"]
            #[inline(always)]
            pub const fn rng(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RNG"]
            #[inline(always)]
            pub fn set_rng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event PKEIKG"]
            #[inline(always)]
            pub const fn pkeikg(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PKEIKG"]
            #[inline(always)]
            pub fn set_pkeikg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cryptomaster", &self.cryptomaster())
                    .field("rng", &self.rng())
                    .field("pkeikg", &self.pkeikg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    cryptomaster: bool,
                    rng: bool,
                    pkeikg: bool,
                }
                let proxy = Int {
                    cryptomaster: self.cryptomaster(),
                    rng: self.rng(),
                    pkeikg: self.pkeikg(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Lock the access to the protected RAM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Protectedramlock(pub u32);
        impl Protectedramlock {
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Protectedramlock {
            #[inline(always)]
            fn default() -> Protectedramlock {
                Protectedramlock(0)
            }
        }
        impl core::fmt::Debug for Protectedramlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Protectedramlock")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Protectedramlock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Protectedramlock {
                    enable: bool,
                }
                let proxy = Protectedramlock {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Lock the access to the SEED register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seedlock(pub u32);
        impl Seedlock {
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the lock"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Seedlock {
            #[inline(always)]
            fn default() -> Seedlock {
                Seedlock(0)
            }
        }
        impl core::fmt::Debug for Seedlock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seedlock")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seedlock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Seedlock {
                    enable: bool,
                }
                let proxy = Seedlock {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Marks the SEED register as valid"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seedvalid(pub u32);
        impl Seedvalid {
            #[doc = "Marks the SEED as valid"]
            #[inline(always)]
            pub const fn valid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Marks the SEED as valid"]
            #[inline(always)]
            pub fn set_valid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Seedvalid {
            #[inline(always)]
            fn default() -> Seedvalid {
                Seedvalid(0)
            }
        }
        impl core::fmt::Debug for Seedvalid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seedvalid")
                    .field("valid", &self.valid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seedvalid {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Seedvalid {
                    valid: bool,
                }
                let proxy = Seedvalid {
                    valid: self.valid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod cracencore {
    #[doc = "CRACENCORE"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracencore {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracencore {}
    unsafe impl Sync for Cracencore {}
    impl Cracencore {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cryptmstrdma(self) -> Cryptmstrdma {
            unsafe { Cryptmstrdma::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cryptmstrhw(self) -> Cryptmstrhw {
            unsafe { Cryptmstrhw::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rngcontrol(self) -> Rngcontrol {
            unsafe { Rngcontrol::from_ptr(self.ptr.add(0x1000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pk(self) -> Pk {
            unsafe { Pk::from_ptr(self.ptr.add(0x2000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ikg(self) -> Ikg {
            unsafe { Ikg::from_ptr(self.ptr.add(0x3000usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptmstrdma {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptmstrdma {}
    unsafe impl Sync for Cryptmstrdma {}
    impl Cryptmstrdma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Fetch Address Least Significant Bit"]
        #[inline(always)]
        pub const fn fetchaddrlsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Fetch Address Most Significant Bit"]
        #[inline(always)]
        pub const fn fetchaddrmsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Fetch Length"]
        #[inline(always)]
        pub const fn fetchlen(self) -> crate::common::Reg<regs::Fetchlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Fetch Tag"]
        #[inline(always)]
        pub const fn fetchtag(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Push Address Least Significant Bit"]
        #[inline(always)]
        pub const fn pushaddrlsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Push Address Most Significant Bit"]
        #[inline(always)]
        pub const fn pushaddrmsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Push Length"]
        #[inline(always)]
        pub const fn pushlen(self) -> crate::common::Reg<regs::Pushlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Interrupt Enable"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Interrupt Set"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Interrupt Clear"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Interrupt Status Raw"]
        #[inline(always)]
        pub const fn intstatraw(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Interrupt Status"]
        #[inline(always)]
        pub const fn intstat(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Interrupt Status Clear"]
        #[inline(always)]
        pub const fn intstatclr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Start"]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::CryptmstrdmaStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::CryptmstrdmaStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cryptmstrhw {
        ptr: *mut u8,
    }
    unsafe impl Send for Cryptmstrhw {}
    unsafe impl Sync for Cryptmstrhw {}
    impl Cryptmstrhw {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Incuded IPs Hardware configuration"]
        #[inline(always)]
        pub const fn inclipshwcfg(
            self,
        ) -> crate::common::Reg<regs::Inclipshwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generic g_AesModesPoss value."]
        #[inline(always)]
        pub const fn ba411eaeshwcfg1(
            self,
        ) -> crate::common::Reg<regs::Ba411eaeshwcfg1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Generic g_CtrSize value."]
        #[inline(always)]
        pub const fn ba411eaeshwcfg2(
            self,
        ) -> crate::common::Reg<regs::Ba411eaeshwcfg2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Generic g_Hash value"]
        #[inline(always)]
        pub const fn ba413hashhwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba413hashhwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Generic g_Sha3CtxtEn value."]
        #[inline(always)]
        pub const fn ba418sha3hwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba418sha3hwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Generic g_SM4ModesPoss value."]
        #[inline(always)]
        pub const fn ba419sm4hwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba419sm4hwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Generic g_aria_modePoss value."]
        #[inline(always)]
        pub const fn ba424ariahwcfg(
            self,
        ) -> crate::common::Reg<regs::Ba424ariahwcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ikg {
        ptr: *mut u8,
    }
    unsafe impl Send for Ikg {}
    unsafe impl Sync for Ikg {}
    impl Ikg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start register."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<regs::IkgStart, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::IkgStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "InitData register."]
        #[inline(always)]
        pub const fn initdata(self) -> crate::common::Reg<regs::Initdata, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Nonce register."]
        #[inline(always)]
        pub const fn nonce(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Personalisation String register."]
        #[inline(always)]
        pub const fn personalisationstring(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Reseed Interval LSB register."]
        #[inline(always)]
        pub const fn reseedintervallsb(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Reseed Interval MSB register."]
        #[inline(always)]
        pub const fn reseedintervalmsb(
            self,
        ) -> crate::common::Reg<regs::Reseedintervalmsb, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "PKE Control register."]
        #[inline(always)]
        pub const fn pkecontrol(self) -> crate::common::Reg<regs::Pkecontrol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "PKE Command register."]
        #[inline(always)]
        pub const fn pkecommand(self) -> crate::common::Reg<regs::Pkecommand, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "PKE Status register."]
        #[inline(always)]
        pub const fn pkestatus(self) -> crate::common::Reg<regs::Pkestatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "SoftRst register."]
        #[inline(always)]
        pub const fn softrst(self) -> crate::common::Reg<regs::Softrst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "HwConfig register."]
        #[inline(always)]
        pub const fn hwconfig(self) -> crate::common::Reg<regs::IkgHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pk {
        ptr: *mut u8,
    }
    unsafe impl Send for Pk {}
    unsafe impl Sync for Pk {}
    impl Pk {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pointers register."]
        #[inline(always)]
        pub const fn pointers(self) -> crate::common::Reg<regs::Pointers, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Command register."]
        #[inline(always)]
        pub const fn command(self) -> crate::common::Reg<regs::Command, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Command register."]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::PkControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::PkStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Timer register."]
        #[inline(always)]
        pub const fn timer(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Hardware configuration register."]
        #[inline(always)]
        pub const fn hwconfig(self) -> crate::common::Reg<regs::PkHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Operand size register."]
        #[inline(always)]
        pub const fn opsize(self) -> crate::common::Reg<regs::Opsize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "RAM error injection register."]
        #[inline(always)]
        pub const fn ramerrorinject(
            self,
        ) -> crate::common::Reg<regs::Ramerrorinject, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "RAM error status register."]
        #[inline(always)]
        pub const fn ramerrorstatus(
            self,
        ) -> crate::common::Reg<regs::Ramerrorstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rngcontrol {
        ptr: *mut u8,
    }
    unsafe impl Send for Rngcontrol {}
    unsafe impl Sync for Rngcontrol {}
    impl Rngcontrol {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register"]
        #[inline(always)]
        pub const fn control(
            self,
        ) -> crate::common::Reg<regs::RngcontrolControl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "FIFO level register."]
        #[inline(always)]
        pub const fn fifolevel(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "FIFO threshold register."]
        #[inline(always)]
        pub const fn fifothreshold(
            self,
        ) -> crate::common::Reg<regs::Fifothreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "FIFO depth register."]
        #[inline(always)]
        pub const fn fifodepth(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Description collection: Key register."]
        #[inline(always)]
        pub const fn key(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
        #[doc = "Test data register."]
        #[inline(always)]
        pub const fn testdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Repetition Test Count Cut-Off value."]
        #[inline(always)]
        pub const fn repeatthreshold(
            self,
        ) -> crate::common::Reg<regs::Repeatthreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
        #[inline(always)]
        pub const fn propthreshold(
            self,
        ) -> crate::common::Reg<regs::Propthreshold, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Status register."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::RngcontrolStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Initial wait counter value."]
        #[inline(always)]
        pub const fn initwaitval(self) -> crate::common::Reg<regs::Initwaitval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Description collection: Disable oscillator rings #n*32 to #((n+1)*32)-1."]
        #[inline(always)]
        pub const fn disableosc(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize + n * 4usize) as _) }
        }
        #[doc = "Switch off timer value."]
        #[inline(always)]
        pub const fn swofftmrval(self) -> crate::common::Reg<regs::Swofftmrval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Sample clock divider."]
        #[inline(always)]
        pub const fn clkdiv(self) -> crate::common::Reg<regs::Clkdiv, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "AIS31 configuration register 0."]
        #[inline(always)]
        pub const fn ais31conf0(self) -> crate::common::Reg<regs::Ais31conf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "AIS31 configuration register 1."]
        #[inline(always)]
        pub const fn ais31conf1(self) -> crate::common::Reg<regs::Ais31conf1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "AIS31 configuration register 2."]
        #[inline(always)]
        pub const fn ais31conf2(self) -> crate::common::Reg<regs::Ais31conf2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "AIS31 status register."]
        #[inline(always)]
        pub const fn ais31status(self) -> crate::common::Reg<regs::Ais31status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Hardware configuration register."]
        #[inline(always)]
        pub const fn hwconfig(
            self,
        ) -> crate::common::Reg<regs::RngcontrolHwconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Description collection: FIFO data"]
        #[inline(always)]
        pub const fn fifo(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "AIS31 configuration register 0."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31conf0(pub u32);
        impl Ais31conf0 {
            #[doc = "Start-up test threshold."]
            #[inline(always)]
            pub const fn startupthreshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Start-up test threshold."]
            #[inline(always)]
            pub fn set_startupthreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
            #[doc = "Online threshold."]
            #[inline(always)]
            pub const fn onlinethreshold(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x7fff;
                val as u16
            }
            #[doc = "Online threshold."]
            #[inline(always)]
            pub fn set_onlinethreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 16usize)) | (((val as u32) & 0x7fff) << 16usize);
            }
        }
        impl Default for Ais31conf0 {
            #[inline(always)]
            fn default() -> Ais31conf0 {
                Ais31conf0(0)
            }
        }
        impl core::fmt::Debug for Ais31conf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31conf0")
                    .field("startupthreshold", &self.startupthreshold())
                    .field("onlinethreshold", &self.onlinethreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31conf0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ais31conf0 {
                    startupthreshold: u16,
                    onlinethreshold: u16,
                }
                let proxy = Ais31conf0 {
                    startupthreshold: self.startupthreshold(),
                    onlinethreshold: self.onlinethreshold(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "AIS31 configuration register 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31conf1(pub u32);
        impl Ais31conf1 {
            #[doc = "Online repeat threshold."]
            #[inline(always)]
            pub const fn onlinerepthreshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Online repeat threshold."]
            #[inline(always)]
            pub fn set_onlinerepthreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
            #[doc = "Expected history value."]
            #[inline(always)]
            pub const fn hexpectedvalue(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x7fff;
                val as u16
            }
            #[doc = "Expected history value."]
            #[inline(always)]
            pub fn set_hexpectedvalue(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 16usize)) | (((val as u32) & 0x7fff) << 16usize);
            }
        }
        impl Default for Ais31conf1 {
            #[inline(always)]
            fn default() -> Ais31conf1 {
                Ais31conf1(0)
            }
        }
        impl core::fmt::Debug for Ais31conf1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31conf1")
                    .field("onlinerepthreshold", &self.onlinerepthreshold())
                    .field("hexpectedvalue", &self.hexpectedvalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31conf1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ais31conf1 {
                    onlinerepthreshold: u16,
                    hexpectedvalue: u16,
                }
                let proxy = Ais31conf1 {
                    onlinerepthreshold: self.onlinerepthreshold(),
                    hexpectedvalue: self.hexpectedvalue(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "AIS31 configuration register 2."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31conf2(pub u32);
        impl Ais31conf2 {
            #[doc = "Minimum allowed history value."]
            #[inline(always)]
            pub const fn hmin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Minimum allowed history value."]
            #[inline(always)]
            pub fn set_hmin(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
            #[doc = "Maximum allowed history value."]
            #[inline(always)]
            pub const fn hmax(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum allowed history value."]
            #[inline(always)]
            pub fn set_hmax(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 16usize)) | (((val as u32) & 0x7fff) << 16usize);
            }
        }
        impl Default for Ais31conf2 {
            #[inline(always)]
            fn default() -> Ais31conf2 {
                Ais31conf2(0)
            }
        }
        impl core::fmt::Debug for Ais31conf2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31conf2")
                    .field("hmin", &self.hmin())
                    .field("hmax", &self.hmax())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31conf2 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ais31conf2 {
                    hmin: u16,
                    hmax: u16,
                }
                let proxy = Ais31conf2 {
                    hmin: self.hmin(),
                    hmax: self.hmax(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "AIS31 status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ais31status(pub u32);
        impl Ais31status {
            #[doc = "Number of preliminary noise alarms since counter was last cleared."]
            #[inline(always)]
            pub const fn numprelimalarms(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of preliminary noise alarms since counter was last cleared."]
            #[inline(always)]
            pub fn set_numprelimalarms(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Last preliminary noise alarm occurred due to history value out of range."]
            #[inline(always)]
            pub const fn prelimnoisealarmrng(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Last preliminary noise alarm occurred due to history value out of range."]
            #[inline(always)]
            pub fn set_prelimnoisealarmrng(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Last preliminary noise alarm occurred due to consecutive high Χ**2."]
            #[inline(always)]
            pub const fn prelimnoisealarmrep(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Last preliminary noise alarm occurred due to consecutive high Χ**2."]
            #[inline(always)]
            pub fn set_prelimnoisealarmrep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Ais31status {
            #[inline(always)]
            fn default() -> Ais31status {
                Ais31status(0)
            }
        }
        impl core::fmt::Debug for Ais31status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ais31status")
                    .field("numprelimalarms", &self.numprelimalarms())
                    .field("prelimnoisealarmrng", &self.prelimnoisealarmrng())
                    .field("prelimnoisealarmrep", &self.prelimnoisealarmrep())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ais31status {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ais31status {
                    numprelimalarms: u16,
                    prelimnoisealarmrng: bool,
                    prelimnoisealarmrep: bool,
                }
                let proxy = Ais31status {
                    numprelimalarms: self.numprelimalarms(),
                    prelimnoisealarmrng: self.prelimnoisealarmrng(),
                    prelimnoisealarmrep: self.prelimnoisealarmrep(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Generic g_AesModesPoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba411eaeshwcfg1(pub u32);
        impl Ba411eaeshwcfg1 {
            #[doc = "Generic g_AesModesPoss value."]
            #[inline(always)]
            pub const fn ba411eaeshwcfgmode(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_AesModesPoss value."]
            #[inline(always)]
            pub fn set_ba411eaeshwcfgmode(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Generic g_CS value."]
            #[inline(always)]
            pub const fn ba411eaeshwcfgcs(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_CS value."]
            #[inline(always)]
            pub fn set_ba411eaeshwcfgcs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Generic g_UseMasking value."]
            #[inline(always)]
            pub const fn ba411eaeshwcfgmasking(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_UseMasking value."]
            #[inline(always)]
            pub fn set_ba411eaeshwcfgmasking(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Generic g_Keysize value."]
            #[inline(always)]
            pub const fn ba411eaeshwcfgkeysize(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x07;
                val as u8
            }
            #[doc = "Generic g_Keysize value."]
            #[inline(always)]
            pub fn set_ba411eaeshwcfgkeysize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 24usize)) | (((val as u32) & 0x07) << 24usize);
            }
        }
        impl Default for Ba411eaeshwcfg1 {
            #[inline(always)]
            fn default() -> Ba411eaeshwcfg1 {
                Ba411eaeshwcfg1(0)
            }
        }
        impl core::fmt::Debug for Ba411eaeshwcfg1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba411eaeshwcfg1")
                    .field("ba411eaeshwcfgmode", &self.ba411eaeshwcfgmode())
                    .field("ba411eaeshwcfgcs", &self.ba411eaeshwcfgcs())
                    .field("ba411eaeshwcfgmasking", &self.ba411eaeshwcfgmasking())
                    .field("ba411eaeshwcfgkeysize", &self.ba411eaeshwcfgkeysize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba411eaeshwcfg1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ba411eaeshwcfg1 {
                    ba411eaeshwcfgmode: u16,
                    ba411eaeshwcfgcs: bool,
                    ba411eaeshwcfgmasking: bool,
                    ba411eaeshwcfgkeysize: u8,
                }
                let proxy = Ba411eaeshwcfg1 {
                    ba411eaeshwcfgmode: self.ba411eaeshwcfgmode(),
                    ba411eaeshwcfgcs: self.ba411eaeshwcfgcs(),
                    ba411eaeshwcfgmasking: self.ba411eaeshwcfgmasking(),
                    ba411eaeshwcfgkeysize: self.ba411eaeshwcfgkeysize(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Generic g_CtrSize value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba411eaeshwcfg2(pub u32);
        impl Ba411eaeshwcfg2 {
            #[doc = "Generic g_CtrSize value."]
            #[inline(always)]
            pub const fn ba411eaeshwcfg2(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Generic g_CtrSize value."]
            #[inline(always)]
            pub fn set_ba411eaeshwcfg2(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Ba411eaeshwcfg2 {
            #[inline(always)]
            fn default() -> Ba411eaeshwcfg2 {
                Ba411eaeshwcfg2(0)
            }
        }
        impl core::fmt::Debug for Ba411eaeshwcfg2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba411eaeshwcfg2")
                    .field("ba411eaeshwcfg2", &self.ba411eaeshwcfg2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba411eaeshwcfg2 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ba411eaeshwcfg2 {
                    ba411eaeshwcfg2: u16,
                }
                let proxy = Ba411eaeshwcfg2 {
                    ba411eaeshwcfg2: self.ba411eaeshwcfg2(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Generic g_Hash value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba413hashhwcfg(pub u32);
        impl Ba413hashhwcfg {
            #[doc = "Generic g_HashMaskFunc value."]
            #[inline(always)]
            pub const fn ba413hashhwcfgmask(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Generic g_HashMaskFunc value."]
            #[inline(always)]
            pub fn set_ba413hashhwcfgmask(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Generic g_HashPadding value."]
            #[inline(always)]
            pub const fn ba413hashhwcfgpadding(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HashPadding value."]
            #[inline(always)]
            pub fn set_ba413hashhwcfgpadding(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Generic g_HMAC_enabled value."]
            #[inline(always)]
            pub const fn ba413hashhwcfghmac(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HMAC_enabled value."]
            #[inline(always)]
            pub fn set_ba413hashhwcfghmac(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Generic g_HashVerifyDigest value."]
            #[inline(always)]
            pub const fn ba413hashhwcfgverifydigest(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_HashVerifyDigest value."]
            #[inline(always)]
            pub fn set_ba413hashhwcfgverifydigest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Ba413hashhwcfg {
            #[inline(always)]
            fn default() -> Ba413hashhwcfg {
                Ba413hashhwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba413hashhwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba413hashhwcfg")
                    .field("ba413hashhwcfgmask", &self.ba413hashhwcfgmask())
                    .field("ba413hashhwcfgpadding", &self.ba413hashhwcfgpadding())
                    .field("ba413hashhwcfghmac", &self.ba413hashhwcfghmac())
                    .field(
                        "ba413hashhwcfgverifydigest",
                        &self.ba413hashhwcfgverifydigest(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba413hashhwcfg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ba413hashhwcfg {
                    ba413hashhwcfgmask: u8,
                    ba413hashhwcfgpadding: bool,
                    ba413hashhwcfghmac: bool,
                    ba413hashhwcfgverifydigest: bool,
                }
                let proxy = Ba413hashhwcfg {
                    ba413hashhwcfgmask: self.ba413hashhwcfgmask(),
                    ba413hashhwcfgpadding: self.ba413hashhwcfgpadding(),
                    ba413hashhwcfghmac: self.ba413hashhwcfghmac(),
                    ba413hashhwcfgverifydigest: self.ba413hashhwcfgverifydigest(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Generic g_Sha3CtxtEn value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba418sha3hwcfg(pub u32);
        impl Ba418sha3hwcfg {
            #[doc = "Generic g_Sha3CtxtEn value."]
            #[inline(always)]
            pub const fn ba418sha3hwcfg(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_Sha3CtxtEn value."]
            #[inline(always)]
            pub fn set_ba418sha3hwcfg(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ba418sha3hwcfg {
            #[inline(always)]
            fn default() -> Ba418sha3hwcfg {
                Ba418sha3hwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba418sha3hwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba418sha3hwcfg")
                    .field("ba418sha3hwcfg", &self.ba418sha3hwcfg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba418sha3hwcfg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ba418sha3hwcfg {
                    ba418sha3hwcfg: bool,
                }
                let proxy = Ba418sha3hwcfg {
                    ba418sha3hwcfg: self.ba418sha3hwcfg(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Generic g_SM4ModesPoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba419sm4hwcfg(pub u32);
        impl Ba419sm4hwcfg {
            #[doc = "Generic g_SM4ModesPoss value."]
            #[inline(always)]
            pub const fn ba419sm4hwcfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Generic g_SM4ModesPoss value."]
            #[inline(always)]
            pub fn set_ba419sm4hwcfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Generic g_sm4UseMasking value."]
            #[inline(always)]
            pub const fn usemasking(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_sm4UseMasking value."]
            #[inline(always)]
            pub fn set_usemasking(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Ba419sm4hwcfg {
            #[inline(always)]
            fn default() -> Ba419sm4hwcfg {
                Ba419sm4hwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba419sm4hwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba419sm4hwcfg")
                    .field("ba419sm4hwcfg", &self.ba419sm4hwcfg())
                    .field("usemasking", &self.usemasking())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba419sm4hwcfg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ba419sm4hwcfg {
                    ba419sm4hwcfg: u16,
                    usemasking: bool,
                }
                let proxy = Ba419sm4hwcfg {
                    ba419sm4hwcfg: self.ba419sm4hwcfg(),
                    usemasking: self.usemasking(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Generic g_aria_modePoss value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ba424ariahwcfg(pub u32);
        impl Ba424ariahwcfg {
            #[doc = "Generic g_aria_modePoss value."]
            #[inline(always)]
            pub const fn ba424ariahwcfg(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Generic g_aria_modePoss value."]
            #[inline(always)]
            pub fn set_ba424ariahwcfg(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Ba424ariahwcfg {
            #[inline(always)]
            fn default() -> Ba424ariahwcfg {
                Ba424ariahwcfg(0)
            }
        }
        impl core::fmt::Debug for Ba424ariahwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ba424ariahwcfg")
                    .field("ba424ariahwcfg", &self.ba424ariahwcfg())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ba424ariahwcfg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ba424ariahwcfg {
                    ba424ariahwcfg: u16,
                }
                let proxy = Ba424ariahwcfg {
                    ba424ariahwcfg: self.ba424ariahwcfg(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sample clock divider."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkdiv(pub u32);
        impl Clkdiv {
            #[doc = "Sample clock divider."]
            #[inline(always)]
            pub const fn clkdiv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Sample clock divider."]
            #[inline(always)]
            pub fn set_clkdiv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Clkdiv {
            #[inline(always)]
            fn default() -> Clkdiv {
                Clkdiv(0)
            }
        }
        impl core::fmt::Debug for Clkdiv {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkdiv")
                    .field("clkdiv", &self.clkdiv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkdiv {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Clkdiv {
                    clkdiv: u8,
                }
                let proxy = Clkdiv {
                    clkdiv: self.clkdiv(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Command(pub u32);
        impl Command {
            #[doc = "This field defines the operation to be performed."]
            #[inline(always)]
            pub const fn opeaddr(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "This field defines the operation to be performed."]
            #[inline(always)]
            pub fn set_opeaddr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "0: Field is GF(p) 1: Field is GF(2**m)"]
            #[inline(always)]
            pub const fn fieldf(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "0: Field is GF(p) 1: Field is GF(2**m)"]
            #[inline(always)]
            pub fn set_fieldf(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "This field defines the size (= number of bytes minus one) of the operands for the current operation."]
            #[inline(always)]
            pub const fn opbytesm1(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x03ff;
                val as u16
            }
            #[doc = "This field defines the size (= number of bytes minus one) of the operands for the current operation."]
            #[inline(always)]
            pub fn set_opbytesm1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 8usize)) | (((val as u32) & 0x03ff) << 8usize);
            }
            #[doc = "Enable randomization of modulus (counter-measure)."]
            #[inline(always)]
            pub const fn randmod(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of modulus (counter-measure)."]
            #[inline(always)]
            pub fn set_randmod(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable accelerator for specific curve modulus:"]
            #[inline(always)]
            pub const fn selcurve(&self) -> super::vals::Selcurve {
                let val = (self.0 >> 20usize) & 0x07;
                super::vals::Selcurve::from_bits(val as u8)
            }
            #[doc = "Enable accelerator for specific curve modulus:"]
            #[inline(always)]
            pub fn set_selcurve(&mut self, val: super::vals::Selcurve) {
                self.0 =
                    (self.0 & !(0x07 << 20usize)) | (((val.to_bits() as u32) & 0x07) << 20usize);
            }
            #[doc = "Enable randomization of exponent/scalar (counter-measure)."]
            #[inline(always)]
            pub const fn randke(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of exponent/scalar (counter-measure)."]
            #[inline(always)]
            pub fn set_randke(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable randomization of projective coordinates (counter-measure)."]
            #[inline(always)]
            pub const fn randproj(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable randomization of projective coordinates (counter-measure)."]
            #[inline(always)]
            pub fn set_randproj(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable Edwards curve."]
            #[inline(always)]
            pub const fn edwards(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Edwards curve."]
            #[inline(always)]
            pub fn set_edwards(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Swap the bytes on AHB interface:"]
            #[inline(always)]
            pub const fn swapbytes(&self) -> super::vals::Swapbytes {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Swapbytes::from_bits(val as u8)
            }
            #[doc = "Swap the bytes on AHB interface:"]
            #[inline(always)]
            pub fn set_swapbytes(&mut self, val: super::vals::Swapbytes) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Flag A."]
            #[inline(always)]
            pub const fn flaga(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Flag A."]
            #[inline(always)]
            pub fn set_flaga(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Flag B."]
            #[inline(always)]
            pub const fn flagb(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Flag B."]
            #[inline(always)]
            pub fn set_flagb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "This bit indicates if the IP has to calculate R**2 mod N for the next operation."]
            #[inline(always)]
            pub const fn calcr2(&self) -> super::vals::Calcr2 {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Calcr2::from_bits(val as u8)
            }
            #[doc = "This bit indicates if the IP has to calculate R**2 mod N for the next operation."]
            #[inline(always)]
            pub fn set_calcr2(&mut self, val: super::vals::Calcr2) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Command {
            #[inline(always)]
            fn default() -> Command {
                Command(0)
            }
        }
        impl core::fmt::Debug for Command {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Command")
                    .field("opeaddr", &self.opeaddr())
                    .field("fieldf", &self.fieldf())
                    .field("opbytesm1", &self.opbytesm1())
                    .field("randmod", &self.randmod())
                    .field("selcurve", &self.selcurve())
                    .field("randke", &self.randke())
                    .field("randproj", &self.randproj())
                    .field("edwards", &self.edwards())
                    .field("swapbytes", &self.swapbytes())
                    .field("flaga", &self.flaga())
                    .field("flagb", &self.flagb())
                    .field("calcr2", &self.calcr2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Command {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Command {
                    opeaddr: u8,
                    fieldf: bool,
                    opbytesm1: u16,
                    randmod: bool,
                    selcurve: super::vals::Selcurve,
                    randke: bool,
                    randproj: bool,
                    edwards: bool,
                    swapbytes: super::vals::Swapbytes,
                    flaga: bool,
                    flagb: bool,
                    calcr2: super::vals::Calcr2,
                }
                let proxy = Command {
                    opeaddr: self.opeaddr(),
                    fieldf: self.fieldf(),
                    opbytesm1: self.opbytesm1(),
                    randmod: self.randmod(),
                    selcurve: self.selcurve(),
                    randke: self.randke(),
                    randproj: self.randproj(),
                    edwards: self.edwards(),
                    swapbytes: self.swapbytes(),
                    flaga: self.flaga(),
                    flagb: self.flagb(),
                    calcr2: self.calcr2(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[inline(always)]
            pub const fn fetchctrlindirect(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchctrlindirect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn pushctrlindirect(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushctrlindirect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn fetchstop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchstop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn pushstop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushstop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[inline(always)]
            pub const fn softrst(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_softrst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("fetchctrlindirect", &self.fetchctrlindirect())
                    .field("pushctrlindirect", &self.pushctrlindirect())
                    .field("fetchstop", &self.fetchstop())
                    .field("pushstop", &self.pushstop())
                    .field("softrst", &self.softrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    fetchctrlindirect: bool,
                    pushctrlindirect: bool,
                    fetchstop: bool,
                    pushstop: bool,
                    softrst: bool,
                }
                let proxy = Config {
                    fetchctrlindirect: self.fetchctrlindirect(),
                    pushctrlindirect: self.pushctrlindirect(),
                    fetchstop: self.fetchstop(),
                    pushstop: self.pushstop(),
                    softrst: self.softrst(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Start"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptmstrdmaStart(pub u32);
        impl CryptmstrdmaStart {
            #[inline(always)]
            pub const fn startfetch(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_startfetch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn startpush(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_startpush(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CryptmstrdmaStart {
            #[inline(always)]
            fn default() -> CryptmstrdmaStart {
                CryptmstrdmaStart(0)
            }
        }
        impl core::fmt::Debug for CryptmstrdmaStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptmstrdmaStart")
                    .field("startfetch", &self.startfetch())
                    .field("startpush", &self.startpush())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptmstrdmaStart {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct CryptmstrdmaStart {
                    startfetch: bool,
                    startpush: bool,
                }
                let proxy = CryptmstrdmaStart {
                    startfetch: self.startfetch(),
                    startpush: self.startpush(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CryptmstrdmaStatus(pub u32);
        impl CryptmstrdmaStatus {
            #[inline(always)]
            pub const fn fetchbusy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn pushbusy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn fetchnotempty(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchnotempty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[inline(always)]
            pub const fn pushwaitingfifo(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushwaitingfifo(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[inline(always)]
            pub const fn softrstbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_softrstbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[inline(always)]
            pub const fn pushnbdata(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub fn set_pushnbdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for CryptmstrdmaStatus {
            #[inline(always)]
            fn default() -> CryptmstrdmaStatus {
                CryptmstrdmaStatus(0)
            }
        }
        impl core::fmt::Debug for CryptmstrdmaStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CryptmstrdmaStatus")
                    .field("fetchbusy", &self.fetchbusy())
                    .field("pushbusy", &self.pushbusy())
                    .field("fetchnotempty", &self.fetchnotempty())
                    .field("pushwaitingfifo", &self.pushwaitingfifo())
                    .field("softrstbusy", &self.softrstbusy())
                    .field("pushnbdata", &self.pushnbdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CryptmstrdmaStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct CryptmstrdmaStatus {
                    fetchbusy: bool,
                    pushbusy: bool,
                    fetchnotempty: bool,
                    pushwaitingfifo: bool,
                    softrstbusy: bool,
                    pushnbdata: u16,
                }
                let proxy = CryptmstrdmaStatus {
                    fetchbusy: self.fetchbusy(),
                    pushbusy: self.pushbusy(),
                    fetchnotempty: self.fetchnotempty(),
                    pushwaitingfifo: self.pushwaitingfifo(),
                    softrstbusy: self.softrstbusy(),
                    pushnbdata: self.pushnbdata(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Fetch Length"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fetchlen(pub u32);
        impl Fetchlen {
            #[inline(always)]
            pub const fn fetchlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[inline(always)]
            pub fn set_fetchlen(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[inline(always)]
            pub const fn fetchcstaddr(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchcstaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[inline(always)]
            pub const fn fetchrealign(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchrealign(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[inline(always)]
            pub const fn fetchzpadding(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_fetchzpadding(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Fetchlen {
            #[inline(always)]
            fn default() -> Fetchlen {
                Fetchlen(0)
            }
        }
        impl core::fmt::Debug for Fetchlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fetchlen")
                    .field("fetchlen", &self.fetchlen())
                    .field("fetchcstaddr", &self.fetchcstaddr())
                    .field("fetchrealign", &self.fetchrealign())
                    .field("fetchzpadding", &self.fetchzpadding())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fetchlen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Fetchlen {
                    fetchlen: u32,
                    fetchcstaddr: bool,
                    fetchrealign: bool,
                    fetchzpadding: bool,
                }
                let proxy = Fetchlen {
                    fetchlen: self.fetchlen(),
                    fetchcstaddr: self.fetchcstaddr(),
                    fetchrealign: self.fetchrealign(),
                    fetchzpadding: self.fetchzpadding(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "FIFO threshold register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fifothreshold(pub u32);
        impl Fifothreshold {
            #[doc = "FIFO level below which the module leaves the idle state to refill the FIFO, expressed in number of 128bit blocks."]
            #[inline(always)]
            pub const fn fifothreshold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "FIFO level below which the module leaves the idle state to refill the FIFO, expressed in number of 128bit blocks."]
            #[inline(always)]
            pub fn set_fifothreshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Fifothreshold {
            #[inline(always)]
            fn default() -> Fifothreshold {
                Fifothreshold(0)
            }
        }
        impl core::fmt::Debug for Fifothreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fifothreshold")
                    .field("fifothreshold", &self.fifothreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fifothreshold {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Fifothreshold {
                    fifothreshold: u8,
                }
                let proxy = Fifothreshold {
                    fifothreshold: self.fifothreshold(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "HwConfig register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgHwconfig(pub u32);
        impl IkgHwconfig {
            #[doc = "Number of Symmetric Keys generated."]
            #[inline(always)]
            pub const fn nbsymkeys(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of Symmetric Keys generated."]
            #[inline(always)]
            pub fn set_nbsymkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Number of Private Keys generated."]
            #[inline(always)]
            pub const fn nbprivkeys(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of Private Keys generated."]
            #[inline(always)]
            pub fn set_nbprivkeys(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Countermeasures for IKG operations are implemented when 1."]
            #[inline(always)]
            pub const fn ikgcm(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Countermeasures for IKG operations are implemented when 1."]
            #[inline(always)]
            pub fn set_ikgcm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "CTR_DRBG health test is implemented when 1."]
            #[inline(always)]
            pub const fn hwhealthtest(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "CTR_DRBG health test is implemented when 1."]
            #[inline(always)]
            pub fn set_hwhealthtest(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "ECC curve for IKG (input)."]
            #[inline(always)]
            pub const fn curve(&self) -> super::vals::Curve {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Curve::from_bits(val as u8)
            }
            #[doc = "ECC curve for IKG (input)."]
            #[inline(always)]
            pub fn set_curve(&mut self, val: super::vals::Curve) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Derivation function is implemented in the CTR_DRBG when 1."]
            #[inline(always)]
            pub const fn df(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Derivation function is implemented in the CTR_DRBG when 1."]
            #[inline(always)]
            pub fn set_df(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "AES Key Size support for the AES Core embedded in the CTR_DRBG."]
            #[inline(always)]
            pub const fn keysize(&self) -> super::vals::Keysize {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::Keysize::from_bits(val as u8)
            }
            #[doc = "AES Key Size support for the AES Core embedded in the CTR_DRBG."]
            #[inline(always)]
            pub fn set_keysize(&mut self, val: super::vals::Keysize) {
                self.0 =
                    (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "Value of g_entropy_input_length/32."]
            #[inline(always)]
            pub const fn entropyinputlength(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_entropy_input_length/32."]
            #[inline(always)]
            pub fn set_entropyinputlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Value of g_nonce_length/32."]
            #[inline(always)]
            pub const fn noncelength(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_nonce_length/32."]
            #[inline(always)]
            pub fn set_noncelength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
            #[doc = "Value of g_personalization_string_length/32."]
            #[inline(always)]
            pub const fn personalizationstringlength(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_personalization_string_length/32."]
            #[inline(always)]
            pub fn set_personalizationstringlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
            #[doc = "Value of g_additional_input_length/32."]
            #[inline(always)]
            pub const fn additionalinputlength(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x0f;
                val as u8
            }
            #[doc = "Value of g_additional_input_length/32."]
            #[inline(always)]
            pub fn set_additionalinputlength(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 28usize)) | (((val as u32) & 0x0f) << 28usize);
            }
        }
        impl Default for IkgHwconfig {
            #[inline(always)]
            fn default() -> IkgHwconfig {
                IkgHwconfig(0)
            }
        }
        impl core::fmt::Debug for IkgHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgHwconfig")
                    .field("nbsymkeys", &self.nbsymkeys())
                    .field("nbprivkeys", &self.nbprivkeys())
                    .field("ikgcm", &self.ikgcm())
                    .field("hwhealthtest", &self.hwhealthtest())
                    .field("curve", &self.curve())
                    .field("df", &self.df())
                    .field("keysize", &self.keysize())
                    .field("entropyinputlength", &self.entropyinputlength())
                    .field("noncelength", &self.noncelength())
                    .field(
                        "personalizationstringlength",
                        &self.personalizationstringlength(),
                    )
                    .field("additionalinputlength", &self.additionalinputlength())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgHwconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct IkgHwconfig {
                    nbsymkeys: u8,
                    nbprivkeys: u8,
                    ikgcm: bool,
                    hwhealthtest: bool,
                    curve: super::vals::Curve,
                    df: bool,
                    keysize: super::vals::Keysize,
                    entropyinputlength: u8,
                    noncelength: u8,
                    personalizationstringlength: u8,
                    additionalinputlength: u8,
                }
                let proxy = IkgHwconfig {
                    nbsymkeys: self.nbsymkeys(),
                    nbprivkeys: self.nbprivkeys(),
                    ikgcm: self.ikgcm(),
                    hwhealthtest: self.hwhealthtest(),
                    curve: self.curve(),
                    df: self.df(),
                    keysize: self.keysize(),
                    entropyinputlength: self.entropyinputlength(),
                    noncelength: self.noncelength(),
                    personalizationstringlength: self.personalizationstringlength(),
                    additionalinputlength: self.additionalinputlength(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Start register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgStart(pub u32);
        impl IkgStart {
            #[doc = "Start the Isolated Key Generation."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the Isolated Key Generation."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for IkgStart {
            #[inline(always)]
            fn default() -> IkgStart {
                IkgStart(0)
            }
        }
        impl core::fmt::Debug for IkgStart {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgStart")
                    .field("start", &self.start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgStart {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct IkgStart {
                    start: bool,
                }
                let proxy = IkgStart {
                    start: self.start(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IkgStatus(pub u32);
        impl IkgStatus {
            #[doc = "Seed Error during Isolated Key Generation."]
            #[inline(always)]
            pub const fn seederror(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Seed Error during Isolated Key Generation."]
            #[inline(always)]
            pub fn set_seederror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Entropy Error during Isolated Key Generation."]
            #[inline(always)]
            pub const fn entropyerror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Entropy Error during Isolated Key Generation."]
            #[inline(always)]
            pub fn set_entropyerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Isolated Key Generation is okay."]
            #[inline(always)]
            pub const fn okay(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Isolated Key Generation is okay."]
            #[inline(always)]
            pub fn set_okay(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CTR_DRBG health test is busy (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub const fn ctrdrbgbusy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CTR_DRBG health test is busy (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub fn set_ctrdrbgbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Catastrophic error during CTR_DRBG health test (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub const fn catastrophicerror(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Catastrophic error during CTR_DRBG health test (only when g_hw_health_test = true)."]
            #[inline(always)]
            pub fn set_catastrophicerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Symmetric Keys are stored."]
            #[inline(always)]
            pub const fn symkeystored(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Symmetric Keys are stored."]
            #[inline(always)]
            pub fn set_symkeystored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Private Keys are stored."]
            #[inline(always)]
            pub const fn privkeystored(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Private Keys are stored."]
            #[inline(always)]
            pub fn set_privkeystored(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for IkgStatus {
            #[inline(always)]
            fn default() -> IkgStatus {
                IkgStatus(0)
            }
        }
        impl core::fmt::Debug for IkgStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IkgStatus")
                    .field("seederror", &self.seederror())
                    .field("entropyerror", &self.entropyerror())
                    .field("okay", &self.okay())
                    .field("ctrdrbgbusy", &self.ctrdrbgbusy())
                    .field("catastrophicerror", &self.catastrophicerror())
                    .field("symkeystored", &self.symkeystored())
                    .field("privkeystored", &self.privkeystored())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IkgStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct IkgStatus {
                    seederror: bool,
                    entropyerror: bool,
                    okay: bool,
                    ctrdrbgbusy: bool,
                    catastrophicerror: bool,
                    symkeystored: bool,
                    privkeystored: bool,
                }
                let proxy = IkgStatus {
                    seederror: self.seederror(),
                    entropyerror: self.entropyerror(),
                    okay: self.okay(),
                    ctrdrbgbusy: self.ctrdrbgbusy(),
                    catastrophicerror: self.catastrophicerror(),
                    symkeystored: self.symkeystored(),
                    privkeystored: self.privkeystored(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Incuded IPs Hardware configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inclipshwcfg(pub u32);
        impl Inclipshwcfg {
            #[doc = "Generic g_IncludeAES value."]
            #[inline(always)]
            pub const fn ba411aesincluded(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAES value."]
            #[inline(always)]
            pub fn set_ba411aesincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Generic g_IncludeAESGCM value."]
            #[inline(always)]
            pub const fn ba415hpaesgcmincluded(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAESGCM value."]
            #[inline(always)]
            pub fn set_ba415hpaesgcmincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Generic g_IncludeAESXTS value."]
            #[inline(always)]
            pub const fn ba416hpaesxtsincluded(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeAESXTS value."]
            #[inline(always)]
            pub fn set_ba416hpaesxtsincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Generic g_IncludeDES value."]
            #[inline(always)]
            pub const fn ba412desincluded(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeDES value."]
            #[inline(always)]
            pub fn set_ba412desincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Generic g_IncludeHASH value."]
            #[inline(always)]
            pub const fn ba413hashincluded(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeHASH value."]
            #[inline(always)]
            pub fn set_ba413hashincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Generic g_IncludeChachaPoly value."]
            #[inline(always)]
            pub const fn ba417chachapolyincluded(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeChachaPoly value."]
            #[inline(always)]
            pub fn set_ba417chachapolyincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Generic g_IncludeSHA3 value."]
            #[inline(always)]
            pub const fn ba418sha3included(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSHA3 value."]
            #[inline(always)]
            pub fn set_ba418sha3included(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Generic g_IncludeZUC value."]
            #[inline(always)]
            pub const fn ba421zucincluded(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeZUC value."]
            #[inline(always)]
            pub fn set_ba421zucincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Generic g_IncludeSM4 value."]
            #[inline(always)]
            pub const fn ba419sm4included(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSM4 value."]
            #[inline(always)]
            pub fn set_ba419sm4included(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Generic g_IncludePKE value."]
            #[inline(always)]
            pub const fn ba414eppkeincluded(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludePKE value."]
            #[inline(always)]
            pub fn set_ba414eppkeincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Generic g_IncludeNDRNG value."]
            #[inline(always)]
            pub const fn ba431ndrngincluded(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeNDRNG value."]
            #[inline(always)]
            pub fn set_ba431ndrngincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Generic g_IncludeHPChachaPoly value."]
            #[inline(always)]
            pub const fn ba420hpchachapolyincluded(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeHPChachaPoly value."]
            #[inline(always)]
            pub fn set_ba420hpchachapolyincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Generic g_IncludeSnow3G value."]
            #[inline(always)]
            pub const fn ba423snow3gincluded(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeSnow3G value."]
            #[inline(always)]
            pub fn set_ba423snow3gincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Generic g_IncludeKasumi value."]
            #[inline(always)]
            pub const fn ba422kasumiincluded(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_IncludeKasumi value."]
            #[inline(always)]
            pub fn set_ba422kasumiincluded(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Inclipshwcfg {
            #[inline(always)]
            fn default() -> Inclipshwcfg {
                Inclipshwcfg(0)
            }
        }
        impl core::fmt::Debug for Inclipshwcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inclipshwcfg")
                    .field("ba411aesincluded", &self.ba411aesincluded())
                    .field("ba415hpaesgcmincluded", &self.ba415hpaesgcmincluded())
                    .field("ba416hpaesxtsincluded", &self.ba416hpaesxtsincluded())
                    .field("ba412desincluded", &self.ba412desincluded())
                    .field("ba413hashincluded", &self.ba413hashincluded())
                    .field("ba417chachapolyincluded", &self.ba417chachapolyincluded())
                    .field("ba418sha3included", &self.ba418sha3included())
                    .field("ba421zucincluded", &self.ba421zucincluded())
                    .field("ba419sm4included", &self.ba419sm4included())
                    .field("ba414eppkeincluded", &self.ba414eppkeincluded())
                    .field("ba431ndrngincluded", &self.ba431ndrngincluded())
                    .field(
                        "ba420hpchachapolyincluded",
                        &self.ba420hpchachapolyincluded(),
                    )
                    .field("ba423snow3gincluded", &self.ba423snow3gincluded())
                    .field("ba422kasumiincluded", &self.ba422kasumiincluded())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inclipshwcfg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Inclipshwcfg {
                    ba411aesincluded: bool,
                    ba415hpaesgcmincluded: bool,
                    ba416hpaesxtsincluded: bool,
                    ba412desincluded: bool,
                    ba413hashincluded: bool,
                    ba417chachapolyincluded: bool,
                    ba418sha3included: bool,
                    ba421zucincluded: bool,
                    ba419sm4included: bool,
                    ba414eppkeincluded: bool,
                    ba431ndrngincluded: bool,
                    ba420hpchachapolyincluded: bool,
                    ba423snow3gincluded: bool,
                    ba422kasumiincluded: bool,
                }
                let proxy = Inclipshwcfg {
                    ba411aesincluded: self.ba411aesincluded(),
                    ba415hpaesgcmincluded: self.ba415hpaesgcmincluded(),
                    ba416hpaesxtsincluded: self.ba416hpaesxtsincluded(),
                    ba412desincluded: self.ba412desincluded(),
                    ba413hashincluded: self.ba413hashincluded(),
                    ba417chachapolyincluded: self.ba417chachapolyincluded(),
                    ba418sha3included: self.ba418sha3included(),
                    ba421zucincluded: self.ba421zucincluded(),
                    ba419sm4included: self.ba419sm4included(),
                    ba414eppkeincluded: self.ba414eppkeincluded(),
                    ba431ndrngincluded: self.ba431ndrngincluded(),
                    ba420hpchachapolyincluded: self.ba420hpchachapolyincluded(),
                    ba423snow3gincluded: self.ba423snow3gincluded(),
                    ba422kasumiincluded: self.ba422kasumiincluded(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "InitData register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Initdata(pub u32);
        impl Initdata {
            #[doc = "Writing a 1 initialise Nonce and Personalisation_String registers counters, i.e. start writing from the 32 LSB."]
            #[inline(always)]
            pub const fn initdata(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 initialise Nonce and Personalisation_String registers counters, i.e. start writing from the 32 LSB."]
            #[inline(always)]
            pub fn set_initdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Initdata {
            #[inline(always)]
            fn default() -> Initdata {
                Initdata(0)
            }
        }
        impl core::fmt::Debug for Initdata {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Initdata")
                    .field("initdata", &self.initdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Initdata {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Initdata {
                    initdata: bool,
                }
                let proxy = Initdata {
                    initdata: self.initdata(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Initial wait counter value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Initwaitval(pub u32);
        impl Initwaitval {
            #[doc = "Number of clock cycles to wait before sampling data from the noise source."]
            #[inline(always)]
            pub const fn initwaitval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of clock cycles to wait before sampling data from the noise source."]
            #[inline(always)]
            pub fn set_initwaitval(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Initwaitval {
            #[inline(always)]
            fn default() -> Initwaitval {
                Initwaitval(0)
            }
        }
        impl core::fmt::Debug for Initwaitval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Initwaitval")
                    .field("initwaitval", &self.initwaitval())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Initwaitval {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Initwaitval {
                    initwaitval: u16,
                }
                let proxy = Initwaitval {
                    initwaitval: self.initwaitval(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Interrupt Enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[inline(always)]
            pub const fn int(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[inline(always)]
            pub fn set_int(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int").field("int", &self.int()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    int: u8,
                }
                let proxy = Int { int: self.int() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Operand size register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Opsize(pub u32);
        impl Opsize {
            #[doc = "Operand size (number of bytes): This register is used when the memory is accessed via AHB Master"]
            #[inline(always)]
            pub const fn opsize(&self) -> super::vals::Opsize {
                let val = (self.0 >> 0usize) & 0x1fff;
                super::vals::Opsize::from_bits(val as u16)
            }
            #[doc = "Operand size (number of bytes): This register is used when the memory is accessed via AHB Master"]
            #[inline(always)]
            pub fn set_opsize(&mut self, val: super::vals::Opsize) {
                self.0 =
                    (self.0 & !(0x1fff << 0usize)) | (((val.to_bits() as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for Opsize {
            #[inline(always)]
            fn default() -> Opsize {
                Opsize(0)
            }
        }
        impl core::fmt::Debug for Opsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Opsize")
                    .field("opsize", &self.opsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opsize {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Opsize {
                    opsize: super::vals::Opsize,
                }
                let proxy = Opsize {
                    opsize: self.opsize(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkControl(pub u32);
        impl PkControl {
            #[doc = "Writing a 1 starts the processing."]
            #[inline(always)]
            pub const fn start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 starts the processing."]
            #[inline(always)]
            pub fn set_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Writing a 1 clears the IRQ output."]
            #[inline(always)]
            pub const fn clearirq(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Writing a 1 clears the IRQ output."]
            #[inline(always)]
            pub fn set_clearirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for PkControl {
            #[inline(always)]
            fn default() -> PkControl {
                PkControl(0)
            }
        }
        impl core::fmt::Debug for PkControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkControl")
                    .field("start", &self.start())
                    .field("clearirq", &self.clearirq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkControl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PkControl {
                    start: bool,
                    clearirq: bool,
                }
                let proxy = PkControl {
                    start: self.start(),
                    clearirq: self.clearirq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Hardware configuration register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkHwconfig(pub u32);
        impl PkHwconfig {
            #[doc = "Maximum operand size (number of bytes)."]
            #[inline(always)]
            pub const fn maxopsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Maximum operand size (number of bytes)."]
            #[inline(always)]
            pub fn set_maxopsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Number of multipliers:"]
            #[inline(always)]
            pub const fn nbmult(&self) -> super::vals::Nbmult {
                let val = (self.0 >> 12usize) & 0x0f;
                super::vals::Nbmult::from_bits(val as u8)
            }
            #[doc = "Number of multipliers:"]
            #[inline(always)]
            pub fn set_nbmult(&mut self, val: super::vals::Nbmult) {
                self.0 =
                    (self.0 & !(0x0f << 12usize)) | (((val.to_bits() as u32) & 0x0f) << 12usize);
            }
            #[doc = "Support prime field."]
            #[inline(always)]
            pub const fn primefield(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Support prime field."]
            #[inline(always)]
            pub fn set_primefield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Support binary field."]
            #[inline(always)]
            pub const fn binaryfield(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Support binary field."]
            #[inline(always)]
            pub fn set_binaryfield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Support error correction."]
            #[inline(always)]
            pub const fn ecc(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Support error correction."]
            #[inline(always)]
            pub fn set_ecc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Support ECC P256 acceleration."]
            #[inline(always)]
            pub const fn p256(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P256 acceleration."]
            #[inline(always)]
            pub fn set_p256(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Support ECC P384 acceleration."]
            #[inline(always)]
            pub const fn p384(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P384 acceleration."]
            #[inline(always)]
            pub fn set_p384(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Support ECC P521 acceleration."]
            #[inline(always)]
            pub const fn p521(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P521 acceleration."]
            #[inline(always)]
            pub fn set_p521(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Support ECC P192 acceleration."]
            #[inline(always)]
            pub const fn p192(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Support ECC P192 acceleration."]
            #[inline(always)]
            pub fn set_p192(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Support Curve25519/Ed25519 acceleration."]
            #[inline(always)]
            pub const fn x25519(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Support Curve25519/Ed25519 acceleration."]
            #[inline(always)]
            pub fn set_x25519(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Memory access"]
            #[inline(always)]
            pub const fn ahbmaster(&self) -> super::vals::Ahbmaster {
                let val = (self.0 >> 25usize) & 0x01;
                super::vals::Ahbmaster::from_bits(val as u8)
            }
            #[doc = "Memory access"]
            #[inline(always)]
            pub fn set_ahbmaster(&mut self, val: super::vals::Ahbmaster) {
                self.0 =
                    (self.0 & !(0x01 << 25usize)) | (((val.to_bits() as u32) & 0x01) << 25usize);
            }
            #[doc = "State of DisableSMx input (high when SM2/SM9 operations are disabled)."]
            #[inline(always)]
            pub const fn disablesmx(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableSMx input (high when SM2/SM9 operations are disabled)."]
            #[inline(always)]
            pub fn set_disablesmx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "State of DisableClrMem input (high when automatic clear of the RAM after reset is disabled)."]
            #[inline(always)]
            pub const fn disableclrmem(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableClrMem input (high when automatic clear of the RAM after reset is disabled)."]
            #[inline(always)]
            pub fn set_disableclrmem(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "State of DisableCM input (high when counter-measures are disabled)."]
            #[inline(always)]
            pub const fn disablecm(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "State of DisableCM input (high when counter-measures are disabled)."]
            #[inline(always)]
            pub fn set_disablecm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for PkHwconfig {
            #[inline(always)]
            fn default() -> PkHwconfig {
                PkHwconfig(0)
            }
        }
        impl core::fmt::Debug for PkHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkHwconfig")
                    .field("maxopsize", &self.maxopsize())
                    .field("nbmult", &self.nbmult())
                    .field("primefield", &self.primefield())
                    .field("binaryfield", &self.binaryfield())
                    .field("ecc", &self.ecc())
                    .field("p256", &self.p256())
                    .field("p384", &self.p384())
                    .field("p521", &self.p521())
                    .field("p192", &self.p192())
                    .field("x25519", &self.x25519())
                    .field("ahbmaster", &self.ahbmaster())
                    .field("disablesmx", &self.disablesmx())
                    .field("disableclrmem", &self.disableclrmem())
                    .field("disablecm", &self.disablecm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkHwconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PkHwconfig {
                    maxopsize: u16,
                    nbmult: super::vals::Nbmult,
                    primefield: bool,
                    binaryfield: bool,
                    ecc: bool,
                    p256: bool,
                    p384: bool,
                    p521: bool,
                    p192: bool,
                    x25519: bool,
                    ahbmaster: super::vals::Ahbmaster,
                    disablesmx: bool,
                    disableclrmem: bool,
                    disablecm: bool,
                }
                let proxy = PkHwconfig {
                    maxopsize: self.maxopsize(),
                    nbmult: self.nbmult(),
                    primefield: self.primefield(),
                    binaryfield: self.binaryfield(),
                    ecc: self.ecc(),
                    p256: self.p256(),
                    p384: self.p384(),
                    p521: self.p521(),
                    p192: self.p192(),
                    x25519: self.x25519(),
                    ahbmaster: self.ahbmaster(),
                    disablesmx: self.disablesmx(),
                    disableclrmem: self.disableclrmem(),
                    disablecm: self.disablecm(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PkStatus(pub u32);
        impl PkStatus {
            #[doc = "These bits indicate an error condition."]
            #[inline(always)]
            pub const fn errorflags(&self) -> u16 {
                let val = (self.0 >> 4usize) & 0x0fff;
                val as u16
            }
            #[doc = "These bits indicate an error condition."]
            #[inline(always)]
            pub fn set_errorflags(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 4usize)) | (((val as u32) & 0x0fff) << 4usize);
            }
            #[doc = "This bit reflects the BUSY output value."]
            #[inline(always)]
            pub const fn pkbusy(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the BUSY output value."]
            #[inline(always)]
            pub fn set_pkbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "This bit reflects the IRQ output value."]
            #[inline(always)]
            pub const fn intrptstatus(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "This bit reflects the IRQ output value."]
            #[inline(always)]
            pub fn set_intrptstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "These bits indicate which data location generated the error flag."]
            #[inline(always)]
            pub const fn failptr(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "These bits indicate which data location generated the error flag."]
            #[inline(always)]
            pub fn set_failptr(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for PkStatus {
            #[inline(always)]
            fn default() -> PkStatus {
                PkStatus(0)
            }
        }
        impl core::fmt::Debug for PkStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PkStatus")
                    .field("errorflags", &self.errorflags())
                    .field("pkbusy", &self.pkbusy())
                    .field("intrptstatus", &self.intrptstatus())
                    .field("failptr", &self.failptr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PkStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PkStatus {
                    errorflags: u16,
                    pkbusy: bool,
                    intrptstatus: bool,
                    failptr: u8,
                }
                let proxy = PkStatus {
                    errorflags: self.errorflags(),
                    pkbusy: self.pkbusy(),
                    intrptstatus: self.intrptstatus(),
                    failptr: self.failptr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "PKE Command register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkecommand(pub u32);
        impl Pkecommand {
            #[doc = "Secure mode."]
            #[inline(always)]
            pub const fn securemode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Secure mode."]
            #[inline(always)]
            pub fn set_securemode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select Generated Private Key for PKE operation."]
            #[inline(always)]
            pub const fn selectedkey(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x0f;
                val as u8
            }
            #[doc = "Select Generated Private Key for PKE operation."]
            #[inline(always)]
            pub fn set_selectedkey(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val as u32) & 0x0f) << 4usize);
            }
            #[doc = "Select PKE operation with Isolated Key"]
            #[inline(always)]
            pub const fn opsel(&self) -> super::vals::Opsel {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Opsel::from_bits(val as u8)
            }
            #[doc = "Select PKE operation with Isolated Key"]
            #[inline(always)]
            pub fn set_opsel(&mut self, val: super::vals::Opsel) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Pkecommand {
            #[inline(always)]
            fn default() -> Pkecommand {
                Pkecommand(0)
            }
        }
        impl core::fmt::Debug for Pkecommand {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkecommand")
                    .field("securemode", &self.securemode())
                    .field("selectedkey", &self.selectedkey())
                    .field("opsel", &self.opsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkecommand {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pkecommand {
                    securemode: bool,
                    selectedkey: u8,
                    opsel: super::vals::Opsel,
                }
                let proxy = Pkecommand {
                    securemode: self.securemode(),
                    selectedkey: self.selectedkey(),
                    opsel: self.opsel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "PKE Control register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkecontrol(pub u32);
        impl Pkecontrol {
            #[doc = "Start the PKE operation or trigger for Secure mode exit."]
            #[inline(always)]
            pub const fn pkestart(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Start the PKE operation or trigger for Secure mode exit."]
            #[inline(always)]
            pub fn set_pkestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Clear the IRQ output."]
            #[inline(always)]
            pub const fn clearirq(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Clear the IRQ output."]
            #[inline(always)]
            pub fn set_clearirq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Pkecontrol {
            #[inline(always)]
            fn default() -> Pkecontrol {
                Pkecontrol(0)
            }
        }
        impl core::fmt::Debug for Pkecontrol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkecontrol")
                    .field("pkestart", &self.pkestart())
                    .field("clearirq", &self.clearirq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkecontrol {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pkecontrol {
                    pkestart: bool,
                    clearirq: bool,
                }
                let proxy = Pkecontrol {
                    pkestart: self.pkestart(),
                    clearirq: self.clearirq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "PKE Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pkestatus(pub u32);
        impl Pkestatus {
            #[doc = "Error because either Private Keys are not stored or the operation is not defined."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error because either Private Keys are not stored or the operation is not defined."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Error because a new operation is started while the previous one is still busy."]
            #[inline(always)]
            pub const fn starterror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Error because a new operation is started while the previous one is still busy."]
            #[inline(always)]
            pub fn set_starterror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Busy, set when the operation starts and cleared when the operation is finished."]
            #[inline(always)]
            pub const fn ikgpkbusy(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Busy, set when the operation starts and cleared when the operation is finished."]
            #[inline(always)]
            pub fn set_ikgpkbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "IRQ, set when the operation is finished and cleared when the CPU writes the bit 1 of PKE_Control Register or a new operation is started."]
            #[inline(always)]
            pub const fn irqstatus(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "IRQ, set when the operation is finished and cleared when the CPU writes the bit 1 of PKE_Control Register or a new operation is started."]
            #[inline(always)]
            pub fn set_irqstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "The PKE Data RAM is being erased."]
            #[inline(always)]
            pub const fn erasebusy(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "The PKE Data RAM is being erased."]
            #[inline(always)]
            pub fn set_erasebusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
        }
        impl Default for Pkestatus {
            #[inline(always)]
            fn default() -> Pkestatus {
                Pkestatus(0)
            }
        }
        impl core::fmt::Debug for Pkestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pkestatus")
                    .field("error", &self.error())
                    .field("starterror", &self.starterror())
                    .field("ikgpkbusy", &self.ikgpkbusy())
                    .field("irqstatus", &self.irqstatus())
                    .field("erasebusy", &self.erasebusy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pkestatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pkestatus {
                    error: bool,
                    starterror: bool,
                    ikgpkbusy: bool,
                    irqstatus: bool,
                    erasebusy: bool,
                }
                let proxy = Pkestatus {
                    error: self.error(),
                    starterror: self.starterror(),
                    ikgpkbusy: self.ikgpkbusy(),
                    irqstatus: self.irqstatus(),
                    erasebusy: self.erasebusy(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Pointers register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pointers(pub u32);
        impl Pointers {
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand A is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn opptra(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand A is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub fn set_opptra(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand B is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn opptrb(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines where operand B is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub fn set_opptrb(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location (0x0 to 0xF) where the result will be stored in memory."]
            #[inline(always)]
            pub const fn opptrc(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location (0x0 to 0xF) where the result will be stored in memory."]
            #[inline(always)]
            pub fn set_opptrc(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub const fn opptrn(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "When executing primitive arithmetic operations, this pointer defines the location where the modulus is located in memory (location 0x0 to 0xF)."]
            #[inline(always)]
            pub fn set_opptrn(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Pointers {
            #[inline(always)]
            fn default() -> Pointers {
                Pointers(0)
            }
        }
        impl core::fmt::Debug for Pointers {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pointers")
                    .field("opptra", &self.opptra())
                    .field("opptrb", &self.opptrb())
                    .field("opptrc", &self.opptrc())
                    .field("opptrn", &self.opptrn())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pointers {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pointers {
                    opptra: u8,
                    opptrb: u8,
                    opptrc: u8,
                    opptrn: u8,
                }
                let proxy = Pointers {
                    opptra: self.opptra(),
                    opptrb: self.opptrb(),
                    opptrc: self.opptrc(),
                    opptrn: self.opptrn(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Propthreshold(pub u32);
        impl Propthreshold {
            #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
            #[inline(always)]
            pub const fn propthreshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Adaptive Proportion Test (1024-sample window) Cut-Off value."]
            #[inline(always)]
            pub fn set_propthreshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Propthreshold {
            #[inline(always)]
            fn default() -> Propthreshold {
                Propthreshold(0)
            }
        }
        impl core::fmt::Debug for Propthreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Propthreshold")
                    .field("propthreshold", &self.propthreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Propthreshold {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Propthreshold {
                    propthreshold: u16,
                }
                let proxy = Propthreshold {
                    propthreshold: self.propthreshold(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Push Length"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pushlen(pub u32);
        impl Pushlen {
            #[inline(always)]
            pub const fn pushlen(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x0fff_ffff;
                val as u32
            }
            #[inline(always)]
            pub fn set_pushlen(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x0fff_ffff << 0usize)) | (((val as u32) & 0x0fff_ffff) << 0usize);
            }
            #[inline(always)]
            pub const fn pushcstaddr(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushcstaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[inline(always)]
            pub const fn pushrealign(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushrealign(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[inline(always)]
            pub const fn pushdiscard(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_pushdiscard(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
        }
        impl Default for Pushlen {
            #[inline(always)]
            fn default() -> Pushlen {
                Pushlen(0)
            }
        }
        impl core::fmt::Debug for Pushlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pushlen")
                    .field("pushlen", &self.pushlen())
                    .field("pushcstaddr", &self.pushcstaddr())
                    .field("pushrealign", &self.pushrealign())
                    .field("pushdiscard", &self.pushdiscard())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pushlen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pushlen {
                    pushlen: u32,
                    pushcstaddr: bool,
                    pushrealign: bool,
                    pushdiscard: bool,
                }
                let proxy = Pushlen {
                    pushlen: self.pushlen(),
                    pushcstaddr: self.pushcstaddr(),
                    pushrealign: self.pushrealign(),
                    pushdiscard: self.pushdiscard(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RAM error injection register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ramerrorinject(pub u32);
        impl Ramerrorinject {
            #[doc = "Bit position of first error"]
            #[inline(always)]
            pub const fn biterror1(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Bit position of first error"]
            #[inline(always)]
            pub fn set_biterror1(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
            #[doc = "Bit position of second error"]
            #[inline(always)]
            pub const fn biterror2(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Bit position of second error"]
            #[inline(always)]
            pub fn set_biterror2(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Ramerrorinject {
            #[inline(always)]
            fn default() -> Ramerrorinject {
                Ramerrorinject(0)
            }
        }
        impl core::fmt::Debug for Ramerrorinject {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ramerrorinject")
                    .field("biterror1", &self.biterror1())
                    .field("biterror2", &self.biterror2())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ramerrorinject {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ramerrorinject {
                    biterror1: u16,
                    biterror2: u16,
                }
                let proxy = Ramerrorinject {
                    biterror1: self.biterror1(),
                    biterror2: self.biterror2(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RAM error status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ramerrorstatus(pub u32);
        impl Ramerrorstatus {
            #[doc = "This bit indicates that a 1-bit error has been detected and corrected on RAM interface"]
            #[inline(always)]
            pub const fn ramcorrection(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that a 1-bit error has been detected and corrected on RAM interface"]
            #[inline(always)]
            pub fn set_ramcorrection(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "This bit indicates that an uncorrectable error has been detected on the data RAM interface"]
            #[inline(always)]
            pub const fn ramfailure(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "This bit indicates that an uncorrectable error has been detected on the data RAM interface"]
            #[inline(always)]
            pub fn set_ramfailure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ramerrorstatus {
            #[inline(always)]
            fn default() -> Ramerrorstatus {
                Ramerrorstatus(0)
            }
        }
        impl core::fmt::Debug for Ramerrorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ramerrorstatus")
                    .field("ramcorrection", &self.ramcorrection())
                    .field("ramfailure", &self.ramfailure())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ramerrorstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ramerrorstatus {
                    ramcorrection: bool,
                    ramfailure: bool,
                }
                let proxy = Ramerrorstatus {
                    ramcorrection: self.ramcorrection(),
                    ramfailure: self.ramfailure(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Repetition Test Count Cut-Off value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Repeatthreshold(pub u32);
        impl Repeatthreshold {
            #[doc = "Repetition Test Count Cut-Off value."]
            #[inline(always)]
            pub const fn repeatthreshold(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Repetition Test Count Cut-Off value."]
            #[inline(always)]
            pub fn set_repeatthreshold(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for Repeatthreshold {
            #[inline(always)]
            fn default() -> Repeatthreshold {
                Repeatthreshold(0)
            }
        }
        impl core::fmt::Debug for Repeatthreshold {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Repeatthreshold")
                    .field("repeatthreshold", &self.repeatthreshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Repeatthreshold {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Repeatthreshold {
                    repeatthreshold: u8,
                }
                let proxy = Repeatthreshold {
                    repeatthreshold: self.repeatthreshold(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Reseed Interval MSB register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reseedintervalmsb(pub u32);
        impl Reseedintervalmsb {
            #[doc = "Reseed Interval MSB."]
            #[inline(always)]
            pub const fn reseedintervalmsb(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Reseed Interval MSB."]
            #[inline(always)]
            pub fn set_reseedintervalmsb(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Reseedintervalmsb {
            #[inline(always)]
            fn default() -> Reseedintervalmsb {
                Reseedintervalmsb(0)
            }
        }
        impl core::fmt::Debug for Reseedintervalmsb {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reseedintervalmsb")
                    .field("reseedintervalmsb", &self.reseedintervalmsb())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reseedintervalmsb {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Reseedintervalmsb {
                    reseedintervalmsb: u16,
                }
                let proxy = Reseedintervalmsb {
                    reseedintervalmsb: self.reseedintervalmsb(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolControl(pub u32);
        impl RngcontrolControl {
            #[doc = "Enable the NDRNG."]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the NDRNG."]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Select between the NDRNG with asynchronous free running oscillators (when 0) and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when 1)."]
            #[inline(always)]
            pub const fn lfsren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Select between the NDRNG with asynchronous free running oscillators (when 0) and the Pseudo-Random generator with synchronous oscillators for simulation purpose (when 1)."]
            #[inline(always)]
            pub fn set_lfsren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Select input for conditioning function and continuous tests:"]
            #[inline(always)]
            pub const fn testen(&self) -> super::vals::Testen {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Testen::from_bits(val as u8)
            }
            #[doc = "Select input for conditioning function and continuous tests:"]
            #[inline(always)]
            pub fn set_testen(&mut self, val: super::vals::Testen) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Conditioning function bypass."]
            #[inline(always)]
            pub const fn condbypass(&self) -> super::vals::Condbypass {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Condbypass::from_bits(val as u8)
            }
            #[doc = "Conditioning function bypass."]
            #[inline(always)]
            pub fn set_condbypass(&mut self, val: super::vals::Condbypass) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Interrupt enable for Repetition Count Test failure."]
            #[inline(always)]
            pub const fn intenrep(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for Repetition Count Test failure."]
            #[inline(always)]
            pub fn set_intenrep(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Interrupt enable for Adaptive Proportion Test failure (1024-sample window)."]
            #[inline(always)]
            pub const fn intenprop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for Adaptive Proportion Test failure (1024-sample window)."]
            #[inline(always)]
            pub fn set_intenprop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Interrupt enable for FIFO full."]
            #[inline(always)]
            pub const fn intenfull(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for FIFO full."]
            #[inline(always)]
            pub fn set_intenfull(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Software reset:"]
            #[inline(always)]
            pub const fn softrst(&self) -> super::vals::ControlSoftrst {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::ControlSoftrst::from_bits(val as u8)
            }
            #[doc = "Software reset:"]
            #[inline(always)]
            pub fn set_softrst(&mut self, val: super::vals::ControlSoftrst) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Interrupt enable for AIS31 preliminary noise alarm."]
            #[inline(always)]
            pub const fn intenpre(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for AIS31 preliminary noise alarm."]
            #[inline(always)]
            pub fn set_intenpre(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Interrupt enable for AIS31 noise alarm."]
            #[inline(always)]
            pub const fn intenalm(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Interrupt enable for AIS31 noise alarm."]
            #[inline(always)]
            pub fn set_intenalm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Force oscillators to run when FIFO is full."]
            #[inline(always)]
            pub const fn forceactiveros(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Force oscillators to run when FIFO is full."]
            #[inline(always)]
            pub fn set_forceactiveros(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Bypass NIST tests such that the results of the start-up and online test do not affect the FSM state."]
            #[inline(always)]
            pub const fn healthtestbypass(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass NIST tests such that the results of the start-up and online test do not affect the FSM state."]
            #[inline(always)]
            pub fn set_healthtestbypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Bypass AIS31 tests such that the results of the start-up and online tests do not affect the FSM state."]
            #[inline(always)]
            pub const fn ais31bypass(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Bypass AIS31 tests such that the results of the start-up and online tests do not affect the FSM state."]
            #[inline(always)]
            pub fn set_ais31bypass(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Select input to health test module:"]
            #[inline(always)]
            pub const fn healthtestsel(&self) -> super::vals::Healthtestsel {
                let val = (self.0 >> 14usize) & 0x01;
                super::vals::Healthtestsel::from_bits(val as u8)
            }
            #[doc = "Select input to health test module:"]
            #[inline(always)]
            pub fn set_healthtestsel(&mut self, val: super::vals::Healthtestsel) {
                self.0 =
                    (self.0 & !(0x01 << 14usize)) | (((val.to_bits() as u32) & 0x01) << 14usize);
            }
            #[doc = "Select input to the AIS31 test module:"]
            #[inline(always)]
            pub const fn ais31testsel(&self) -> super::vals::Ais31testsel {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Ais31testsel::from_bits(val as u8)
            }
            #[doc = "Select input to the AIS31 test module:"]
            #[inline(always)]
            pub fn set_ais31testsel(&mut self, val: super::vals::Ais31testsel) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Number of 128 bit blocks used in AES-CBCMAC post-processing."]
            #[inline(always)]
            pub const fn nb128bitblocks(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of 128 bit blocks used in AES-CBCMAC post-processing."]
            #[inline(always)]
            pub fn set_nb128bitblocks(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Enable write of the samples in the FIFO during start-up."]
            #[inline(always)]
            pub const fn fifowritestartup(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable write of the samples in the FIFO during start-up."]
            #[inline(always)]
            pub fn set_fifowritestartup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for RngcontrolControl {
            #[inline(always)]
            fn default() -> RngcontrolControl {
                RngcontrolControl(0)
            }
        }
        impl core::fmt::Debug for RngcontrolControl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolControl")
                    .field("enable", &self.enable())
                    .field("lfsren", &self.lfsren())
                    .field("testen", &self.testen())
                    .field("condbypass", &self.condbypass())
                    .field("intenrep", &self.intenrep())
                    .field("intenprop", &self.intenprop())
                    .field("intenfull", &self.intenfull())
                    .field("softrst", &self.softrst())
                    .field("intenpre", &self.intenpre())
                    .field("intenalm", &self.intenalm())
                    .field("forceactiveros", &self.forceactiveros())
                    .field("healthtestbypass", &self.healthtestbypass())
                    .field("ais31bypass", &self.ais31bypass())
                    .field("healthtestsel", &self.healthtestsel())
                    .field("ais31testsel", &self.ais31testsel())
                    .field("nb128bitblocks", &self.nb128bitblocks())
                    .field("fifowritestartup", &self.fifowritestartup())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolControl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RngcontrolControl {
                    enable: bool,
                    lfsren: bool,
                    testen: super::vals::Testen,
                    condbypass: super::vals::Condbypass,
                    intenrep: bool,
                    intenprop: bool,
                    intenfull: bool,
                    softrst: super::vals::ControlSoftrst,
                    intenpre: bool,
                    intenalm: bool,
                    forceactiveros: bool,
                    healthtestbypass: bool,
                    ais31bypass: bool,
                    healthtestsel: super::vals::Healthtestsel,
                    ais31testsel: super::vals::Ais31testsel,
                    nb128bitblocks: u8,
                    fifowritestartup: bool,
                }
                let proxy = RngcontrolControl {
                    enable: self.enable(),
                    lfsren: self.lfsren(),
                    testen: self.testen(),
                    condbypass: self.condbypass(),
                    intenrep: self.intenrep(),
                    intenprop: self.intenprop(),
                    intenfull: self.intenfull(),
                    softrst: self.softrst(),
                    intenpre: self.intenpre(),
                    intenalm: self.intenalm(),
                    forceactiveros: self.forceactiveros(),
                    healthtestbypass: self.healthtestbypass(),
                    ais31bypass: self.ais31bypass(),
                    healthtestsel: self.healthtestsel(),
                    ais31testsel: self.ais31testsel(),
                    nb128bitblocks: self.nb128bitblocks(),
                    fifowritestartup: self.fifowritestartup(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Hardware configuration register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolHwconfig(pub u32);
        impl RngcontrolHwconfig {
            #[doc = "Generic g_NumRings value."]
            #[inline(always)]
            pub const fn numbofrings(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Generic g_NumRings value."]
            #[inline(always)]
            pub fn set_numbofrings(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Generic g_AIS31 value."]
            #[inline(always)]
            pub const fn ais31(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_AIS31 value."]
            #[inline(always)]
            pub fn set_ais31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Generic g_AIS31Full value."]
            #[inline(always)]
            pub const fn ais31full(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Generic g_AIS31Full value."]
            #[inline(always)]
            pub fn set_ais31full(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
        }
        impl Default for RngcontrolHwconfig {
            #[inline(always)]
            fn default() -> RngcontrolHwconfig {
                RngcontrolHwconfig(0)
            }
        }
        impl core::fmt::Debug for RngcontrolHwconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolHwconfig")
                    .field("numbofrings", &self.numbofrings())
                    .field("ais31", &self.ais31())
                    .field("ais31full", &self.ais31full())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolHwconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RngcontrolHwconfig {
                    numbofrings: u8,
                    ais31: bool,
                    ais31full: bool,
                }
                let proxy = RngcontrolHwconfig {
                    numbofrings: self.numbofrings(),
                    ais31: self.ais31(),
                    ais31full: self.ais31full(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RngcontrolStatus(pub u32);
        impl RngcontrolStatus {
            #[doc = "High when data written to TestData register is being processed."]
            #[inline(always)]
            pub const fn testdatabusy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "High when data written to TestData register is being processed."]
            #[inline(always)]
            pub fn set_testdatabusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "State of the control FSM:"]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "State of the control FSM:"]
            #[inline(always)]
            pub fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "NIST-800-90B repetition Count Test interrupt status."]
            #[inline(always)]
            pub const fn repfail(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "NIST-800-90B repetition Count Test interrupt status."]
            #[inline(always)]
            pub fn set_repfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "NIST-800-90B adaptive Proportion Test (1024-sample window) interrupt status."]
            #[inline(always)]
            pub const fn propfail(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "NIST-800-90B adaptive Proportion Test (1024-sample window) interrupt status."]
            #[inline(always)]
            pub fn set_propfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "FIFO full status."]
            #[inline(always)]
            pub const fn fullint(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "FIFO full status."]
            #[inline(always)]
            pub fn set_fullint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "AIS31 preliminary noise alarm interrupt status."]
            #[inline(always)]
            pub const fn preint(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "AIS31 preliminary noise alarm interrupt status."]
            #[inline(always)]
            pub fn set_preint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "AIS31 noise alarm interrupt status."]
            #[inline(always)]
            pub const fn almint(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "AIS31 noise alarm interrupt status."]
            #[inline(always)]
            pub fn set_almint(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Start-up test failure."]
            #[inline(always)]
            pub const fn startupfail(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Start-up test failure."]
            #[inline(always)]
            pub fn set_startupfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Set when a FIFO data read is performed while the NDRNG is disabled AND has its FIFO empty (FIFOLevel = 0)."]
            #[inline(always)]
            pub const fn fifoaccfail(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Set when a FIFO data read is performed while the NDRNG is disabled AND has its FIFO empty (FIFOLevel = 0)."]
            #[inline(always)]
            pub fn set_fifoaccfail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for RngcontrolStatus {
            #[inline(always)]
            fn default() -> RngcontrolStatus {
                RngcontrolStatus(0)
            }
        }
        impl core::fmt::Debug for RngcontrolStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RngcontrolStatus")
                    .field("testdatabusy", &self.testdatabusy())
                    .field("state", &self.state())
                    .field("repfail", &self.repfail())
                    .field("propfail", &self.propfail())
                    .field("fullint", &self.fullint())
                    .field("preint", &self.preint())
                    .field("almint", &self.almint())
                    .field("startupfail", &self.startupfail())
                    .field("fifoaccfail", &self.fifoaccfail())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RngcontrolStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RngcontrolStatus {
                    testdatabusy: bool,
                    state: super::vals::State,
                    repfail: bool,
                    propfail: bool,
                    fullint: bool,
                    preint: bool,
                    almint: bool,
                    startupfail: bool,
                    fifoaccfail: bool,
                }
                let proxy = RngcontrolStatus {
                    testdatabusy: self.testdatabusy(),
                    state: self.state(),
                    repfail: self.repfail(),
                    propfail: self.propfail(),
                    fullint: self.fullint(),
                    preint: self.preint(),
                    almint: self.almint(),
                    startupfail: self.startupfail(),
                    fifoaccfail: self.fifoaccfail(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "SoftRst register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Softrst(pub u32);
        impl Softrst {
            #[doc = "Software reset:"]
            #[inline(always)]
            pub const fn softrst(&self) -> super::vals::SoftrstSoftrst {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SoftrstSoftrst::from_bits(val as u8)
            }
            #[doc = "Software reset:"]
            #[inline(always)]
            pub fn set_softrst(&mut self, val: super::vals::SoftrstSoftrst) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Softrst {
            #[inline(always)]
            fn default() -> Softrst {
                Softrst(0)
            }
        }
        impl core::fmt::Debug for Softrst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Softrst")
                    .field("softrst", &self.softrst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Softrst {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Softrst {
                    softrst: super::vals::SoftrstSoftrst,
                }
                let proxy = Softrst {
                    softrst: self.softrst(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Switch off timer value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Swofftmrval(pub u32);
        impl Swofftmrval {
            #[doc = "Number of clk cycles to wait before stopping the rings after the FIFO is full."]
            #[inline(always)]
            pub const fn swofftmrval(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of clk cycles to wait before stopping the rings after the FIFO is full."]
            #[inline(always)]
            pub fn set_swofftmrval(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Swofftmrval {
            #[inline(always)]
            fn default() -> Swofftmrval {
                Swofftmrval(0)
            }
        }
        impl core::fmt::Debug for Swofftmrval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Swofftmrval")
                    .field("swofftmrval", &self.swofftmrval())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Swofftmrval {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Swofftmrval {
                    swofftmrval: u16,
                }
                let proxy = Swofftmrval {
                    swofftmrval: self.swofftmrval(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ahbmaster {
            #[doc = "Memory access through AHB Slave and internally in the PKE."]
            SLAVE = 0x0,
            #[doc = "Memory access through AHB Master, outside the PKE."]
            MASTER = 0x01,
        }
        impl Ahbmaster {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ahbmaster {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ahbmaster {
            #[inline(always)]
            fn from(val: u8) -> Ahbmaster {
                Ahbmaster::from_bits(val)
            }
        }
        impl From<Ahbmaster> for u8 {
            #[inline(always)]
            fn from(val: Ahbmaster) -> u8 {
                Ahbmaster::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ais31testsel {
            #[doc = "Before conditioning."]
            BEFORE = 0x0,
            #[doc = "After conditioning."]
            AFTER = 0x01,
        }
        impl Ais31testsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ais31testsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ais31testsel {
            #[inline(always)]
            fn from(val: u8) -> Ais31testsel {
                Ais31testsel::from_bits(val)
            }
        }
        impl From<Ais31testsel> for u8 {
            #[inline(always)]
            fn from(val: Ais31testsel) -> u8 {
                Ais31testsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Calcr2 {
            #[doc = "don't recalculate R² mod N"]
            NRECALCULATE = 0x0,
            #[doc = "re-calculate R² mod N"]
            RECALCULATE = 0x01,
        }
        impl Calcr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Calcr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Calcr2 {
            #[inline(always)]
            fn from(val: u8) -> Calcr2 {
                Calcr2::from_bits(val)
            }
        }
        impl From<Calcr2> for u8 {
            #[inline(always)]
            fn from(val: Calcr2) -> u8 {
                Calcr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Condbypass {
            #[doc = "the conditioning function is used (normal mode)."]
            NORMAL = 0x0,
            #[doc = "the conditioning function is bypassed (to observe entropy source directly)."]
            BYPASS = 0x01,
        }
        impl Condbypass {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Condbypass {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Condbypass {
            #[inline(always)]
            fn from(val: u8) -> Condbypass {
                Condbypass::from_bits(val)
            }
        }
        impl From<Condbypass> for u8 {
            #[inline(always)]
            fn from(val: Condbypass) -> u8 {
                Condbypass::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ControlSoftrst {
            #[doc = "Normal mode."]
            NORMAL = 0x0,
            #[doc = "The continuous test, the conditioning function and the FIFO are reset."]
            CTEST = 0x01,
        }
        impl ControlSoftrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ControlSoftrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ControlSoftrst {
            #[inline(always)]
            fn from(val: u8) -> ControlSoftrst {
                ControlSoftrst::from_bits(val)
            }
        }
        impl From<ControlSoftrst> for u8 {
            #[inline(always)]
            fn from(val: ControlSoftrst) -> u8 {
                ControlSoftrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Curve {
            #[doc = "P256."]
            P256 = 0x0,
            #[doc = "P384."]
            P384 = 0x01,
            #[doc = "P521."]
            P521 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Curve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Curve {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Curve {
            #[inline(always)]
            fn from(val: u8) -> Curve {
                Curve::from_bits(val)
            }
        }
        impl From<Curve> for u8 {
            #[inline(always)]
            fn from(val: Curve) -> u8 {
                Curve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Healthtestsel {
            #[doc = "Before conditioning."]
            BEFORE = 0x0,
            #[doc = "After conditioning."]
            AFTER = 0x01,
        }
        impl Healthtestsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Healthtestsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Healthtestsel {
            #[inline(always)]
            fn from(val: u8) -> Healthtestsel {
                Healthtestsel::from_bits(val)
            }
        }
        impl From<Healthtestsel> for u8 {
            #[inline(always)]
            fn from(val: Healthtestsel) -> u8 {
                Healthtestsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Keysize {
            _RESERVED_0 = 0x0,
            #[doc = "supports AES128"]
            AES128 = 0x01,
            #[doc = "supports AES192"]
            AES192 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "supports AES256"]
            AES256 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Keysize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Keysize {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Keysize {
            #[inline(always)]
            fn from(val: u8) -> Keysize {
                Keysize::from_bits(val)
            }
        }
        impl From<Keysize> for u8 {
            #[inline(always)]
            fn from(val: Keysize) -> u8 {
                Keysize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nbmult {
            #[doc = "1 multiplier"]
            MULT1 = 0x0,
            #[doc = "4 multipliers"]
            MULT4 = 0x01,
            #[doc = "16 multipliers"]
            MULT16 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "64 multipliers"]
            MULT64 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "256 multipliers"]
            MULT256 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Nbmult {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nbmult {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nbmult {
            #[inline(always)]
            fn from(val: u8) -> Nbmult {
                Nbmult::from_bits(val)
            }
        }
        impl From<Nbmult> for u8 {
            #[inline(always)]
            fn from(val: Nbmult) -> u8 {
                Nbmult::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Opsel {
            #[doc = "Public Key Generation"]
            PUBKEY = 0x0,
            #[doc = "ECDSA Signature"]
            ECDSA = 0x01,
            #[doc = "Point Multiplication"]
            PTMUL = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Opsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Opsel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Opsel {
            #[inline(always)]
            fn from(val: u8) -> Opsel {
                Opsel::from_bits(val)
            }
        }
        impl From<Opsel> for u8 {
            #[inline(always)]
            fn from(val: Opsel) -> u8 {
                Opsel::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Opsize(pub u16);
        impl Opsize {
            #[doc = "256 bytes."]
            pub const OPSIZE256: Self = Self(0x0100);
            #[doc = "521 bytes."]
            pub const OPSIZE521: Self = Self(0x0209);
            #[doc = "2048 bytes."]
            pub const OPSIZE2048: Self = Self(0x0800);
            #[doc = "3072 bytes."]
            pub const OPSIZE3072: Self = Self(0x0c00);
            #[doc = "4096 bytes."]
            pub const OPSIZE4096: Self = Self(0x1000);
        }
        impl Opsize {
            pub const fn from_bits(val: u16) -> Opsize {
                Self(val & 0x1fff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Opsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("OPSIZE256"),
                    0x0209 => f.write_str("OPSIZE521"),
                    0x0800 => f.write_str("OPSIZE2048"),
                    0x0c00 => f.write_str("OPSIZE3072"),
                    0x1000 => f.write_str("OPSIZE4096"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Opsize {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "OPSIZE256"),
                    0x0209 => defmt::write!(f, "OPSIZE521"),
                    0x0800 => defmt::write!(f, "OPSIZE2048"),
                    0x0c00 => defmt::write!(f, "OPSIZE3072"),
                    0x1000 => defmt::write!(f, "OPSIZE4096"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Opsize {
            #[inline(always)]
            fn from(val: u16) -> Opsize {
                Opsize::from_bits(val)
            }
        }
        impl From<Opsize> for u16 {
            #[inline(always)]
            fn from(val: Opsize) -> u16 {
                Opsize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Selcurve {
            #[doc = "Unspecified"]
            NOACCEL = 0x0,
            #[doc = "Unspecified"]
            P256 = 0x01,
            #[doc = "Unspecified"]
            P384 = 0x02,
            #[doc = "Unspecified"]
            P521 = 0x03,
            #[doc = "Unspecified"]
            P192 = 0x04,
            #[doc = "Unspecified"]
            CURVE25519 = 0x05,
            #[doc = "Unspecified"]
            ED25519 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Selcurve {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Selcurve {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Selcurve {
            #[inline(always)]
            fn from(val: u8) -> Selcurve {
                Selcurve::from_bits(val)
            }
        }
        impl From<Selcurve> for u8 {
            #[inline(always)]
            fn from(val: Selcurve) -> u8 {
                Selcurve::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SoftrstSoftrst {
            #[doc = "Normal mode."]
            NORMAL = 0x0,
            #[doc = "The Isolated Key Generation logic and the keys are reset."]
            KEY = 0x01,
        }
        impl SoftrstSoftrst {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SoftrstSoftrst {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SoftrstSoftrst {
            #[inline(always)]
            fn from(val: u8) -> SoftrstSoftrst {
                SoftrstSoftrst::from_bits(val)
            }
        }
        impl From<SoftrstSoftrst> for u8 {
            #[inline(always)]
            fn from(val: SoftrstSoftrst) -> u8 {
                SoftrstSoftrst::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "Reset"]
            RESET = 0x0,
            #[doc = "Startup"]
            STARTUP = 0x01,
            #[doc = "Idle (Rings On)"]
            IDLERON = 0x02,
            #[doc = "Idle (Rings Off)"]
            IDLEROFF = 0x03,
            #[doc = "Fill FIFO"]
            FILLFIFO = 0x04,
            #[doc = "Error"]
            ERROR = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swapbytes {
            #[doc = "Native format (little endian)."]
            NATIVE = 0x0,
            #[doc = "Byte swapped (big endian)."]
            SWAPPED = 0x01,
        }
        impl Swapbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swapbytes {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swapbytes {
            #[inline(always)]
            fn from(val: u8) -> Swapbytes {
                Swapbytes::from_bits(val)
            }
        }
        impl From<Swapbytes> for u8 {
            #[inline(always)]
            fn from(val: Swapbytes) -> u8 {
                Swapbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Testen {
            #[doc = "Noise source (normal mode)."]
            NORMAL = 0x0,
            #[doc = "Test data register (test mode)."]
            TEST = 0x01,
        }
        impl Testen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Testen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Testen {
            #[inline(always)]
            fn from(val: u8) -> Testen {
                Testen::from_bits(val)
            }
        }
        impl From<Testen> for u8 {
            #[inline(always)]
            fn from(val: Testen) -> u8 {
                Testen::to_bits(val)
            }
        }
    }
}
pub mod ctrlapperi {
    #[doc = "Control access port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ctrlapperi {
        ptr: *mut u8,
    }
    unsafe impl Send for Ctrlapperi {}
    unsafe impl Sync for Ctrlapperi {}
    impl Ctrlapperi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RXSTATUS is changed to DataPending."]
        #[inline(always)]
        pub const fn events_rxready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "TXSTATUS is changed to NoDataPending."]
        #[inline(always)]
        pub const fn events_txdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn mailbox(self) -> Mailbox {
            unsafe { Mailbox::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "System reset request."]
        #[inline(always)]
        pub const fn reset(self) -> crate::common::Reg<regs::Reset, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "This register disables the ERASEPROTECT register and performs an ERASEALL operation."]
        #[inline(always)]
        pub const fn disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mailbox {
        ptr: *mut u8,
    }
    unsafe impl Send for Mailbox {}
    unsafe impl Sync for Mailbox {}
    impl Mailbox {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data sent from the debugger to the CPU."]
        #[inline(always)]
        pub const fn rxdata(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status to indicate if data sent from the debugger to the CPU has been read."]
        #[inline(always)]
        pub const fn rxstatus(self) -> crate::common::Reg<regs::Rxstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Data sent from the CPU to the debugger."]
        #[inline(always)]
        pub const fn txdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Status to indicate if data sent from the CPU to the debugger has been read."]
        #[inline(always)]
        pub const fn txstatus(self) -> crate::common::Reg<regs::Txstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXREADY"]
            #[inline(always)]
            pub const fn rxready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXREADY"]
            #[inline(always)]
            pub fn set_rxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event TXDONE"]
            #[inline(always)]
            pub const fn txdone(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDONE"]
            #[inline(always)]
            pub fn set_txdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxready", &self.rxready())
                    .field("txdone", &self.txdone())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    rxready: bool,
                    txdone: bool,
                }
                let proxy = Int {
                    rxready: self.rxready(),
                    txdone: self.txdone(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "This register locks the ERASEPROTECT.DISABLE register from being written until next reset."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Lock ERASEPROTECT.DISABLE register from being written until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Lock ERASEPROTECT.DISABLE register from being written until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lock {
                    lock: bool,
                }
                let proxy = Lock { lock: self.lock() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "System reset request."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reset(pub u32);
        impl Reset {
            #[doc = "Reset request"]
            #[inline(always)]
            pub const fn reset(&self) -> super::vals::Reset {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Reset::from_bits(val as u8)
            }
            #[doc = "Reset request"]
            #[inline(always)]
            pub fn set_reset(&mut self, val: super::vals::Reset) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Reset {
            #[inline(always)]
            fn default() -> Reset {
                Reset(0)
            }
        }
        impl core::fmt::Debug for Reset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reset")
                    .field("reset", &self.reset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reset {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Reset {
                    reset: super::vals::Reset,
                }
                let proxy = Reset {
                    reset: self.reset(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status to indicate if data sent from the debugger to the CPU has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxstatus(pub u32);
        impl Rxstatus {
            #[doc = "Status of data in register RXDATA."]
            #[inline(always)]
            pub const fn rxstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register RXDATA."]
            #[inline(always)]
            pub fn set_rxstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxstatus {
            #[inline(always)]
            fn default() -> Rxstatus {
                Rxstatus(0)
            }
        }
        impl core::fmt::Debug for Rxstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxstatus")
                    .field("rxstatus", &self.rxstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rxstatus {
                    rxstatus: bool,
                }
                let proxy = Rxstatus {
                    rxstatus: self.rxstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status to indicate if data sent from the CPU to the debugger has been read."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txstatus(pub u32);
        impl Txstatus {
            #[doc = "Status of data in register TXDATA."]
            #[inline(always)]
            pub const fn txstatus(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status of data in register TXDATA."]
            #[inline(always)]
            pub fn set_txstatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txstatus {
            #[inline(always)]
            fn default() -> Txstatus {
                Txstatus(0)
            }
        }
        impl core::fmt::Debug for Txstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txstatus")
                    .field("txstatus", &self.txstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Txstatus {
                    txstatus: bool,
                }
                let proxy = Txstatus {
                    txstatus: self.txstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reset {
            #[doc = "No reset is generated"]
            NO_RESET = 0x0,
            #[doc = "Perform a device soft reset"]
            SOFT_RESET = 0x01,
            #[doc = "Perform a device hard reset"]
            HARD_RESET = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "Perform a device pin reset"]
            PIN_RESET = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Reset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reset {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reset {
            #[inline(always)]
            fn from(val: u8) -> Reset {
                Reset::from_bits(val)
            }
        }
        impl From<Reset> for u8 {
            #[inline(always)]
            fn from(val: Reset) -> u8 {
                Reset::to_bits(val)
            }
        }
    }
}
pub mod dppic {
    #[doc = "Distributed programmable peripheral interconnect controller 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Channel group tasks"]
        #[inline(always)]
        pub const fn tasks_chg(self, n: usize) -> TasksChg {
            assert!(n < 6usize);
            unsafe { TasksChg::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_chg(self, n: usize) -> SubscribeChg {
            assert!(n < 6usize);
            unsafe { SubscribeChg::from_ptr(self.ptr.add(0x80usize + n * 8usize) as _) }
        }
        #[doc = "Channel enable register"]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Channel enable set register"]
        #[inline(always)]
        pub const fn chenset(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Channel enable clear register"]
        #[inline(always)]
        pub const fn chenclr(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize + n * 4usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeChg {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeChg {}
    unsafe impl Sync for SubscribeChg {}
    impl SubscribeChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].EN"]
        #[inline(always)]
        pub const fn en(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task CHG\\[n\\].DIS"]
        #[inline(always)]
        pub const fn dis(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Channel group tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksChg {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksChg {}
    unsafe impl Sync for TasksChg {}
    impl TasksChg {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Enable channel group n"]
        #[inline(always)]
        pub const fn en(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Disable channel group n"]
        #[inline(always)]
        pub const fn dis(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Channel enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable channel 0"]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable channel 0"]
            #[inline(always)]
            pub fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field(
                        "ch",
                        &[
                            self.ch(0usize),
                            self.ch(1usize),
                            self.ch(2usize),
                            self.ch(3usize),
                            self.ch(4usize),
                            self.ch(5usize),
                            self.ch(6usize),
                            self.ch(7usize),
                            self.ch(8usize),
                            self.ch(9usize),
                            self.ch(10usize),
                            self.ch(11usize),
                            self.ch(12usize),
                            self.ch(13usize),
                            self.ch(14usize),
                            self.ch(15usize),
                            self.ch(16usize),
                            self.ch(17usize),
                            self.ch(18usize),
                            self.ch(19usize),
                            self.ch(20usize),
                            self.ch(21usize),
                            self.ch(22usize),
                            self.ch(23usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Chen {
                    ch: [bool; 24usize],
                }
                let proxy = Chen {
                    ch: [
                        self.ch(0usize),
                        self.ch(1usize),
                        self.ch(2usize),
                        self.ch(3usize),
                        self.ch(4usize),
                        self.ch(5usize),
                        self.ch(6usize),
                        self.ch(7usize),
                        self.ch(8usize),
                        self.ch(9usize),
                        self.ch(10usize),
                        self.ch(11usize),
                        self.ch(12usize),
                        self.ch(13usize),
                        self.ch(14usize),
                        self.ch(15usize),
                        self.ch(16usize),
                        self.ch(17usize),
                        self.ch(18usize),
                        self.ch(19usize),
                        self.ch(20usize),
                        self.ch(21usize),
                        self.ch(22usize),
                        self.ch(23usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Channel group n Note: Writes to this register are ignored if either SUBSCRIBE_CHG\\[n\\].EN or SUBSCRIBE_CHG\\[n\\].DIS is enabled"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "Include or exclude channel 0"]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Include or exclude channel 0"]
            #[inline(always)]
            pub fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 24usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field(
                        "ch",
                        &[
                            self.ch(0usize),
                            self.ch(1usize),
                            self.ch(2usize),
                            self.ch(3usize),
                            self.ch(4usize),
                            self.ch(5usize),
                            self.ch(6usize),
                            self.ch(7usize),
                            self.ch(8usize),
                            self.ch(9usize),
                            self.ch(10usize),
                            self.ch(11usize),
                            self.ch(12usize),
                            self.ch(13usize),
                            self.ch(14usize),
                            self.ch(15usize),
                            self.ch(16usize),
                            self.ch(17usize),
                            self.ch(18usize),
                            self.ch(19usize),
                            self.ch(20usize),
                            self.ch(21usize),
                            self.ch(22usize),
                            self.ch(23usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Chg {
                    ch: [bool; 24usize],
                }
                let proxy = Chg {
                    ch: [
                        self.ch(0usize),
                        self.ch(1usize),
                        self.ch(2usize),
                        self.ch(3usize),
                        self.ch(4usize),
                        self.ch(5usize),
                        self.ch(6usize),
                        self.ch(7usize),
                        self.ch(8usize),
                        self.ch(9usize),
                        self.ch(10usize),
                        self.ch(11usize),
                        self.ch(12usize),
                        self.ch(13usize),
                        self.ch(14usize),
                        self.ch(15usize),
                        self.ch(16usize),
                        self.ch(17usize),
                        self.ch(18usize),
                        self.ch(19usize),
                        self.ch(20usize),
                        self.ch(21usize),
                        self.ch(22usize),
                        self.ch(23usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod ecb {
    #[doc = "AES ECB Mode Encryption 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecb {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecb {}
    unsafe impl Sync for Ecb {}
    impl Ecb {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start ECB block encrypt"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Abort a possible executing ECB operation"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "ECB block encrypt complete"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "ECB block encrypt aborted because of a STOP task or due to an error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error status"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn key(self) -> Key {
            unsafe { Key::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "IN EasyDMA channel"]
        #[inline(always)]
        pub const fn in_(self) -> In {
            unsafe { In::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "OUT EasyDMA channel"]
        #[inline(always)]
        pub const fn out(self) -> Out {
            unsafe { Out::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
    }
    #[doc = "IN EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct In {
        ptr: *mut u8,
    }
    unsafe impl Send for In {}
    unsafe impl Sync for In {}
    impl In {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Input pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Key {
        ptr: *mut u8,
    }
    unsafe impl Send for Key {}
    unsafe impl Sync for Key {}
    impl Key {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: 128-bit AES key"]
        #[inline(always)]
        pub const fn value(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "OUT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Out {
        ptr: *mut u8,
    }
    unsafe impl Send for Out {}
    unsafe impl Sync for Out {}
    impl Out {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Output pointer Points to a job list containing encrypted ECB data structure"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Error status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub const fn errorstatus(&self) -> super::vals::Errorstatus {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Errorstatus::from_bits(val as u8)
            }
            #[doc = "Error status when the ERROR event is generated"]
            #[inline(always)]
            pub fn set_errorstatus(&mut self, val: super::vals::Errorstatus) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("errorstatus", &self.errorstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorstatus {
                    errorstatus: super::vals::Errorstatus,
                }
                let proxy = Errorstatus {
                    errorstatus: self.errorstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    end: bool,
                    error: bool,
                }
                let proxy = Int {
                    end: self.end(),
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorstatus {
            #[doc = "No errors have occurred"]
            NO_ERROR = 0x0,
            #[doc = "End of INPTR job list before data structure was read."]
            PREMATURE_INPTR_END = 0x01,
            #[doc = "End of OUTPTR job list before data structure was read."]
            PREMATURE_OUTPTR_END = 0x02,
            #[doc = "Deprecated enumerator - Encryption aborted due to higher priority peripheral requesting or using the AES module."]
            ENCRYPTION_TOO_SLOW = 0x03,
            #[doc = "Bus error during DMA access."]
            DMA_ERROR = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Errorstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorstatus {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorstatus {
            #[inline(always)]
            fn from(val: u8) -> Errorstatus {
                Errorstatus::from_bits(val)
            }
        }
        impl From<Errorstatus> for u8 {
            #[inline(always)]
            fn from(val: Errorstatus) -> u8 {
                Errorstatus::to_bits(val)
            }
        }
    }
}
pub mod egu {
    #[doc = "Event generator unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Egu {
        ptr: *mut u8,
    }
    unsafe impl Send for Egu {}
    unsafe impl Sync for Egu {}
    impl Egu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Trigger n for triggering the corresponding TRIGGERED\\[n\\] event"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Event number n generated by triggering the corresponding TRIGGER\\[n\\] task"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[inline(always)]
            pub const fn triggered(&self, n: usize) -> bool {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[0\\]"]
            #[inline(always)]
            pub fn set_triggered(&mut self, n: usize, val: bool) {
                assert!(n < 16usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field(
                        "triggered",
                        &[
                            self.triggered(0usize),
                            self.triggered(1usize),
                            self.triggered(2usize),
                            self.triggered(3usize),
                            self.triggered(4usize),
                            self.triggered(5usize),
                            self.triggered(6usize),
                            self.triggered(7usize),
                            self.triggered(8usize),
                            self.triggered(9usize),
                            self.triggered(10usize),
                            self.triggered(11usize),
                            self.triggered(12usize),
                            self.triggered(13usize),
                            self.triggered(14usize),
                            self.triggered(15usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    triggered: [bool; 16usize],
                }
                let proxy = Int {
                    triggered: [
                        self.triggered(0usize),
                        self.triggered(1usize),
                        self.triggered(2usize),
                        self.triggered(3usize),
                        self.triggered(4usize),
                        self.triggered(5usize),
                        self.triggered(6usize),
                        self.triggered(7usize),
                        self.triggered(8usize),
                        self.triggered(9usize),
                        self.triggered(10usize),
                        self.triggered(11usize),
                        self.triggered(12usize),
                        self.triggered(13usize),
                        self.triggered(14usize),
                        self.triggered(15usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod etm {
    #[doc = "Embedded Trace Macrocell"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Etm {
        ptr: *mut u8,
    }
    unsafe impl Send for Etm {}
    unsafe impl Sync for Etm {}
    impl Etm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enables the trace unit."]
        #[inline(always)]
        pub const fn trcprgctlr(self) -> crate::common::Reg<regs::Trcprgctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Controls which PE to trace. Might ignore writes when the trace unit is enabled or not idle. Before writing to this register, ensure that TRCSTATR.IDLE == 1 so that the trace unit can synchronize with the chosen PE. Implemented if TRCIDR3.NUMPROC is greater than zero."]
        #[inline(always)]
        pub const fn trcprocselr(self) -> crate::common::Reg<regs::Trcprocselr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Idle status bit"]
        #[inline(always)]
        pub const fn trcstatr(self) -> crate::common::Reg<regs::Trcstatr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Controls the tracing options This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trcconfigr(self) -> crate::common::Reg<regs::Trcconfigr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Controls the tracing of arbitrary events. If the selected event occurs a trace element is generated in the trace stream according to the settings in TRCEVENTCTL1R.DATAEN and TRCEVENTCTL1R.INSTEN."]
        #[inline(always)]
        pub const fn trceventctl0r(
            self,
        ) -> crate::common::Reg<regs::Trceventctl0r, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Controls the behavior of the events that TRCEVENTCTL0R selects. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trceventctl1r(
            self,
        ) -> crate::common::Reg<regs::Trceventctl1r, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Enables trace unit functionality that prevents trace unit buffer overflows. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCIDR3.STALLCTL == 1."]
        #[inline(always)]
        pub const fn trcstallctlr(
            self,
        ) -> crate::common::Reg<regs::Trcstallctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Controls the insertion of global timestamps in the trace streams. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.TS == 1."]
        #[inline(always)]
        pub const fn trctsctlr(self) -> crate::common::Reg<regs::Trctsctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Controls how often trace synchronization requests occur. Might ignore writes when the trace unit is enabled or not idle. If writes are permitted then the register must be programmed."]
        #[inline(always)]
        pub const fn trcsyncpr(self) -> crate::common::Reg<regs::Trcsyncpr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Sets the threshold value for cycle counting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.CCI==1."]
        #[inline(always)]
        pub const fn trcccctlr(self) -> crate::common::Reg<regs::Trcccctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Controls which regions in the memory map are enabled to use branch broadcasting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.BB == 1."]
        #[inline(always)]
        pub const fn trcbbctlr(self) -> crate::common::Reg<regs::Trcbbctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Sets the trace ID for instruction trace. If data trace is enabled then it also sets the trace ID for data trace, to (trace ID for instruction trace) + 1. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trctraceidr(self) -> crate::common::Reg<regs::Trctraceidr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Controls when Q elements are enabled. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed if it is implemented and TRCCONFIGR.QE is set to any value other than 0b00."]
        #[inline(always)]
        pub const fn trcqctlr(self) -> crate::common::Reg<regs::Trcqctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Controls instruction trace filtering. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. Must be programmed, particularly to set the value of the SSSTATUS bit, which sets the state of the start/stop logic."]
        #[inline(always)]
        pub const fn trcvictlr(self) -> crate::common::Reg<regs::Trcvictlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "ViewInst exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcviiectlr(self) -> crate::common::Reg<regs::Trcviiectlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Use this to set, or read, the single address comparators that control the ViewInst start/stop logic. The start/stop logic is active for an instruction which causes a start and remains active up to and including an instruction which causes a stop, and then the start/stop logic becomes inactive. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[inline(always)]
        pub const fn trcvissctlr(self) -> crate::common::Reg<regs::Trcvissctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Use this to set, or read, which PE comparator inputs can control the ViewInst start/stop logic. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[inline(always)]
        pub const fn trcvipcssctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvipcssctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Controls data trace filtering. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when data tracing is enabled, that is, when either TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1."]
        #[inline(always)]
        pub const fn trcvdctlr(self) -> crate::common::Reg<regs::Trcvdctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcvdsacctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvdsacctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[inline(always)]
        pub const fn trcvdarcctlr(
            self,
        ) -> crate::common::Reg<regs::Trcvdarcctlr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "Description collection: Moves the sequencer state according to programmed events. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqevr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trcseqevr, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Moves the sequencer to state 0 when a programmed event occurs. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqrstevr(
            self,
        ) -> crate::common::Reg<regs::Trcseqrstevr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Use this to set, or read, the sequencer state. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcseqstr(self) -> crate::common::Reg<regs::Trcseqstr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Use this to set, or read, which external inputs are resources to the trace unit. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[inline(always)]
        pub const fn trcextinselr(
            self,
        ) -> crate::common::Reg<regs::Trcextinselr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Description collection: This sets or returns the reload count value for counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntrldvr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntrldvr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Controls the operation of counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntctlr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntctlr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: This sets or returns the value of counter n. The count value is only stable when TRCSTATR.PMSTABLE == 1. If software uses counter n then it must write to this register to set the initial counter value. Might ignore writes when the trace unit is enabled or not idle."]
        #[inline(always)]
        pub const fn trccntvr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trccntvr, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0160usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Controls the selection of the resources in the trace unit. Might ignore writes when the trace unit is enabled or not idle. If software selects a non-implemented resource then CONSTRAINED UNPREDICTABLE behavior of the resource selector occurs, so the resource selector might fire unexpectedly or might not fire. Reads of the TRCRSCTLRn might return UNKNOWN."]
        #[inline(always)]
        pub const fn trcrsctlr(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Trcrsctlr, crate::common::RW> {
            assert!(n < 30usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize + n * 4usize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcssccr0(self) -> crate::common::Reg<regs::Trcssccr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0280usize) as _) }
        }
        #[doc = "Indicates the status of the single-shot comparators. TRCSSCSR0 is sensitive toinstruction addresses."]
        #[inline(always)]
        pub const fn trcsscsr0(self) -> crate::common::Reg<regs::Trcsscsr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02a0usize) as _) }
        }
        #[doc = "Selects the processor comparator inputs for Single-shot control."]
        #[inline(always)]
        pub const fn trcsspcicr0(self) -> crate::common::Reg<regs::Trcsspcicr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x02c0usize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcpdcr(self) -> crate::common::Reg<regs::Trcpdcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0310usize) as _) }
        }
        #[doc = "Indicates the power down status of the ETM."]
        #[inline(always)]
        pub const fn trcpdsr(self) -> crate::common::Reg<regs::Trcpdsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0314usize) as _) }
        }
        #[doc = "Sets the state of output pins."]
        #[inline(always)]
        pub const fn trcitatbidr(self) -> crate::common::Reg<regs::Trcitatbidr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ee4usize) as _) }
        }
        #[doc = "Reads the state of the input pins."]
        #[inline(always)]
        pub const fn trcitiatbinr(
            self,
        ) -> crate::common::Reg<regs::Trcitiatbinr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef4usize) as _) }
        }
        #[doc = "Sets the state of the output pins."]
        #[inline(always)]
        pub const fn trcitiatboutr(
            self,
        ) -> crate::common::Reg<regs::Trcitiatboutr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0efcusize) as _) }
        }
        #[doc = "Enables topology detection or integration testing, by putting ETM-M33 into integration mode."]
        #[inline(always)]
        pub const fn trcitctrl(self) -> crate::common::Reg<regs::Trcitctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f00usize) as _) }
        }
        #[doc = "Sets bits in the claim tag and determines the number of claim tag bits implemented."]
        #[inline(always)]
        pub const fn trcclaimset(self) -> crate::common::Reg<regs::Trcclaimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa0usize) as _) }
        }
        #[doc = "Clears bits in the claim tag and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn trcclaimclr(self) -> crate::common::Reg<regs::Trcclaimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn trcauthstatus(
            self,
        ) -> crate::common::Reg<regs::Trcauthstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb8usize) as _) }
        }
        #[doc = "The TRCDEVARCH identifies ETM-M33 as an ETMv4.2 component"]
        #[inline(always)]
        pub const fn trcdevarch(self) -> crate::common::Reg<regs::Trcdevarch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fbcusize) as _) }
        }
        #[doc = "Controls the single-shot comparator."]
        #[inline(always)]
        pub const fn trcdevtype(self) -> crate::common::Reg<regs::Trcdevtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fccusize) as _) }
        }
        #[doc = "Description collection: Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn trcpidr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fd0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Coresight component identification registers."]
        #[inline(always)]
        pub const fn trccidr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff0usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcauthstatus(pub u32);
        impl Trcauthstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Trcauthstatus {
            #[inline(always)]
            fn default() -> Trcauthstatus {
                Trcauthstatus(0)
            }
        }
        impl core::fmt::Debug for Trcauthstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcauthstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcauthstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcauthstatus {
                    nsid: super::vals::Nsid,
                    nsnid: super::vals::Nsnid,
                    sid: super::vals::Sid,
                    snid: super::vals::Snid,
                }
                let proxy = Trcauthstatus {
                    nsid: self.nsid(),
                    nsnid: self.nsnid(),
                    sid: self.sid(),
                    snid: self.snid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls which regions in the memory map are enabled to use branch broadcasting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.BB == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcbbctlr(pub u32);
        impl Trcbbctlr {
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[0\\] controls the selection of address range comparator pair 0."]
            #[inline(always)]
            pub const fn range_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[0\\] controls the selection of address range comparator pair 0."]
            #[inline(always)]
            pub fn set_range_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[1\\] controls the selection of address range comparator pair 1."]
            #[inline(always)]
            pub const fn range_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[1\\] controls the selection of address range comparator pair 1."]
            #[inline(always)]
            pub fn set_range_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[2\\] controls the selection of address range comparator pair 2."]
            #[inline(always)]
            pub const fn range_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[2\\] controls the selection of address range comparator pair 2."]
            #[inline(always)]
            pub fn set_range_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[3\\] controls the selection of address range comparator pair 3."]
            #[inline(always)]
            pub const fn range_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[3\\] controls the selection of address range comparator pair 3."]
            #[inline(always)]
            pub fn set_range_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[4\\] controls the selection of address range comparator pair 4."]
            #[inline(always)]
            pub const fn range_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[4\\] controls the selection of address range comparator pair 4."]
            #[inline(always)]
            pub fn set_range_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[5\\] controls the selection of address range comparator pair 5."]
            #[inline(always)]
            pub const fn range_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[5\\] controls the selection of address range comparator pair 5."]
            #[inline(always)]
            pub fn set_range_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[6\\] controls the selection of address range comparator pair 6."]
            #[inline(always)]
            pub const fn range_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[6\\] controls the selection of address range comparator pair 6."]
            #[inline(always)]
            pub fn set_range_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[7\\] controls the selection of address range comparator pair 7."]
            #[inline(always)]
            pub const fn range_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Address range field. Selects which address range comparator pairs are in use with branch broadcasting. Each field represents an address range comparator pair, so field\\[7\\] controls the selection of address range comparator pair 7."]
            #[inline(always)]
            pub fn set_range_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Trcbbctlr {
            #[inline(always)]
            fn default() -> Trcbbctlr {
                Trcbbctlr(0)
            }
        }
        impl core::fmt::Debug for Trcbbctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcbbctlr")
                    .field("range_0", &self.range_0())
                    .field("range_1", &self.range_1())
                    .field("range_2", &self.range_2())
                    .field("range_3", &self.range_3())
                    .field("range_4", &self.range_4())
                    .field("range_5", &self.range_5())
                    .field("range_6", &self.range_6())
                    .field("range_7", &self.range_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcbbctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcbbctlr {
                    range_0: bool,
                    range_1: bool,
                    range_2: bool,
                    range_3: bool,
                    range_4: bool,
                    range_5: bool,
                    range_6: bool,
                    range_7: bool,
                }
                let proxy = Trcbbctlr {
                    range_0: self.range_0(),
                    range_1: self.range_1(),
                    range_2: self.range_2(),
                    range_3: self.range_3(),
                    range_4: self.range_4(),
                    range_5: self.range_5(),
                    range_6: self.range_6(),
                    range_7: self.range_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sets the threshold value for cycle counting. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.CCI==1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcccctlr(pub u32);
        impl Trcccctlr {
            #[doc = "Sets the threshold value for instruction trace cycle counting."]
            #[inline(always)]
            pub const fn threshold(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Sets the threshold value for instruction trace cycle counting."]
            #[inline(always)]
            pub fn set_threshold(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Trcccctlr {
            #[inline(always)]
            fn default() -> Trcccctlr {
                Trcccctlr(0)
            }
        }
        impl core::fmt::Debug for Trcccctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcccctlr")
                    .field("threshold", &self.threshold())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcccctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcccctlr {
                    threshold: u16,
                }
                let proxy = Trcccctlr {
                    threshold: self.threshold(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Clears bits in the claim tag and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcclaimclr(pub u32);
        impl Trcclaimclr {
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn clr_0(&self) -> super::vals::Clr0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Clr0::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub fn set_clr_0(&mut self, val: super::vals::Clr0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn clr_1(&self) -> super::vals::Clr1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Clr1::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub fn set_clr_1(&mut self, val: super::vals::Clr1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn clr_2(&self) -> super::vals::Clr2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clr2::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub fn set_clr_2(&mut self, val: super::vals::Clr2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub const fn clr_3(&self) -> super::vals::Clr3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Clr3::from_bits(val as u8)
            }
            #[doc = "Claim tag clear register"]
            #[inline(always)]
            pub fn set_clr_3(&mut self, val: super::vals::Clr3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcclaimclr {
            #[inline(always)]
            fn default() -> Trcclaimclr {
                Trcclaimclr(0)
            }
        }
        impl core::fmt::Debug for Trcclaimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcclaimclr")
                    .field("clr_0", &self.clr_0())
                    .field("clr_1", &self.clr_1())
                    .field("clr_2", &self.clr_2())
                    .field("clr_3", &self.clr_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcclaimclr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcclaimclr {
                    clr_0: super::vals::Clr0,
                    clr_1: super::vals::Clr1,
                    clr_2: super::vals::Clr2,
                    clr_3: super::vals::Clr3,
                }
                let proxy = Trcclaimclr {
                    clr_0: self.clr_0(),
                    clr_1: self.clr_1(),
                    clr_2: self.clr_2(),
                    clr_3: self.clr_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sets bits in the claim tag and determines the number of claim tag bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcclaimset(pub u32);
        impl Trcclaimset {
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_0(&self) -> super::vals::Set0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Set0::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub fn set_set_0(&mut self, val: super::vals::Set0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_1(&self) -> super::vals::Set1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Set1::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub fn set_set_1(&mut self, val: super::vals::Set1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_2(&self) -> super::vals::Set2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Set2::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub fn set_set_2(&mut self, val: super::vals::Set2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub const fn set_3(&self) -> super::vals::Set3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Set3::from_bits(val as u8)
            }
            #[doc = "Claim tag set register"]
            #[inline(always)]
            pub fn set_set_3(&mut self, val: super::vals::Set3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcclaimset {
            #[inline(always)]
            fn default() -> Trcclaimset {
                Trcclaimset(0)
            }
        }
        impl core::fmt::Debug for Trcclaimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcclaimset")
                    .field("set_0", &self.set_0())
                    .field("set_1", &self.set_1())
                    .field("set_2", &self.set_2())
                    .field("set_3", &self.set_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcclaimset {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcclaimset {
                    set_0: super::vals::Set0,
                    set_1: super::vals::Set1,
                    set_2: super::vals::Set2,
                    set_3: super::vals::Set3,
                }
                let proxy = Trcclaimset {
                    set_0: self.set_0(),
                    set_1: self.set_1(),
                    set_2: self.set_2(),
                    set_3: self.set_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Controls the operation of counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntctlr(pub u32);
        impl Trccntctlr {
            #[doc = "Selects an event, that when it occurs causes counter n to decrement."]
            #[inline(always)]
            pub const fn cntevent(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Selects an event, that when it occurs causes counter n to decrement."]
            #[inline(always)]
            pub fn set_cntevent(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Selects an event, that when it occurs causes a reload event for counter n."]
            #[inline(always)]
            pub const fn rldevent(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Selects an event, that when it occurs causes a reload event for counter n."]
            #[inline(always)]
            pub fn set_rldevent(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Controls whether a reload event occurs for counter n, when counter n reaches zero."]
            #[inline(always)]
            pub const fn rldself(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Controls whether a reload event occurs for counter n, when counter n reaches zero."]
            #[inline(always)]
            pub fn set_rldself(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "For TRCCNTCTLR3 and TRCCNTCTLR1, this bit controls whether counter n decrements when a reload event occurs for counter n-1."]
            #[inline(always)]
            pub const fn cntchain(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "For TRCCNTCTLR3 and TRCCNTCTLR1, this bit controls whether counter n decrements when a reload event occurs for counter n-1."]
            #[inline(always)]
            pub fn set_cntchain(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Trccntctlr {
            #[inline(always)]
            fn default() -> Trccntctlr {
                Trccntctlr(0)
            }
        }
        impl core::fmt::Debug for Trccntctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntctlr")
                    .field("cntevent", &self.cntevent())
                    .field("rldevent", &self.rldevent())
                    .field("rldself", &self.rldself())
                    .field("cntchain", &self.cntchain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trccntctlr {
                    cntevent: u8,
                    rldevent: u8,
                    rldself: bool,
                    cntchain: bool,
                }
                let proxy = Trccntctlr {
                    cntevent: self.cntevent(),
                    rldevent: self.rldevent(),
                    rldself: self.rldself(),
                    cntchain: self.cntchain(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: This sets or returns the reload count value for counter n. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntrldvr(pub u32);
        impl Trccntrldvr {
            #[doc = "Contains the reload value for counter n. When a reload event occurs for counter n then the trace unit copies the VALUEn field into counter n."]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Contains the reload value for counter n. When a reload event occurs for counter n then the trace unit copies the VALUEn field into counter n."]
            #[inline(always)]
            pub fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Trccntrldvr {
            #[inline(always)]
            fn default() -> Trccntrldvr {
                Trccntrldvr(0)
            }
        }
        impl core::fmt::Debug for Trccntrldvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntrldvr")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntrldvr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trccntrldvr {
                    value: u16,
                }
                let proxy = Trccntrldvr {
                    value: self.value(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: This sets or returns the value of counter n. The count value is only stable when TRCSTATR.PMSTABLE == 1. If software uses counter n then it must write to this register to set the initial counter value. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trccntvr(pub u32);
        impl Trccntvr {
            #[doc = "Contains the count value of counter n."]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Contains the count value of counter n."]
            #[inline(always)]
            pub fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Trccntvr {
            #[inline(always)]
            fn default() -> Trccntvr {
                Trccntvr(0)
            }
        }
        impl core::fmt::Debug for Trccntvr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trccntvr")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trccntvr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trccntvr {
                    value: u16,
                }
                let proxy = Trccntvr {
                    value: self.value(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the tracing options This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcconfigr(pub u32);
        impl Trcconfigr {
            #[doc = "Instruction P0 load field. This field controls whether load instructions are traced as P0 instructions."]
            #[inline(always)]
            pub const fn loadasp0inst(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction P0 load field. This field controls whether load instructions are traced as P0 instructions."]
            #[inline(always)]
            pub fn set_loadasp0inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Instruction P0 field. This field controls whether store instructions are traced as P0 instructions."]
            #[inline(always)]
            pub const fn storeasp0inst(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction P0 field. This field controls whether store instructions are traced as P0 instructions."]
            #[inline(always)]
            pub fn set_storeasp0inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Branch broadcast mode bit."]
            #[inline(always)]
            pub const fn bb(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Branch broadcast mode bit."]
            #[inline(always)]
            pub fn set_bb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Cycle counting instruction trace bit."]
            #[inline(always)]
            pub const fn cci(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Cycle counting instruction trace bit."]
            #[inline(always)]
            pub fn set_cci(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Context ID tracing bit."]
            #[inline(always)]
            pub const fn cid(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Context ID tracing bit."]
            #[inline(always)]
            pub fn set_cid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Virtual context identifier tracing bit."]
            #[inline(always)]
            pub const fn vmid(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Virtual context identifier tracing bit."]
            #[inline(always)]
            pub fn set_vmid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Conditional instruction tracing bit."]
            #[inline(always)]
            pub const fn cond(&self) -> super::vals::Cond {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Cond::from_bits(val as u8)
            }
            #[doc = "Conditional instruction tracing bit."]
            #[inline(always)]
            pub fn set_cond(&mut self, val: super::vals::Cond) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Global timestamp tracing bit."]
            #[inline(always)]
            pub const fn ts(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Global timestamp tracing bit."]
            #[inline(always)]
            pub fn set_ts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Return stack enable bit."]
            #[inline(always)]
            pub const fn rs(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Return stack enable bit."]
            #[inline(always)]
            pub fn set_rs(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Q element enable field."]
            #[inline(always)]
            pub const fn qe(&self) -> super::vals::Qe {
                let val = (self.0 >> 13usize) & 0x03;
                super::vals::Qe::from_bits(val as u8)
            }
            #[doc = "Q element enable field."]
            #[inline(always)]
            pub fn set_qe(&mut self, val: super::vals::Qe) {
                self.0 =
                    (self.0 & !(0x03 << 13usize)) | (((val.to_bits() as u32) & 0x03) << 13usize);
            }
            #[doc = "Control bit to select the Virtual context identifier value used by the trace unit, both for trace generation and in the Virtual context identifier comparators."]
            #[inline(always)]
            pub const fn vmidopt(&self) -> super::vals::Vmidopt {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Vmidopt::from_bits(val as u8)
            }
            #[doc = "Control bit to select the Virtual context identifier value used by the trace unit, both for trace generation and in the Virtual context identifier comparators."]
            #[inline(always)]
            pub fn set_vmidopt(&mut self, val: super::vals::Vmidopt) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Data address tracing bit."]
            #[inline(always)]
            pub const fn da(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Data address tracing bit."]
            #[inline(always)]
            pub fn set_da(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Data value tracing bit."]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Data value tracing bit."]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Trcconfigr {
            #[inline(always)]
            fn default() -> Trcconfigr {
                Trcconfigr(0)
            }
        }
        impl core::fmt::Debug for Trcconfigr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcconfigr")
                    .field("loadasp0inst", &self.loadasp0inst())
                    .field("storeasp0inst", &self.storeasp0inst())
                    .field("bb", &self.bb())
                    .field("cci", &self.cci())
                    .field("cid", &self.cid())
                    .field("vmid", &self.vmid())
                    .field("cond", &self.cond())
                    .field("ts", &self.ts())
                    .field("rs", &self.rs())
                    .field("qe", &self.qe())
                    .field("vmidopt", &self.vmidopt())
                    .field("da", &self.da())
                    .field("dv", &self.dv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcconfigr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcconfigr {
                    loadasp0inst: bool,
                    storeasp0inst: bool,
                    bb: bool,
                    cci: bool,
                    cid: bool,
                    vmid: bool,
                    cond: super::vals::Cond,
                    ts: bool,
                    rs: bool,
                    qe: super::vals::Qe,
                    vmidopt: super::vals::Vmidopt,
                    da: bool,
                    dv: bool,
                }
                let proxy = Trcconfigr {
                    loadasp0inst: self.loadasp0inst(),
                    storeasp0inst: self.storeasp0inst(),
                    bb: self.bb(),
                    cci: self.cci(),
                    cid: self.cid(),
                    vmid: self.vmid(),
                    cond: self.cond(),
                    ts: self.ts(),
                    rs: self.rs(),
                    qe: self.qe(),
                    vmidopt: self.vmidopt(),
                    da: self.da(),
                    dv: self.dv(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The TRCDEVARCH identifies ETM-M33 as an ETMv4.2 component"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcdevarch(pub u32);
        impl Trcdevarch {
            #[doc = "Architecture ID"]
            #[inline(always)]
            pub const fn archid(&self) -> super::vals::Archid {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::Archid::from_bits(val as u16)
            }
            #[doc = "Architecture ID"]
            #[inline(always)]
            pub fn set_archid(&mut self, val: super::vals::Archid) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
            #[doc = "Architecture revision"]
            #[inline(always)]
            pub const fn revision(&self) -> super::vals::Revision {
                let val = (self.0 >> 16usize) & 0x0f;
                super::vals::Revision::from_bits(val as u8)
            }
            #[doc = "Architecture revision"]
            #[inline(always)]
            pub fn set_revision(&mut self, val: super::vals::Revision) {
                self.0 =
                    (self.0 & !(0x0f << 16usize)) | (((val.to_bits() as u32) & 0x0f) << 16usize);
            }
            #[doc = "This register is implemented"]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "This register is implemented"]
            #[inline(always)]
            pub fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "Defines the architect of the component"]
            #[inline(always)]
            pub const fn architect(&self) -> super::vals::Architect {
                let val = (self.0 >> 21usize) & 0x07ff;
                super::vals::Architect::from_bits(val as u16)
            }
            #[doc = "Defines the architect of the component"]
            #[inline(always)]
            pub fn set_architect(&mut self, val: super::vals::Architect) {
                self.0 = (self.0 & !(0x07ff << 21usize))
                    | (((val.to_bits() as u32) & 0x07ff) << 21usize);
            }
        }
        impl Default for Trcdevarch {
            #[inline(always)]
            fn default() -> Trcdevarch {
                Trcdevarch(0)
            }
        }
        impl core::fmt::Debug for Trcdevarch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcdevarch")
                    .field("archid", &self.archid())
                    .field("revision", &self.revision())
                    .field("present", &self.present())
                    .field("architect", &self.architect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcdevarch {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcdevarch {
                    archid: super::vals::Archid,
                    revision: super::vals::Revision,
                    present: super::vals::Present,
                    architect: super::vals::Architect,
                }
                let proxy = Trcdevarch {
                    archid: self.archid(),
                    revision: self.revision(),
                    present: self.present(),
                    architect: self.architect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcdevtype(pub u32);
        impl Trcdevtype {
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Trcdevtype {
            #[inline(always)]
            fn default() -> Trcdevtype {
                Trcdevtype(0)
            }
        }
        impl core::fmt::Debug for Trcdevtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcdevtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcdevtype {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcdevtype {
                    major: super::vals::Major,
                    sub: super::vals::Sub,
                }
                let proxy = Trcdevtype {
                    major: self.major(),
                    sub: self.sub(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the tracing of arbitrary events. If the selected event occurs a trace element is generated in the trace stream according to the settings in TRCEVENTCTL1R.DATAEN and TRCEVENTCTL1R.INSTEN."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trceventctl0r(pub u32);
        impl Trceventctl0r {
            #[doc = "Select which event should generate trace elements."]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should generate trace elements."]
            #[inline(always)]
            pub fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trceventctl0r {
            #[inline(always)]
            fn default() -> Trceventctl0r {
                Trceventctl0r(0)
            }
        }
        impl core::fmt::Debug for Trceventctl0r {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trceventctl0r")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trceventctl0r {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trceventctl0r {
                    event: u8,
                }
                let proxy = Trceventctl0r {
                    event: self.event(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the behavior of the events that TRCEVENTCTL0R selects. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trceventctl1r(pub u32);
        impl Trceventctl1r {
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn insten_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub fn set_insten_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn insten_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub fn set_insten_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn insten_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub fn set_insten_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub const fn insten_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction event enable field."]
            #[inline(always)]
            pub fn set_insten_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Data event enable bit."]
            #[inline(always)]
            pub const fn dataen(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Data event enable bit."]
            #[inline(always)]
            pub fn set_dataen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "AMBA Trace Bus (ATB) trigger enable bit."]
            #[inline(always)]
            pub const fn atb(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "AMBA Trace Bus (ATB) trigger enable bit."]
            #[inline(always)]
            pub fn set_atb(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Low-power state behavior override bit. Controls how a trace unit behaves in low-power state."]
            #[inline(always)]
            pub const fn lpoverride(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Low-power state behavior override bit. Controls how a trace unit behaves in low-power state."]
            #[inline(always)]
            pub fn set_lpoverride(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Trceventctl1r {
            #[inline(always)]
            fn default() -> Trceventctl1r {
                Trceventctl1r(0)
            }
        }
        impl core::fmt::Debug for Trceventctl1r {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trceventctl1r")
                    .field("insten_0", &self.insten_0())
                    .field("insten_1", &self.insten_1())
                    .field("insten_2", &self.insten_2())
                    .field("insten_3", &self.insten_3())
                    .field("dataen", &self.dataen())
                    .field("atb", &self.atb())
                    .field("lpoverride", &self.lpoverride())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trceventctl1r {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trceventctl1r {
                    insten_0: bool,
                    insten_1: bool,
                    insten_2: bool,
                    insten_3: bool,
                    dataen: bool,
                    atb: bool,
                    lpoverride: bool,
                }
                let proxy = Trceventctl1r {
                    insten_0: self.insten_0(),
                    insten_1: self.insten_1(),
                    insten_2: self.insten_2(),
                    insten_3: self.insten_3(),
                    dataen: self.dataen(),
                    atb: self.atb(),
                    lpoverride: self.lpoverride(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Use this to set, or read, which external inputs are resources to the trace unit. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcextinselr(pub u32);
        impl Trcextinselr {
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn sel_0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub fn set_sel_0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn sel_1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub fn set_sel_1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn sel_2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub fn set_sel_2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub const fn sel_3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Each field in this collection selects an external input as a resource for the trace unit."]
            #[inline(always)]
            pub fn set_sel_3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Trcextinselr {
            #[inline(always)]
            fn default() -> Trcextinselr {
                Trcextinselr(0)
            }
        }
        impl core::fmt::Debug for Trcextinselr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcextinselr")
                    .field("sel_0", &self.sel_0())
                    .field("sel_1", &self.sel_1())
                    .field("sel_2", &self.sel_2())
                    .field("sel_3", &self.sel_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcextinselr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcextinselr {
                    sel_0: u8,
                    sel_1: u8,
                    sel_2: u8,
                    sel_3: u8,
                }
                let proxy = Trcextinselr {
                    sel_0: self.sel_0(),
                    sel_1: self.sel_1(),
                    sel_2: self.sel_2(),
                    sel_3: self.sel_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sets the state of output pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitatbidr(pub u32);
        impl Trcitatbidr {
            #[doc = "Drives the ATIDMI\\[0\\] output pin."]
            #[inline(always)]
            pub const fn id_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[0\\] output pin."]
            #[inline(always)]
            pub fn set_id_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Drives the ATIDMI\\[1\\] output pin."]
            #[inline(always)]
            pub const fn id_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[1\\] output pin."]
            #[inline(always)]
            pub fn set_id_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Drives the ATIDMI\\[2\\] output pin."]
            #[inline(always)]
            pub const fn id_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[2\\] output pin."]
            #[inline(always)]
            pub fn set_id_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Drives the ATIDMI\\[3\\] output pin."]
            #[inline(always)]
            pub const fn id_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[3\\] output pin."]
            #[inline(always)]
            pub fn set_id_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Drives the ATIDMI\\[4\\] output pin."]
            #[inline(always)]
            pub const fn id_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[4\\] output pin."]
            #[inline(always)]
            pub fn set_id_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Drives the ATIDMI\\[5\\] output pin."]
            #[inline(always)]
            pub const fn id_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[5\\] output pin."]
            #[inline(always)]
            pub fn set_id_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Drives the ATIDMI\\[6\\] output pin."]
            #[inline(always)]
            pub const fn id_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATIDMI\\[6\\] output pin."]
            #[inline(always)]
            pub fn set_id_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Trcitatbidr {
            #[inline(always)]
            fn default() -> Trcitatbidr {
                Trcitatbidr(0)
            }
        }
        impl core::fmt::Debug for Trcitatbidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitatbidr")
                    .field("id_0", &self.id_0())
                    .field("id_1", &self.id_1())
                    .field("id_2", &self.id_2())
                    .field("id_3", &self.id_3())
                    .field("id_4", &self.id_4())
                    .field("id_5", &self.id_5())
                    .field("id_6", &self.id_6())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitatbidr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcitatbidr {
                    id_0: bool,
                    id_1: bool,
                    id_2: bool,
                    id_3: bool,
                    id_4: bool,
                    id_5: bool,
                    id_6: bool,
                }
                let proxy = Trcitatbidr {
                    id_0: self.id_0(),
                    id_1: self.id_1(),
                    id_2: self.id_2(),
                    id_3: self.id_3(),
                    id_4: self.id_4(),
                    id_5: self.id_5(),
                    id_6: self.id_6(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enables topology detection or integration testing, by putting ETM-M33 into integration mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitctrl(pub u32);
        impl Trcitctrl {
            #[doc = "Integration mode enable"]
            #[inline(always)]
            pub const fn ime(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Integration mode enable"]
            #[inline(always)]
            pub fn set_ime(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcitctrl {
            #[inline(always)]
            fn default() -> Trcitctrl {
                Trcitctrl(0)
            }
        }
        impl core::fmt::Debug for Trcitctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitctrl")
                    .field("ime", &self.ime())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitctrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcitctrl {
                    ime: bool,
                }
                let proxy = Trcitctrl { ime: self.ime() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Reads the state of the input pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitiatbinr(pub u32);
        impl Trcitiatbinr {
            #[doc = "Returns the value of the ATVALIDMI input pin."]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the value of the ATVALIDMI input pin."]
            #[inline(always)]
            pub fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the value of the AFREADYMI input pin."]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the value of the AFREADYMI input pin."]
            #[inline(always)]
            pub fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcitiatbinr {
            #[inline(always)]
            fn default() -> Trcitiatbinr {
                Trcitiatbinr(0)
            }
        }
        impl core::fmt::Debug for Trcitiatbinr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitiatbinr")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitiatbinr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcitiatbinr {
                    atvalid: bool,
                    afready: bool,
                }
                let proxy = Trcitiatbinr {
                    atvalid: self.atvalid(),
                    afready: self.afready(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sets the state of the output pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcitiatboutr(pub u32);
        impl Trcitiatboutr {
            #[doc = "Drives the ATVALIDMI output pin."]
            #[inline(always)]
            pub const fn atvalid(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the ATVALIDMI output pin."]
            #[inline(always)]
            pub fn set_atvalid(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Drives the AFREADYMI output pin."]
            #[inline(always)]
            pub const fn afready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Drives the AFREADYMI output pin."]
            #[inline(always)]
            pub fn set_afready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcitiatboutr {
            #[inline(always)]
            fn default() -> Trcitiatboutr {
                Trcitiatboutr(0)
            }
        }
        impl core::fmt::Debug for Trcitiatboutr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcitiatboutr")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcitiatboutr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcitiatboutr {
                    atvalid: bool,
                    afready: bool,
                }
                let proxy = Trcitiatboutr {
                    atvalid: self.atvalid(),
                    afready: self.afready(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcpdcr(pub u32);
        impl Trcpdcr {
            #[doc = "Power up request, to request that power to ETM and access to the trace registers is maintained."]
            #[inline(always)]
            pub const fn pu(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Power up request, to request that power to ETM and access to the trace registers is maintained."]
            #[inline(always)]
            pub fn set_pu(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Trcpdcr {
            #[inline(always)]
            fn default() -> Trcpdcr {
                Trcpdcr(0)
            }
        }
        impl core::fmt::Debug for Trcpdcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcpdcr").field("pu", &self.pu()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcpdcr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcpdcr {
                    pu: bool,
                }
                let proxy = Trcpdcr { pu: self.pu() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates the power down status of the ETM."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcpdsr(pub u32);
        impl Trcpdsr {
            #[doc = "Indicates ETM is powered up"]
            #[inline(always)]
            pub const fn power(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates ETM is powered up"]
            #[inline(always)]
            pub fn set_power(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Sticky power down state. This bit is set to 1 when power to the ETM registers is removed, to indicate that programming state has been lost. It is cleared after a read of the TRCPDSR"]
            #[inline(always)]
            pub const fn stickypd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Sticky power down state. This bit is set to 1 when power to the ETM registers is removed, to indicate that programming state has been lost. It is cleared after a read of the TRCPDSR"]
            #[inline(always)]
            pub fn set_stickypd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcpdsr {
            #[inline(always)]
            fn default() -> Trcpdsr {
                Trcpdsr(0)
            }
        }
        impl core::fmt::Debug for Trcpdsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcpdsr")
                    .field("power", &self.power())
                    .field("stickypd", &self.stickypd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcpdsr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcpdsr {
                    power: bool,
                    stickypd: bool,
                }
                let proxy = Trcpdsr {
                    power: self.power(),
                    stickypd: self.stickypd(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enables the trace unit."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcprgctlr(pub u32);
        impl Trcprgctlr {
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcprgctlr {
            #[inline(always)]
            fn default() -> Trcprgctlr {
                Trcprgctlr(0)
            }
        }
        impl core::fmt::Debug for Trcprgctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcprgctlr")
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcprgctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcprgctlr {
                    en: bool,
                }
                let proxy = Trcprgctlr { en: self.en() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls which PE to trace. Might ignore writes when the trace unit is enabled or not idle. Before writing to this register, ensure that TRCSTATR.IDLE == 1 so that the trace unit can synchronize with the chosen PE. Implemented if TRCIDR3.NUMPROC is greater than zero."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcprocselr(pub u32);
        impl Trcprocselr {
            #[doc = "PE select bits that select the PE to trace."]
            #[inline(always)]
            pub const fn procsel(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "PE select bits that select the PE to trace."]
            #[inline(always)]
            pub fn set_procsel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Trcprocselr {
            #[inline(always)]
            fn default() -> Trcprocselr {
                Trcprocselr(0)
            }
        }
        impl core::fmt::Debug for Trcprocselr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcprocselr")
                    .field("procsel", &self.procsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcprocselr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcprocselr {
                    procsel: u8,
                }
                let proxy = Trcprocselr {
                    procsel: self.procsel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls when Q elements are enabled. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed if it is implemented and TRCCONFIGR.QE is set to any value other than 0b00."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcqctlr(pub u32);
        impl Trcqctlr {
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub const fn range_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Specifies the address range comparators to be used for controlling Q elements."]
            #[inline(always)]
            pub fn set_range_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects whether the address range comparators selected by the RANGE field indicate address ranges where the trace unit is permitted to generate Q elements or address ranges where the trace unit is not permitted to generate Q elements:"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects whether the address range comparators selected by the RANGE field indicate address ranges where the trace unit is permitted to generate Q elements or address ranges where the trace unit is not permitted to generate Q elements:"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Trcqctlr {
            #[inline(always)]
            fn default() -> Trcqctlr {
                Trcqctlr(0)
            }
        }
        impl core::fmt::Debug for Trcqctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcqctlr")
                    .field("range_0", &self.range_0())
                    .field("range_1", &self.range_1())
                    .field("range_2", &self.range_2())
                    .field("range_3", &self.range_3())
                    .field("range_4", &self.range_4())
                    .field("range_5", &self.range_5())
                    .field("range_6", &self.range_6())
                    .field("range_7", &self.range_7())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcqctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcqctlr {
                    range_0: bool,
                    range_1: bool,
                    range_2: bool,
                    range_3: bool,
                    range_4: bool,
                    range_5: bool,
                    range_6: bool,
                    range_7: bool,
                    mode: super::vals::Mode,
                }
                let proxy = Trcqctlr {
                    range_0: self.range_0(),
                    range_1: self.range_1(),
                    range_2: self.range_2(),
                    range_3: self.range_3(),
                    range_4: self.range_4(),
                    range_5: self.range_5(),
                    range_6: self.range_6(),
                    range_7: self.range_7(),
                    mode: self.mode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Controls the selection of the resources in the trace unit. Might ignore writes when the trace unit is enabled or not idle. If software selects a non-implemented resource then CONSTRAINED UNPREDICTABLE behavior of the resource selector occurs, so the resource selector might fire unexpectedly or might not fire. Reads of the TRCRSCTLRn might return UNKNOWN."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcrsctlr(pub u32);
        impl Trcrsctlr {
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Trcrsctlr {
            #[inline(always)]
            fn default() -> Trcrsctlr {
                Trcrsctlr(0)
            }
        }
        impl core::fmt::Debug for Trcrsctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcrsctlr").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcrsctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcrsctlr {
                    en: bool,
                }
                let proxy = Trcrsctlr { en: self.en() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Moves the sequencer state according to programmed events. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqevr(pub u32);
        impl Trcseqevr {
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub const fn f_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Forward field."]
            #[inline(always)]
            pub fn set_f_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub const fn b_7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Backward field."]
            #[inline(always)]
            pub fn set_b_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Trcseqevr {
            #[inline(always)]
            fn default() -> Trcseqevr {
                Trcseqevr(0)
            }
        }
        impl core::fmt::Debug for Trcseqevr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqevr")
                    .field("f_0", &self.f_0())
                    .field("f_1", &self.f_1())
                    .field("f_2", &self.f_2())
                    .field("f_3", &self.f_3())
                    .field("f_4", &self.f_4())
                    .field("f_5", &self.f_5())
                    .field("f_6", &self.f_6())
                    .field("f_7", &self.f_7())
                    .field("b_0", &self.b_0())
                    .field("b_1", &self.b_1())
                    .field("b_2", &self.b_2())
                    .field("b_3", &self.b_3())
                    .field("b_4", &self.b_4())
                    .field("b_5", &self.b_5())
                    .field("b_6", &self.b_6())
                    .field("b_7", &self.b_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqevr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcseqevr {
                    f_0: bool,
                    f_1: bool,
                    f_2: bool,
                    f_3: bool,
                    f_4: bool,
                    f_5: bool,
                    f_6: bool,
                    f_7: bool,
                    b_0: bool,
                    b_1: bool,
                    b_2: bool,
                    b_3: bool,
                    b_4: bool,
                    b_5: bool,
                    b_6: bool,
                    b_7: bool,
                }
                let proxy = Trcseqevr {
                    f_0: self.f_0(),
                    f_1: self.f_1(),
                    f_2: self.f_2(),
                    f_3: self.f_3(),
                    f_4: self.f_4(),
                    f_5: self.f_5(),
                    f_6: self.f_6(),
                    f_7: self.f_7(),
                    b_0: self.b_0(),
                    b_1: self.b_1(),
                    b_2: self.b_2(),
                    b_3: self.b_3(),
                    b_4: self.b_4(),
                    b_5: self.b_5(),
                    b_6: self.b_6(),
                    b_7: self.b_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Moves the sequencer to state 0 when a programmed event occurs. Might ignore writes when the trace unit is enabled or not idle. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqrstevr(pub u32);
        impl Trcseqrstevr {
            #[doc = "Select which event should reset the sequencer."]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should reset the sequencer."]
            #[inline(always)]
            pub fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trcseqrstevr {
            #[inline(always)]
            fn default() -> Trcseqrstevr {
                Trcseqrstevr(0)
            }
        }
        impl core::fmt::Debug for Trcseqrstevr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqrstevr")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqrstevr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcseqrstevr {
                    event: u8,
                }
                let proxy = Trcseqrstevr {
                    event: self.event(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Use this to set, or read, the sequencer state. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. When the sequencer is used, all sequencer state transitions must be programmed with a valid event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcseqstr(pub u32);
        impl Trcseqstr {
            #[doc = "Sets or returns the state of the sequencer."]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Sets or returns the state of the sequencer."]
            #[inline(always)]
            pub fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Trcseqstr {
            #[inline(always)]
            fn default() -> Trcseqstr {
                Trcseqstr(0)
            }
        }
        impl core::fmt::Debug for Trcseqstr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcseqstr")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcseqstr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcseqstr {
                    state: super::vals::State,
                }
                let proxy = Trcseqstr {
                    state: self.state(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the single-shot comparator."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcssccr0(pub u32);
        impl Trcssccr0 {
            #[doc = "Enables the single-shot comparator resource to be reset when it occurs, to enable another comparator match to be detected"]
            #[inline(always)]
            pub const fn rst(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the single-shot comparator resource to be reset when it occurs, to enable another comparator match to be detected"]
            #[inline(always)]
            pub fn set_rst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
        }
        impl Default for Trcssccr0 {
            #[inline(always)]
            fn default() -> Trcssccr0 {
                Trcssccr0(0)
            }
        }
        impl core::fmt::Debug for Trcssccr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcssccr0")
                    .field("rst", &self.rst())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcssccr0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcssccr0 {
                    rst: bool,
                }
                let proxy = Trcssccr0 { rst: self.rst() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates the status of the single-shot comparators. TRCSSCSR0 is sensitive toinstruction addresses."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsscsr0(pub u32);
        impl Trcsscsr0 {
            #[doc = "Instruction address comparator support"]
            #[inline(always)]
            pub const fn inst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction address comparator support"]
            #[inline(always)]
            pub fn set_inst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Data address comparator support"]
            #[inline(always)]
            pub const fn da(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Data address comparator support"]
            #[inline(always)]
            pub fn set_da(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Data value comparator support"]
            #[inline(always)]
            pub const fn dv(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Data value comparator support"]
            #[inline(always)]
            pub fn set_dv(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Process counter value comparator support"]
            #[inline(always)]
            pub const fn pc(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Process counter value comparator support"]
            #[inline(always)]
            pub fn set_pc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Single-shot status. This indicates whether any of the selected comparators have matched."]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Single-shot status. This indicates whether any of the selected comparators have matched."]
            #[inline(always)]
            pub fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Trcsscsr0 {
            #[inline(always)]
            fn default() -> Trcsscsr0 {
                Trcsscsr0(0)
            }
        }
        impl core::fmt::Debug for Trcsscsr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsscsr0")
                    .field("inst", &self.inst())
                    .field("da", &self.da())
                    .field("dv", &self.dv())
                    .field("pc", &self.pc())
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsscsr0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcsscsr0 {
                    inst: bool,
                    da: bool,
                    dv: bool,
                    pc: bool,
                    status: bool,
                }
                let proxy = Trcsscsr0 {
                    inst: self.inst(),
                    da: self.da(),
                    dv: self.dv(),
                    pc: self.pc(),
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Selects the processor comparator inputs for Single-shot control."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsspcicr0(pub u32);
        impl Trcsspcicr0 {
            #[doc = "Selects processor comparator 0 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn pc_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 0 inputs for Single-shot control"]
            #[inline(always)]
            pub fn set_pc_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects processor comparator 1 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn pc_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 1 inputs for Single-shot control"]
            #[inline(always)]
            pub fn set_pc_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects processor comparator 2 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn pc_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 2 inputs for Single-shot control"]
            #[inline(always)]
            pub fn set_pc_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects processor comparator 3 inputs for Single-shot control"]
            #[inline(always)]
            pub const fn pc_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects processor comparator 3 inputs for Single-shot control"]
            #[inline(always)]
            pub fn set_pc_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Trcsspcicr0 {
            #[inline(always)]
            fn default() -> Trcsspcicr0 {
                Trcsspcicr0(0)
            }
        }
        impl core::fmt::Debug for Trcsspcicr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsspcicr0")
                    .field("pc_0", &self.pc_0())
                    .field("pc_1", &self.pc_1())
                    .field("pc_2", &self.pc_2())
                    .field("pc_3", &self.pc_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsspcicr0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcsspcicr0 {
                    pc_0: bool,
                    pc_1: bool,
                    pc_2: bool,
                    pc_3: bool,
                }
                let proxy = Trcsspcicr0 {
                    pc_0: self.pc_0(),
                    pc_1: self.pc_1(),
                    pc_2: self.pc_2(),
                    pc_3: self.pc_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enables trace unit functionality that prevents trace unit buffer overflows. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCIDR3.STALLCTL == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcstallctlr(pub u32);
        impl Trcstallctlr {
            #[doc = "Threshold level field. If LEVEL is nonzero then a trace unit might suppress the generation of: Global timestamps in the instruction trace stream and the data trace stream. Cycle counting in the instruction trace stream, although the cumulative cycle count remains correct."]
            #[inline(always)]
            pub const fn level(&self) -> super::vals::Level {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Level::from_bits(val as u8)
            }
            #[doc = "Threshold level field. If LEVEL is nonzero then a trace unit might suppress the generation of: Global timestamps in the instruction trace stream and the data trace stream. Cycle counting in the instruction trace stream, although the cumulative cycle count remains correct."]
            #[inline(always)]
            pub fn set_level(&mut self, val: super::vals::Level) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Instruction stall bit. Controls if a trace unit can stall the PE when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn istall(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Instruction stall bit. Controls if a trace unit can stall the PE when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub fn set_istall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Data stall bit. Controls if a trace unit can stall the PE when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn dstall(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Data stall bit. Controls if a trace unit can stall the PE when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub fn set_dstall(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Prioritize instruction trace bit. Controls if a trace unit can prioritize instruction trace when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn instpriority(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Prioritize instruction trace bit. Controls if a trace unit can prioritize instruction trace when the instruction trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub fn set_instpriority(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a load when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn datadiscardload(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a load when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub fn set_datadiscardload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a store when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub const fn datadiscardstore(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Data discard field. Controls if a trace unit can discard data trace elements on a store when the data trace buffer space is less than LEVEL."]
            #[inline(always)]
            pub fn set_datadiscardstore(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Trace overflow prevention bit."]
            #[inline(always)]
            pub const fn nooverflow(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Trace overflow prevention bit."]
            #[inline(always)]
            pub fn set_nooverflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Trcstallctlr {
            #[inline(always)]
            fn default() -> Trcstallctlr {
                Trcstallctlr(0)
            }
        }
        impl core::fmt::Debug for Trcstallctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcstallctlr")
                    .field("level", &self.level())
                    .field("istall", &self.istall())
                    .field("dstall", &self.dstall())
                    .field("instpriority", &self.instpriority())
                    .field("datadiscardload", &self.datadiscardload())
                    .field("datadiscardstore", &self.datadiscardstore())
                    .field("nooverflow", &self.nooverflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcstallctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcstallctlr {
                    level: super::vals::Level,
                    istall: bool,
                    dstall: bool,
                    instpriority: bool,
                    datadiscardload: bool,
                    datadiscardstore: bool,
                    nooverflow: bool,
                }
                let proxy = Trcstallctlr {
                    level: self.level(),
                    istall: self.istall(),
                    dstall: self.dstall(),
                    instpriority: self.instpriority(),
                    datadiscardload: self.datadiscardload(),
                    datadiscardstore: self.datadiscardstore(),
                    nooverflow: self.nooverflow(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Idle status bit"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcstatr(pub u32);
        impl Trcstatr {
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub const fn idle(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Trace unit enable bit"]
            #[inline(always)]
            pub fn set_idle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Programmers' model stable bit"]
            #[inline(always)]
            pub const fn pmstable(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Programmers' model stable bit"]
            #[inline(always)]
            pub fn set_pmstable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Trcstatr {
            #[inline(always)]
            fn default() -> Trcstatr {
                Trcstatr(0)
            }
        }
        impl core::fmt::Debug for Trcstatr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcstatr")
                    .field("idle", &self.idle())
                    .field("pmstable", &self.pmstable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcstatr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcstatr {
                    idle: bool,
                    pmstable: bool,
                }
                let proxy = Trcstatr {
                    idle: self.idle(),
                    pmstable: self.pmstable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls how often trace synchronization requests occur. Might ignore writes when the trace unit is enabled or not idle. If writes are permitted then the register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcsyncpr(pub u32);
        impl Trcsyncpr {
            #[doc = "Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a trace synchronization request occurs. The number of bytes is always a power of two, calculated by 2^PERIOD"]
            #[inline(always)]
            pub const fn period(&self) -> super::vals::Period {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Period::from_bits(val as u8)
            }
            #[doc = "Controls how many bytes of trace, the sum of instruction and data, that a trace unit can generate before a trace synchronization request occurs. The number of bytes is always a power of two, calculated by 2^PERIOD"]
            #[inline(always)]
            pub fn set_period(&mut self, val: super::vals::Period) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Trcsyncpr {
            #[inline(always)]
            fn default() -> Trcsyncpr {
                Trcsyncpr(0)
            }
        }
        impl core::fmt::Debug for Trcsyncpr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcsyncpr")
                    .field("period", &self.period())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcsyncpr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcsyncpr {
                    period: super::vals::Period,
                }
                let proxy = Trcsyncpr {
                    period: self.period(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sets the trace ID for instruction trace. If data trace is enabled then it also sets the trace ID for data trace, to (trace ID for instruction trace) + 1. This register must always be programmed as part of trace unit initialization. Might ignore writes when the trace unit is enabled or not idle."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trctraceidr(pub u32);
        impl Trctraceidr {
            #[doc = "Trace ID field. Sets the trace ID value for instruction trace. Bit\\[0\\] must be zero if data trace is enabled. If data trace is enabled then a trace unit sets the trace ID for data trace, to TRACEID+1."]
            #[inline(always)]
            pub const fn traceid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Trace ID field. Sets the trace ID value for instruction trace. Bit\\[0\\] must be zero if data trace is enabled. If data trace is enabled then a trace unit sets the trace ID for data trace, to TRACEID+1."]
            #[inline(always)]
            pub fn set_traceid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Trctraceidr {
            #[inline(always)]
            fn default() -> Trctraceidr {
                Trctraceidr(0)
            }
        }
        impl core::fmt::Debug for Trctraceidr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trctraceidr")
                    .field("traceid", &self.traceid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trctraceidr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trctraceidr {
                    traceid: u8,
                }
                let proxy = Trctraceidr {
                    traceid: self.traceid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls the insertion of global timestamps in the trace streams. When the selected event is triggered, the trace unit inserts a global timestamp into the trace streams. Might ignore writes when the trace unit is enabled or not idle. Must be programmed if TRCCONFIGR.TS == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trctsctlr(pub u32);
        impl Trctsctlr {
            #[doc = "Select which event should generate time stamps."]
            #[inline(always)]
            pub const fn event(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select which event should generate time stamps."]
            #[inline(always)]
            pub fn set_event(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Trctsctlr {
            #[inline(always)]
            fn default() -> Trctsctlr {
                Trctsctlr(0)
            }
        }
        impl core::fmt::Debug for Trctsctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trctsctlr")
                    .field("event", &self.event())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trctsctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trctsctlr {
                    event: u8,
                }
                let proxy = Trctsctlr {
                    event: self.event(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdarcctlr(pub u32);
        impl Trcvdarcctlr {
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvdarcctlr {
            #[inline(always)]
            fn default() -> Trcvdarcctlr {
                Trcvdarcctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdarcctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdarcctlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdarcctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcvdarcctlr {
                    include_0: bool,
                    include_1: bool,
                    include_2: bool,
                    include_3: bool,
                    include_4: bool,
                    include_5: bool,
                    include_6: bool,
                    include_7: bool,
                    exclude_0: bool,
                    exclude_1: bool,
                    exclude_2: bool,
                    exclude_3: bool,
                    exclude_4: bool,
                    exclude_5: bool,
                    exclude_6: bool,
                    exclude_7: bool,
                }
                let proxy = Trcvdarcctlr {
                    include_0: self.include_0(),
                    include_1: self.include_1(),
                    include_2: self.include_2(),
                    include_3: self.include_3(),
                    include_4: self.include_4(),
                    include_5: self.include_5(),
                    include_6: self.include_6(),
                    include_7: self.include_7(),
                    exclude_0: self.exclude_0(),
                    exclude_1: self.exclude_1(),
                    exclude_2: self.exclude_2(),
                    exclude_3: self.exclude_3(),
                    exclude_4: self.exclude_4(),
                    exclude_5: self.exclude_5(),
                    exclude_6: self.exclude_6(),
                    exclude_7: self.exclude_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls data trace filtering. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when data tracing is enabled, that is, when either TRCCONFIGR.DA == 1 or TRCCONFIGR.DV == 1."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdctlr(pub u32);
        impl Trcvdctlr {
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub const fn event_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Event unit enable bit."]
            #[inline(always)]
            pub fn set_event_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Stack Pointer (SP)."]
            #[inline(always)]
            pub const fn sprel(&self) -> super::vals::Sprel {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Sprel::from_bits(val as u8)
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Stack Pointer (SP)."]
            #[inline(always)]
            pub fn set_sprel(&mut self, val: super::vals::Sprel) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Program Counter (PC)."]
            #[inline(always)]
            pub const fn pcrel(&self) -> super::vals::Pcrel {
                let val = (self.0 >> 10usize) & 0x01;
                super::vals::Pcrel::from_bits(val as u8)
            }
            #[doc = "Controls whether a trace unit traces data for transfers that are relative to the Program Counter (PC)."]
            #[inline(always)]
            pub fn set_pcrel(&mut self, val: super::vals::Pcrel) {
                self.0 =
                    (self.0 & !(0x01 << 10usize)) | (((val.to_bits() as u32) & 0x01) << 10usize);
            }
            #[doc = "Controls which information a trace unit populates in bits\\[63:56\\] of the data address."]
            #[inline(always)]
            pub const fn tbi(&self) -> super::vals::Tbi {
                let val = (self.0 >> 11usize) & 0x01;
                super::vals::Tbi::from_bits(val as u8)
            }
            #[doc = "Controls which information a trace unit populates in bits\\[63:56\\] of the data address."]
            #[inline(always)]
            pub fn set_tbi(&mut self, val: super::vals::Tbi) {
                self.0 =
                    (self.0 & !(0x01 << 11usize)) | (((val.to_bits() as u32) & 0x01) << 11usize);
            }
            #[doc = "Controls the tracing of data transfers for exceptions and exception returns on Armv6-M, Armv7-M, and Armv8-M PEs."]
            #[inline(always)]
            pub const fn trcexdata(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Controls the tracing of data transfers for exceptions and exception returns on Armv6-M, Armv7-M, and Armv8-M PEs."]
            #[inline(always)]
            pub fn set_trcexdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Trcvdctlr {
            #[inline(always)]
            fn default() -> Trcvdctlr {
                Trcvdctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdctlr")
                    .field("event_0", &self.event_0())
                    .field("event_1", &self.event_1())
                    .field("event_2", &self.event_2())
                    .field("event_3", &self.event_3())
                    .field("event_4", &self.event_4())
                    .field("event_5", &self.event_5())
                    .field("event_6", &self.event_6())
                    .field("event_7", &self.event_7())
                    .field("sprel", &self.sprel())
                    .field("pcrel", &self.pcrel())
                    .field("tbi", &self.tbi())
                    .field("trcexdata", &self.trcexdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcvdctlr {
                    event_0: bool,
                    event_1: bool,
                    event_2: bool,
                    event_3: bool,
                    event_4: bool,
                    event_5: bool,
                    event_6: bool,
                    event_7: bool,
                    sprel: super::vals::Sprel,
                    pcrel: super::vals::Pcrel,
                    tbi: super::vals::Tbi,
                    trcexdata: bool,
                }
                let proxy = Trcvdctlr {
                    event_0: self.event_0(),
                    event_1: self.event_1(),
                    event_2: self.event_2(),
                    event_3: self.event_3(),
                    event_4: self.event_4(),
                    event_5: self.event_5(),
                    event_6: self.event_6(),
                    event_7: self.event_7(),
                    sprel: self.sprel(),
                    pcrel: self.pcrel(),
                    tbi: self.tbi(),
                    trcexdata: self.trcexdata(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "ViewData include / exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvdsacctlr(pub u32);
        impl Trcvdsacctlr {
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData include control."]
            #[inline(always)]
            pub fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewData exclude control."]
            #[inline(always)]
            pub fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvdsacctlr {
            #[inline(always)]
            fn default() -> Trcvdsacctlr {
                Trcvdsacctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvdsacctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvdsacctlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvdsacctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcvdsacctlr {
                    include_0: bool,
                    include_1: bool,
                    include_2: bool,
                    include_3: bool,
                    include_4: bool,
                    include_5: bool,
                    include_6: bool,
                    include_7: bool,
                    exclude_0: bool,
                    exclude_1: bool,
                    exclude_2: bool,
                    exclude_3: bool,
                    exclude_4: bool,
                    exclude_5: bool,
                    exclude_6: bool,
                    exclude_7: bool,
                }
                let proxy = Trcvdsacctlr {
                    include_0: self.include_0(),
                    include_1: self.include_1(),
                    include_2: self.include_2(),
                    include_3: self.include_3(),
                    include_4: self.include_4(),
                    include_5: self.include_5(),
                    include_6: self.include_6(),
                    include_7: self.include_7(),
                    exclude_0: self.exclude_0(),
                    exclude_1: self.exclude_1(),
                    exclude_2: self.exclude_2(),
                    exclude_3: self.exclude_3(),
                    exclude_4: self.exclude_4(),
                    exclude_5: self.exclude_5(),
                    exclude_6: self.exclude_6(),
                    exclude_7: self.exclude_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls instruction trace filtering. Might ignore writes when the trace unit is enabled or not idle. Only returns stable data when TRCSTATR.PMSTABLE == 1. Must be programmed, particularly to set the value of the SSSTATUS bit, which sets the state of the start/stop logic."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvictlr(pub u32);
        impl Trcvictlr {
            #[doc = "Select which resource number should be filtered."]
            #[inline(always)]
            pub const fn event_sel(&self) -> super::vals::EventSel {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::EventSel::from_bits(val as u8)
            }
            #[doc = "Select which resource number should be filtered."]
            #[inline(always)]
            pub fn set_event_sel(&mut self, val: super::vals::EventSel) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "When TRCIDR4.NUMACPAIRS &gt; 0 or TRCIDR4.NUMPC &gt; 0, this bit returns the status of the start/stop logic."]
            #[inline(always)]
            pub const fn ssstatus(&self) -> super::vals::Ssstatus {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Ssstatus::from_bits(val as u8)
            }
            #[doc = "When TRCIDR4.NUMACPAIRS &gt; 0 or TRCIDR4.NUMPC &gt; 0, this bit returns the status of the start/stop logic."]
            #[inline(always)]
            pub fn set_ssstatus(&mut self, val: super::vals::Ssstatus) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Controls whether a trace unit must trace a Reset exception."]
            #[inline(always)]
            pub const fn trcreset(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Controls whether a trace unit must trace a Reset exception."]
            #[inline(always)]
            pub fn set_trcreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "When TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a System error exception."]
            #[inline(always)]
            pub const fn trcerr(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "When TRCIDR3.TRCERR==1, this bit controls whether a trace unit must trace a System error exception."]
            #[inline(always)]
            pub fn set_trcerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub const fn exlevel0_s(&self) -> super::vals::Exlevel0S {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Exlevel0S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub fn set_exlevel0_s(&mut self, val: super::vals::Exlevel0S) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub const fn exlevel1_s(&self) -> super::vals::Exlevel1S {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Exlevel1S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub fn set_exlevel1_s(&mut self, val: super::vals::Exlevel1S) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub const fn exlevel2_s(&self) -> super::vals::Exlevel2S {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Exlevel2S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub fn set_exlevel2_s(&mut self, val: super::vals::Exlevel2S) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub const fn exlevel3_s(&self) -> super::vals::Exlevel3S {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Exlevel3S::from_bits(val as u8)
            }
            #[doc = "In Secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub fn set_exlevel3_s(&mut self, val: super::vals::Exlevel3S) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub const fn exlevel0_ns(&self) -> super::vals::Exlevel0Ns {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Exlevel0Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 0."]
            #[inline(always)]
            pub fn set_exlevel0_ns(&mut self, val: super::vals::Exlevel0Ns) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub const fn exlevel1_ns(&self) -> super::vals::Exlevel1Ns {
                let val = (self.0 >> 21usize) & 0x01;
                super::vals::Exlevel1Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 1."]
            #[inline(always)]
            pub fn set_exlevel1_ns(&mut self, val: super::vals::Exlevel1Ns) {
                self.0 =
                    (self.0 & !(0x01 << 21usize)) | (((val.to_bits() as u32) & 0x01) << 21usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub const fn exlevel2_ns(&self) -> super::vals::Exlevel2Ns {
                let val = (self.0 >> 22usize) & 0x01;
                super::vals::Exlevel2Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 2."]
            #[inline(always)]
            pub fn set_exlevel2_ns(&mut self, val: super::vals::Exlevel2Ns) {
                self.0 =
                    (self.0 & !(0x01 << 22usize)) | (((val.to_bits() as u32) & 0x01) << 22usize);
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub const fn exlevel3_ns(&self) -> super::vals::Exlevel3Ns {
                let val = (self.0 >> 23usize) & 0x01;
                super::vals::Exlevel3Ns::from_bits(val as u8)
            }
            #[doc = "In Non-secure state, each bit controls whether instruction tracing is enabled for the corresponding Exception level 3."]
            #[inline(always)]
            pub fn set_exlevel3_ns(&mut self, val: super::vals::Exlevel3Ns) {
                self.0 =
                    (self.0 & !(0x01 << 23usize)) | (((val.to_bits() as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvictlr {
            #[inline(always)]
            fn default() -> Trcvictlr {
                Trcvictlr(0)
            }
        }
        impl core::fmt::Debug for Trcvictlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvictlr")
                    .field("event_sel", &self.event_sel())
                    .field("ssstatus", &self.ssstatus())
                    .field("trcreset", &self.trcreset())
                    .field("trcerr", &self.trcerr())
                    .field("exlevel0_s", &self.exlevel0_s())
                    .field("exlevel1_s", &self.exlevel1_s())
                    .field("exlevel2_s", &self.exlevel2_s())
                    .field("exlevel3_s", &self.exlevel3_s())
                    .field("exlevel0_ns", &self.exlevel0_ns())
                    .field("exlevel1_ns", &self.exlevel1_ns())
                    .field("exlevel2_ns", &self.exlevel2_ns())
                    .field("exlevel3_ns", &self.exlevel3_ns())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvictlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcvictlr {
                    event_sel: super::vals::EventSel,
                    ssstatus: super::vals::Ssstatus,
                    trcreset: bool,
                    trcerr: bool,
                    exlevel0_s: super::vals::Exlevel0S,
                    exlevel1_s: super::vals::Exlevel1S,
                    exlevel2_s: super::vals::Exlevel2S,
                    exlevel3_s: super::vals::Exlevel3S,
                    exlevel0_ns: super::vals::Exlevel0Ns,
                    exlevel1_ns: super::vals::Exlevel1Ns,
                    exlevel2_ns: super::vals::Exlevel2Ns,
                    exlevel3_ns: super::vals::Exlevel3Ns,
                }
                let proxy = Trcvictlr {
                    event_sel: self.event_sel(),
                    ssstatus: self.ssstatus(),
                    trcreset: self.trcreset(),
                    trcerr: self.trcerr(),
                    exlevel0_s: self.exlevel0_s(),
                    exlevel1_s: self.exlevel1_s(),
                    exlevel2_s: self.exlevel2_s(),
                    exlevel3_s: self.exlevel3_s(),
                    exlevel0_ns: self.exlevel0_ns(),
                    exlevel1_ns: self.exlevel1_ns(),
                    exlevel2_ns: self.exlevel2_ns(),
                    exlevel3_ns: self.exlevel3_ns(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "ViewInst exclude control. Might ignore writes when the trace unit is enabled or not idle. This register must be programmed when one or more address comparators are implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcviiectlr(pub u32);
        impl Trcviiectlr {
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub const fn include_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Include range field. Selects which address range comparator pairs are in use with ViewInst include control."]
            #[inline(always)]
            pub fn set_include_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub const fn exclude_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Exclude range field. Selects which address range comparator pairs are in use with ViewInst exclude control."]
            #[inline(always)]
            pub fn set_exclude_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcviiectlr {
            #[inline(always)]
            fn default() -> Trcviiectlr {
                Trcviiectlr(0)
            }
        }
        impl core::fmt::Debug for Trcviiectlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcviiectlr")
                    .field("include_0", &self.include_0())
                    .field("include_1", &self.include_1())
                    .field("include_2", &self.include_2())
                    .field("include_3", &self.include_3())
                    .field("include_4", &self.include_4())
                    .field("include_5", &self.include_5())
                    .field("include_6", &self.include_6())
                    .field("include_7", &self.include_7())
                    .field("exclude_0", &self.exclude_0())
                    .field("exclude_1", &self.exclude_1())
                    .field("exclude_2", &self.exclude_2())
                    .field("exclude_3", &self.exclude_3())
                    .field("exclude_4", &self.exclude_4())
                    .field("exclude_5", &self.exclude_5())
                    .field("exclude_6", &self.exclude_6())
                    .field("exclude_7", &self.exclude_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcviiectlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcviiectlr {
                    include_0: bool,
                    include_1: bool,
                    include_2: bool,
                    include_3: bool,
                    include_4: bool,
                    include_5: bool,
                    include_6: bool,
                    include_7: bool,
                    exclude_0: bool,
                    exclude_1: bool,
                    exclude_2: bool,
                    exclude_3: bool,
                    exclude_4: bool,
                    exclude_5: bool,
                    exclude_6: bool,
                    exclude_7: bool,
                }
                let proxy = Trcviiectlr {
                    include_0: self.include_0(),
                    include_1: self.include_1(),
                    include_2: self.include_2(),
                    include_3: self.include_3(),
                    include_4: self.include_4(),
                    include_5: self.include_5(),
                    include_6: self.include_6(),
                    include_7: self.include_7(),
                    exclude_0: self.exclude_0(),
                    exclude_1: self.exclude_1(),
                    exclude_2: self.exclude_2(),
                    exclude_3: self.exclude_3(),
                    exclude_4: self.exclude_4(),
                    exclude_5: self.exclude_5(),
                    exclude_6: self.exclude_6(),
                    exclude_7: self.exclude_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Use this to set, or read, which PE comparator inputs can control the ViewInst start/stop logic. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvipcssctlr(pub u32);
        impl Trcvipcssctlr {
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub const fn start_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of starting trace"]
            #[inline(always)]
            pub fn set_start_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub const fn stop_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which PE comparator inputs are in use with ViewInst start/stop control, for the purpose of stopping trace."]
            #[inline(always)]
            pub fn set_stop_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvipcssctlr {
            #[inline(always)]
            fn default() -> Trcvipcssctlr {
                Trcvipcssctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvipcssctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvipcssctlr")
                    .field("start_0", &self.start_0())
                    .field("start_1", &self.start_1())
                    .field("start_2", &self.start_2())
                    .field("start_3", &self.start_3())
                    .field("start_4", &self.start_4())
                    .field("start_5", &self.start_5())
                    .field("start_6", &self.start_6())
                    .field("start_7", &self.start_7())
                    .field("stop_0", &self.stop_0())
                    .field("stop_1", &self.stop_1())
                    .field("stop_2", &self.stop_2())
                    .field("stop_3", &self.stop_3())
                    .field("stop_4", &self.stop_4())
                    .field("stop_5", &self.stop_5())
                    .field("stop_6", &self.stop_6())
                    .field("stop_7", &self.stop_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvipcssctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcvipcssctlr {
                    start_0: bool,
                    start_1: bool,
                    start_2: bool,
                    start_3: bool,
                    start_4: bool,
                    start_5: bool,
                    start_6: bool,
                    start_7: bool,
                    stop_0: bool,
                    stop_1: bool,
                    stop_2: bool,
                    stop_3: bool,
                    stop_4: bool,
                    stop_5: bool,
                    stop_6: bool,
                    stop_7: bool,
                }
                let proxy = Trcvipcssctlr {
                    start_0: self.start_0(),
                    start_1: self.start_1(),
                    start_2: self.start_2(),
                    start_3: self.start_3(),
                    start_4: self.start_4(),
                    start_5: self.start_5(),
                    start_6: self.start_6(),
                    start_7: self.start_7(),
                    stop_0: self.stop_0(),
                    stop_1: self.stop_1(),
                    stop_2: self.stop_2(),
                    stop_3: self.stop_3(),
                    stop_4: self.stop_4(),
                    stop_5: self.stop_5(),
                    stop_6: self.stop_6(),
                    stop_7: self.stop_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Use this to set, or read, the single address comparators that control the ViewInst start/stop logic. The start/stop logic is active for an instruction which causes a start and remains active up to and including an instruction which causes a stop, and then the start/stop logic becomes inactive. Might ignore writes when the trace unit is enabled or not idle. If implemented then this register must be programmed."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Trcvissctlr(pub u32);
        impl Trcvissctlr {
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub const fn start_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of starting trace."]
            #[inline(always)]
            pub fn set_start_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_0(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_1(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_2(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_3(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_4(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_5(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_6(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub const fn stop_7(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Selects which single address comparators are in use with ViewInst start/stop control, for the purpose of stopping trace"]
            #[inline(always)]
            pub fn set_stop_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Trcvissctlr {
            #[inline(always)]
            fn default() -> Trcvissctlr {
                Trcvissctlr(0)
            }
        }
        impl core::fmt::Debug for Trcvissctlr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Trcvissctlr")
                    .field("start_0", &self.start_0())
                    .field("start_1", &self.start_1())
                    .field("start_2", &self.start_2())
                    .field("start_3", &self.start_3())
                    .field("start_4", &self.start_4())
                    .field("start_5", &self.start_5())
                    .field("start_6", &self.start_6())
                    .field("start_7", &self.start_7())
                    .field("stop_0", &self.stop_0())
                    .field("stop_1", &self.stop_1())
                    .field("stop_2", &self.stop_2())
                    .field("stop_3", &self.stop_3())
                    .field("stop_4", &self.stop_4())
                    .field("stop_5", &self.stop_5())
                    .field("stop_6", &self.stop_6())
                    .field("stop_7", &self.stop_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Trcvissctlr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Trcvissctlr {
                    start_0: bool,
                    start_1: bool,
                    start_2: bool,
                    start_3: bool,
                    start_4: bool,
                    start_5: bool,
                    start_6: bool,
                    start_7: bool,
                    stop_0: bool,
                    stop_1: bool,
                    stop_2: bool,
                    stop_3: bool,
                    stop_4: bool,
                    stop_5: bool,
                    stop_6: bool,
                    stop_7: bool,
                }
                let proxy = Trcvissctlr {
                    start_0: self.start_0(),
                    start_1: self.start_1(),
                    start_2: self.start_2(),
                    start_3: self.start_3(),
                    start_4: self.start_4(),
                    start_5: self.start_5(),
                    start_6: self.start_6(),
                    start_7: self.start_7(),
                    stop_0: self.stop_0(),
                    stop_1: self.stop_1(),
                    stop_2: self.stop_2(),
                    stop_3: self.stop_3(),
                    stop_4: self.stop_4(),
                    stop_5: self.stop_5(),
                    stop_6: self.stop_6(),
                    stop_7: self.stop_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Archid(pub u16);
        impl Archid {
            #[doc = "Component is an ETMv4 component"]
            pub const ETMV42: Self = Self(0x4a13);
        }
        impl Archid {
            pub const fn from_bits(val: u16) -> Archid {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Archid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x4a13 => f.write_str("ETMV42"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Archid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x4a13 => defmt::write!(f, "ETMV42"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Archid {
            #[inline(always)]
            fn from(val: u16) -> Archid {
                Archid::from_bits(val)
            }
        }
        impl From<Archid> for u16 {
            #[inline(always)]
            fn from(val: Archid) -> u16 {
                Archid::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Architect(pub u16);
        impl Architect {
            #[doc = "This peripheral was architected by Arm."]
            pub const ARM: Self = Self(0x023b);
        }
        impl Architect {
            pub const fn from_bits(val: u16) -> Architect {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Architect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x023b => f.write_str("ARM"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Architect {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x023b => defmt::write!(f, "ARM"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Architect {
            #[inline(always)]
            fn from(val: u16) -> Architect {
                Architect::from_bits(val)
            }
        }
        impl From<Architect> for u16 {
            #[inline(always)]
            fn from(val: Architect) -> u16 {
                Architect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr0 {
            #[doc = "Claim tag 0 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr0 {
            #[inline(always)]
            fn from(val: u8) -> Clr0 {
                Clr0::from_bits(val)
            }
        }
        impl From<Clr0> for u8 {
            #[inline(always)]
            fn from(val: Clr0) -> u8 {
                Clr0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr1 {
            #[doc = "Claim tag 1 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr1 {
            #[inline(always)]
            fn from(val: u8) -> Clr1 {
                Clr1::from_bits(val)
            }
        }
        impl From<Clr1> for u8 {
            #[inline(always)]
            fn from(val: Clr1) -> u8 {
                Clr1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr2 {
            #[doc = "Claim tag 2 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr2 {
            #[inline(always)]
            fn from(val: u8) -> Clr2 {
                Clr2::from_bits(val)
            }
        }
        impl From<Clr2> for u8 {
            #[inline(always)]
            fn from(val: Clr2) -> u8 {
                Clr2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clr3 {
            #[doc = "Claim tag 3 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl Clr3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clr3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clr3 {
            #[inline(always)]
            fn from(val: u8) -> Clr3 {
                Clr3::from_bits(val)
            }
        }
        impl From<Clr3> for u8 {
            #[inline(always)]
            fn from(val: Clr3) -> u8 {
                Clr3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cond {
            #[doc = "Conditional instruction tracing is disabled."]
            DISABLED = 0x0,
            #[doc = "Conditional load instructions are traced."]
            LOAD_ONLY = 0x01,
            #[doc = "Conditional store instructions are traced."]
            STORE_ONLY = 0x02,
            #[doc = "Conditional load and store instructions are traced."]
            LOAD_AND_STORE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "All conditional instructions are traced."]
            ALL = 0x07,
        }
        impl Cond {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cond {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cond {
            #[inline(always)]
            fn from(val: u8) -> Cond {
                Cond::from_bits(val)
            }
        }
        impl From<Cond> for u8 {
            #[inline(always)]
            fn from(val: Cond) -> u8 {
                Cond::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EventSel(pub u8);
        impl EventSel {
            #[doc = "This event is not filtered."]
            pub const DISABLED: Self = Self(0x0);
            #[doc = "This event is filtered."]
            pub const ENABLED: Self = Self(0x01);
        }
        impl EventSel {
            pub const fn from_bits(val: u8) -> EventSel {
                Self(val & 0x1f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for EventSel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    0x01 => f.write_str("ENABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EventSel {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    0x01 => defmt::write!(f, "ENABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for EventSel {
            #[inline(always)]
            fn from(val: u8) -> EventSel {
                EventSel::from_bits(val)
            }
        }
        impl From<EventSel> for u8 {
            #[inline(always)]
            fn from(val: EventSel) -> u8 {
                EventSel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel0Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 0."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 0."]
            DISABLED = 0x01,
        }
        impl Exlevel0Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel0Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel0Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel0Ns {
                Exlevel0Ns::from_bits(val)
            }
        }
        impl From<Exlevel0Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel0Ns) -> u8 {
                Exlevel0Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel0S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 0."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 0."]
            DISABLED = 0x01,
        }
        impl Exlevel0S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel0S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel0S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel0S {
                Exlevel0S::from_bits(val)
            }
        }
        impl From<Exlevel0S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel0S) -> u8 {
                Exlevel0S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel1Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 1."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 1."]
            DISABLED = 0x01,
        }
        impl Exlevel1Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel1Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel1Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel1Ns {
                Exlevel1Ns::from_bits(val)
            }
        }
        impl From<Exlevel1Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel1Ns) -> u8 {
                Exlevel1Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel1S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 1."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 1."]
            DISABLED = 0x01,
        }
        impl Exlevel1S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel1S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel1S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel1S {
                Exlevel1S::from_bits(val)
            }
        }
        impl From<Exlevel1S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel1S) -> u8 {
                Exlevel1S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel2Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 2."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 2."]
            DISABLED = 0x01,
        }
        impl Exlevel2Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel2Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel2Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel2Ns {
                Exlevel2Ns::from_bits(val)
            }
        }
        impl From<Exlevel2Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel2Ns) -> u8 {
                Exlevel2Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel2S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 2."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 2."]
            DISABLED = 0x01,
        }
        impl Exlevel2S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel2S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel2S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel2S {
                Exlevel2S::from_bits(val)
            }
        }
        impl From<Exlevel2S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel2S) -> u8 {
                Exlevel2S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel3Ns {
            #[doc = "The trace unit generates instruction trace, in Non-secure state, for Exception level 3."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Non-secure state, for Exception level 3."]
            DISABLED = 0x01,
        }
        impl Exlevel3Ns {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel3Ns {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel3Ns {
            #[inline(always)]
            fn from(val: u8) -> Exlevel3Ns {
                Exlevel3Ns::from_bits(val)
            }
        }
        impl From<Exlevel3Ns> for u8 {
            #[inline(always)]
            fn from(val: Exlevel3Ns) -> u8 {
                Exlevel3Ns::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Exlevel3S {
            #[doc = "The trace unit generates instruction trace, in Secure state, for Exception level 3."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not generate instruction trace, in Secure state, for Exception level 3."]
            DISABLED = 0x01,
        }
        impl Exlevel3S {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Exlevel3S {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Exlevel3S {
            #[inline(always)]
            fn from(val: u8) -> Exlevel3S {
                Exlevel3S::from_bits(val)
            }
        }
        impl From<Exlevel3S> for u8 {
            #[inline(always)]
            fn from(val: Exlevel3S) -> u8 {
                Exlevel3S::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Level {
            #[doc = "Zero invasion. This setting has a greater risk of a FIFO overflow"]
            MIN = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Maximum invasion occurs but there is less risk of a FIFO overflow."]
            MAX = 0x0f,
        }
        impl Level {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Level {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Level {
            #[inline(always)]
            fn from(val: u8) -> Level {
                Level::from_bits(val)
            }
        }
        impl From<Level> for u8 {
            #[inline(always)]
            fn from(val: Level) -> u8 {
                Level::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Peripheral is a trace source."]
            TRACE_SOURCE = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Exclude mode. The address range comparators selected by the RANGE field indicate address ranges where the trace unit cannot generate Q elements. If no ranges are selected, Q elements are permitted across the entire memory map."]
            EXCLUDE = 0x0,
            #[doc = "Include mode. The address range comparators selected by the RANGE field indicate address ranges where the trace unit can generate Q elements. If all the implemented bits in RANGE are set to 0 then Q elements are disabled."]
            INCLUDE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pcrel {
            #[doc = "The trace unit does not affect the tracing of PC-relative transfers."]
            ENABLED = 0x0,
            #[doc = "The trace unit does not trace the address or value portions of PC-relative transfers."]
            DISABLED = 0x01,
        }
        impl Pcrel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pcrel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pcrel {
            #[inline(always)]
            fn from(val: u8) -> Pcrel {
                Pcrel::from_bits(val)
            }
        }
        impl From<Pcrel> for u8 {
            #[inline(always)]
            fn from(val: Pcrel) -> u8 {
                Pcrel::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Period(pub u8);
        impl Period {
            #[doc = "Trace synchronization requests are disabled. This setting does not disable other types of trace synchronization request."]
            pub const DISABLED: Self = Self(0x0);
        }
        impl Period {
            pub const fn from_bits(val: u8) -> Period {
                Self(val & 0x1f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Period {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Period {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Period {
            #[inline(always)]
            fn from(val: u8) -> Period {
                Period::from_bits(val)
            }
        }
        impl From<Period> for u8 {
            #[inline(always)]
            fn from(val: Period) -> u8 {
                Period::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "The register is not implemented."]
            ABSENT = 0x0,
            #[doc = "The register is implemented."]
            PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Qe {
            #[doc = "Q elements are disabled."]
            DISABLED = 0x0,
            #[doc = "Q elements with instruction counts are enabled. Q elements without instruction counts are disabled."]
            ONLY_WITHOUT_INST_COUNTS = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Q elements with and without instruction counts are enabled."]
            ENABLED = 0x03,
        }
        impl Qe {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Qe {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Qe {
            #[inline(always)]
            fn from(val: u8) -> Qe {
                Qe::from_bits(val)
            }
        }
        impl From<Qe> for u8 {
            #[inline(always)]
            fn from(val: Qe) -> u8 {
                Qe::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Revision {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Component is part of architecture 4.2"]
            V2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Revision {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Revision {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Revision {
            #[inline(always)]
            fn from(val: u8) -> Revision {
                Revision::from_bits(val)
            }
        }
        impl From<Revision> for u8 {
            #[inline(always)]
            fn from(val: Revision) -> u8 {
                Revision::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set0 {
            #[doc = "Claim tag 0 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 0 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set0 {
            #[inline(always)]
            fn from(val: u8) -> Set0 {
                Set0::from_bits(val)
            }
        }
        impl From<Set0> for u8 {
            #[inline(always)]
            fn from(val: Set0) -> u8 {
                Set0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set1 {
            #[doc = "Claim tag 1 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 1 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set1 {
            #[inline(always)]
            fn from(val: u8) -> Set1 {
                Set1::from_bits(val)
            }
        }
        impl From<Set1> for u8 {
            #[inline(always)]
            fn from(val: Set1) -> u8 {
                Set1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set2 {
            #[doc = "Claim tag 2 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 2 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set2 {
            #[inline(always)]
            fn from(val: u8) -> Set2 {
                Set2::from_bits(val)
            }
        }
        impl From<Set2> for u8 {
            #[inline(always)]
            fn from(val: Set2) -> u8 {
                Set2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Set3 {
            #[doc = "Claim tag 3 is not set."]
            NOT_SET = 0x0,
            #[doc = "Claim tag 3 is set."]
            R_SET_W_CLAIM = 0x01,
        }
        impl Set3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Set3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Set3 {
            #[inline(always)]
            fn from(val: u8) -> Set3 {
                Set3::from_bits(val)
            }
        }
        impl From<Set3> for u8 {
            #[inline(always)]
            fn from(val: Set3) -> u8 {
                Set3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sprel {
            #[doc = "The trace unit does not affect the tracing of SP-relative transfers."]
            ENABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "The trace unit does not trace the address portion of SP-relative transfers. If data value tracing is enabled then the trace unit generates a P1 data address element."]
            DATA_ONLY = 0x02,
            #[doc = "The trace unit does not trace the address or value portions of SP-relative transfers."]
            DISABLED = 0x03,
        }
        impl Sprel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sprel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sprel {
            #[inline(always)]
            fn from(val: u8) -> Sprel {
                Sprel::from_bits(val)
            }
        }
        impl From<Sprel> for u8 {
            #[inline(always)]
            fn from(val: Sprel) -> u8 {
                Sprel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ssstatus {
            #[doc = "The start/stop logic is in the stopped state."]
            STOPPED = 0x0,
            #[doc = "The start/stop logic is in the started state."]
            STARTED = 0x01,
        }
        impl Ssstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ssstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ssstatus {
            #[inline(always)]
            fn from(val: u8) -> Ssstatus {
                Ssstatus::from_bits(val)
            }
        }
        impl From<Ssstatus> for u8 {
            #[inline(always)]
            fn from(val: Ssstatus) -> u8 {
                Ssstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "The sequencer is in state 0."]
            STATE0 = 0x0,
            #[doc = "The sequencer is in state 1."]
            STATE1 = 0x01,
            #[doc = "The sequencer is in state 2."]
            STATE2 = 0x02,
            #[doc = "The sequencer is in state 3."]
            STATE3 = 0x03,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "Peripheral is a processor trace source."]
            PROCESSOR_TRACE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tbi {
            #[doc = "The trace unit assigns bits\\[63:56\\] to have the same value as bit\\[55\\] of the data address, that is, it sign-extends the value."]
            SIGN_EXTEND = 0x0,
            #[doc = "The trace unit assigns bits\\[63:56\\] to have the same value as bits\\[63:56\\] of the data address."]
            COPY = 0x01,
        }
        impl Tbi {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tbi {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tbi {
            #[inline(always)]
            fn from(val: u8) -> Tbi {
                Tbi::from_bits(val)
            }
        }
        impl From<Tbi> for u8 {
            #[inline(always)]
            fn from(val: Tbi) -> u8 {
                Tbi::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Vmidopt {
            #[doc = "VTTBR_EL2.VMID is used. If the trace unit supports a Virtual context identifier larger than the VTTBR_EL2.VMID, the upper unused bits are always zero. If the trace unit supports a Virtual context identifier larger than 8 bits and if the VTCR_EL2.VS bit forces use of an 8-bit Virtual context identifier, bits \\[15:8\\] of the trace unit Virtual context identifier are always zero."]
            VTTBR_EL2 = 0x0,
            #[doc = "CONTEXTIDR_EL2 is used."]
            CONTEXTIDR_EL2 = 0x01,
        }
        impl Vmidopt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Vmidopt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Vmidopt {
            #[inline(always)]
            fn from(val: u8) -> Vmidopt {
                Vmidopt::from_bits(val)
            }
        }
        impl From<Vmidopt> for u8 {
            #[inline(always)]
            fn from(val: Vmidopt) -> u8 {
                Vmidopt::to_bits(val)
            }
        }
    }
}
pub mod ficr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ficr {
        ptr: *mut u8,
    }
    unsafe impl Send for Ficr {}
    unsafe impl Sync for Ficr {}
    impl Ficr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Device info"]
        #[inline(always)]
        pub const fn info(self) -> Info {
            unsafe { Info::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Description collection: Common encryption root key, word n"]
        #[inline(always)]
        pub const fn er(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0380usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Common identity root key, word n"]
        #[inline(always)]
        pub const fn ir(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0390usize + n * 4usize) as _) }
        }
        #[doc = "Device address type"]
        #[inline(always)]
        pub const fn deviceaddrtype(
            self,
        ) -> crate::common::Reg<regs::Deviceaddrtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03a0usize) as _) }
        }
        #[doc = "Description collection: Device address n"]
        #[inline(always)]
        pub const fn deviceaddr(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x03a4usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trimcnf(self, n: usize) -> Trimcnf {
            assert!(n < 64usize);
            unsafe { Trimcnf::from_ptr(self.ptr.add(0x0400usize + n * 8usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nfc(self) -> Nfc {
            unsafe { Nfc::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "XOSC32M capacitor selection trim values"]
        #[inline(always)]
        pub const fn xosc32mtrim(self) -> crate::common::Reg<regs::Xosc32mtrim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0620usize) as _) }
        }
        #[doc = "XOSC32K capacitor selection trim values"]
        #[inline(always)]
        pub const fn xosc32ktrim(self) -> crate::common::Reg<regs::Xosc32ktrim, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0624usize) as _) }
        }
    }
    #[doc = "Device info"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Info {
        ptr: *mut u8,
    }
    unsafe impl Send for Info {}
    unsafe impl Sync for Info {}
    impl Info {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration identifier"]
        #[inline(always)]
        pub const fn configid(self) -> crate::common::Reg<regs::Configid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: Device identifier"]
        #[inline(always)]
        pub const fn deviceid(self, n: usize) -> crate::common::Reg<u32, crate::common::R> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: 128-bit Universally Unique IDentifier (UUID)."]
        #[inline(always)]
        pub const fn uuid(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
        #[doc = "Part code"]
        #[inline(always)]
        pub const fn part(self) -> crate::common::Reg<regs::Part, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Part Variant, Hardware version and Production configuration"]
        #[inline(always)]
        pub const fn variant(self) -> crate::common::Reg<regs::Variant, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Package option"]
        #[inline(always)]
        pub const fn package(self) -> crate::common::Reg<regs::Package, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "RAM size (KB)"]
        #[inline(always)]
        pub const fn ram(self) -> crate::common::Reg<regs::Ram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "RRAM size (KB)"]
        #[inline(always)]
        pub const fn rram(self) -> crate::common::Reg<regs::Rram, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfc {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfc {}
    unsafe impl Sync for Nfc {}
    impl Nfc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader0(self) -> crate::common::Reg<regs::Tagheader0, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader1(self) -> crate::common::Reg<regs::Tagheader1, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader2(self) -> crate::common::Reg<regs::Tagheader2, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[inline(always)]
        pub const fn tagheader3(self) -> crate::common::Reg<regs::Tagheader3, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trimcnf {
        ptr: *mut u8,
    }
    unsafe impl Send for Trimcnf {}
    unsafe impl Sync for Trimcnf {}
    impl Trimcnf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Address of the register which will be written"]
        #[inline(always)]
        pub const fn addr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Data to be written into the register"]
        #[inline(always)]
        pub const fn data(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration identifier"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Configid(pub u32);
        impl Configid {
            #[doc = "Identification number for the HW"]
            #[inline(always)]
            pub const fn hwid(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Identification number for the HW"]
            #[inline(always)]
            pub fn set_hwid(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Configid {
            #[inline(always)]
            fn default() -> Configid {
                Configid(0)
            }
        }
        impl core::fmt::Debug for Configid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Configid")
                    .field("hwid", &self.hwid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Configid {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Configid {
                    hwid: u16,
                }
                let proxy = Configid { hwid: self.hwid() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Device address type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Deviceaddrtype(pub u32);
        impl Deviceaddrtype {
            #[doc = "Device address type"]
            #[inline(always)]
            pub const fn deviceaddrtype(&self) -> super::vals::Deviceaddrtype {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Deviceaddrtype::from_bits(val as u8)
            }
            #[doc = "Device address type"]
            #[inline(always)]
            pub fn set_deviceaddrtype(&mut self, val: super::vals::Deviceaddrtype) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Deviceaddrtype {
            #[inline(always)]
            fn default() -> Deviceaddrtype {
                Deviceaddrtype(0)
            }
        }
        impl core::fmt::Debug for Deviceaddrtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Deviceaddrtype")
                    .field("deviceaddrtype", &self.deviceaddrtype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Deviceaddrtype {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Deviceaddrtype {
                    deviceaddrtype: super::vals::Deviceaddrtype,
                }
                let proxy = Deviceaddrtype {
                    deviceaddrtype: self.deviceaddrtype(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Package option"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Package(pub u32);
        impl Package {
            #[doc = "Package option"]
            #[inline(always)]
            pub const fn package(&self) -> super::vals::Package {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Package::from_bits(val as u32)
            }
            #[doc = "Package option"]
            #[inline(always)]
            pub fn set_package(&mut self, val: super::vals::Package) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Package {
            #[inline(always)]
            fn default() -> Package {
                Package(0)
            }
        }
        impl core::fmt::Debug for Package {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Package")
                    .field("package", &self.package())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Package {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Package {
                    package: super::vals::Package,
                }
                let proxy = Package {
                    package: self.package(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Part code"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Part(pub u32);
        impl Part {
            #[doc = "Part code"]
            #[inline(always)]
            pub const fn part(&self) -> super::vals::Part {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Part::from_bits(val as u32)
            }
            #[doc = "Part code"]
            #[inline(always)]
            pub fn set_part(&mut self, val: super::vals::Part) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Part {
            #[inline(always)]
            fn default() -> Part {
                Part(0)
            }
        }
        impl core::fmt::Debug for Part {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Part").field("part", &self.part()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Part {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Part {
                    part: super::vals::Part,
                }
                let proxy = Part { part: self.part() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RAM size (KB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ram(pub u32);
        impl Ram {
            #[doc = "RAM size (KB)"]
            #[inline(always)]
            pub const fn ram(&self) -> super::vals::Ram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Ram::from_bits(val as u32)
            }
            #[doc = "RAM size (KB)"]
            #[inline(always)]
            pub fn set_ram(&mut self, val: super::vals::Ram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Ram {
            #[inline(always)]
            fn default() -> Ram {
                Ram(0)
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ram").field("ram", &self.ram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ram {
                    ram: super::vals::Ram,
                }
                let proxy = Ram { ram: self.ram() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RRAM size (KB)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rram(pub u32);
        impl Rram {
            #[doc = "RRAM size (KB)"]
            #[inline(always)]
            pub const fn rram(&self) -> super::vals::Rram {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rram::from_bits(val as u32)
            }
            #[doc = "RRAM size (KB)"]
            #[inline(always)]
            pub fn set_rram(&mut self, val: super::vals::Rram) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rram {
            #[inline(always)]
            fn default() -> Rram {
                Rram(0)
            }
        }
        impl core::fmt::Debug for Rram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rram").field("rram", &self.rram()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rram {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rram {
                    rram: super::vals::Rram,
                }
                let proxy = Rram { rram: self.rram() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader0(pub u32);
        impl Tagheader0 {
            #[doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            #[inline(always)]
            pub const fn mfgid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default Manufacturer ID: Nordic Semiconductor ASA has ICM 0x5F"]
            #[inline(always)]
            pub fn set_mfgid(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 1"]
            #[inline(always)]
            pub const fn ud1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 1"]
            #[inline(always)]
            pub fn set_ud1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 2"]
            #[inline(always)]
            pub const fn ud2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 2"]
            #[inline(always)]
            pub fn set_ud2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 3"]
            #[inline(always)]
            pub const fn ud3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 3"]
            #[inline(always)]
            pub fn set_ud3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader0 {
            #[inline(always)]
            fn default() -> Tagheader0 {
                Tagheader0(0)
            }
        }
        impl core::fmt::Debug for Tagheader0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader0")
                    .field("mfgid", &self.mfgid())
                    .field("ud1", &self.ud1())
                    .field("ud2", &self.ud2())
                    .field("ud3", &self.ud3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tagheader0 {
                    mfgid: u8,
                    ud1: u8,
                    ud2: u8,
                    ud3: u8,
                }
                let proxy = Tagheader0 {
                    mfgid: self.mfgid(),
                    ud1: self.ud1(),
                    ud2: self.ud2(),
                    ud3: self.ud3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader1(pub u32);
        impl Tagheader1 {
            #[doc = "Unique identifier byte 4"]
            #[inline(always)]
            pub const fn ud4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 4"]
            #[inline(always)]
            pub fn set_ud4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 5"]
            #[inline(always)]
            pub const fn ud5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 5"]
            #[inline(always)]
            pub fn set_ud5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 6"]
            #[inline(always)]
            pub const fn ud6(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 6"]
            #[inline(always)]
            pub fn set_ud6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 7"]
            #[inline(always)]
            pub const fn ud7(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 7"]
            #[inline(always)]
            pub fn set_ud7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader1 {
            #[inline(always)]
            fn default() -> Tagheader1 {
                Tagheader1(0)
            }
        }
        impl core::fmt::Debug for Tagheader1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader1")
                    .field("ud4", &self.ud4())
                    .field("ud5", &self.ud5())
                    .field("ud6", &self.ud6())
                    .field("ud7", &self.ud7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tagheader1 {
                    ud4: u8,
                    ud5: u8,
                    ud6: u8,
                    ud7: u8,
                }
                let proxy = Tagheader1 {
                    ud4: self.ud4(),
                    ud5: self.ud5(),
                    ud6: self.ud6(),
                    ud7: self.ud7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader2(pub u32);
        impl Tagheader2 {
            #[doc = "Unique identifier byte 8"]
            #[inline(always)]
            pub const fn ud8(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 8"]
            #[inline(always)]
            pub fn set_ud8(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 9"]
            #[inline(always)]
            pub const fn ud9(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 9"]
            #[inline(always)]
            pub fn set_ud9(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 10"]
            #[inline(always)]
            pub const fn ud10(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 10"]
            #[inline(always)]
            pub fn set_ud10(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 11"]
            #[inline(always)]
            pub const fn ud11(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 11"]
            #[inline(always)]
            pub fn set_ud11(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader2 {
            #[inline(always)]
            fn default() -> Tagheader2 {
                Tagheader2(0)
            }
        }
        impl core::fmt::Debug for Tagheader2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader2")
                    .field("ud8", &self.ud8())
                    .field("ud9", &self.ud9())
                    .field("ud10", &self.ud10())
                    .field("ud11", &self.ud11())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader2 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tagheader2 {
                    ud8: u8,
                    ud9: u8,
                    ud10: u8,
                    ud11: u8,
                }
                let proxy = Tagheader2 {
                    ud8: self.ud8(),
                    ud9: self.ud9(),
                    ud10: self.ud10(),
                    ud11: self.ud11(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Default header for NFC Tag. Software can read these values to populate NFCID1_3RD_LAST, NFCID1_2ND_LAST and NFCID1_LAST."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tagheader3(pub u32);
        impl Tagheader3 {
            #[doc = "Unique identifier byte 12"]
            #[inline(always)]
            pub const fn ud12(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 12"]
            #[inline(always)]
            pub fn set_ud12(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Unique identifier byte 13"]
            #[inline(always)]
            pub const fn ud13(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 13"]
            #[inline(always)]
            pub fn set_ud13(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Unique identifier byte 14"]
            #[inline(always)]
            pub const fn ud14(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 14"]
            #[inline(always)]
            pub fn set_ud14(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Unique identifier byte 15"]
            #[inline(always)]
            pub const fn ud15(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Unique identifier byte 15"]
            #[inline(always)]
            pub fn set_ud15(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Tagheader3 {
            #[inline(always)]
            fn default() -> Tagheader3 {
                Tagheader3(0)
            }
        }
        impl core::fmt::Debug for Tagheader3 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tagheader3")
                    .field("ud12", &self.ud12())
                    .field("ud13", &self.ud13())
                    .field("ud14", &self.ud14())
                    .field("ud15", &self.ud15())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tagheader3 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tagheader3 {
                    ud12: u8,
                    ud13: u8,
                    ud14: u8,
                    ud15: u8,
                }
                let proxy = Tagheader3 {
                    ud12: self.ud12(),
                    ud13: self.ud13(),
                    ud14: self.ud14(),
                    ud15: self.ud15(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Part Variant, Hardware version and Production configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Variant(pub u32);
        impl Variant {
            #[doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"]
            #[inline(always)]
            pub const fn variant(&self) -> super::vals::Variant {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Variant::from_bits(val as u32)
            }
            #[doc = "Part Variant, Hardware version and Production configuration, encoded as ASCII"]
            #[inline(always)]
            pub fn set_variant(&mut self, val: super::vals::Variant) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Variant {
            #[inline(always)]
            fn default() -> Variant {
                Variant(0)
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Variant")
                    .field("variant", &self.variant())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Variant {
                    variant: super::vals::Variant,
                }
                let proxy = Variant {
                    variant: self.variant(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "XOSC32K capacitor selection trim values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32ktrim(pub u32);
        impl Xosc32ktrim {
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub const fn slope(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub fn set_slope(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub const fn offset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub fn set_offset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Xosc32ktrim {
            #[inline(always)]
            fn default() -> Xosc32ktrim {
                Xosc32ktrim(0)
            }
        }
        impl core::fmt::Debug for Xosc32ktrim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32ktrim")
                    .field("slope", &self.slope())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32ktrim {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Xosc32ktrim {
                    slope: u16,
                    offset: u16,
                }
                let proxy = Xosc32ktrim {
                    slope: self.slope(),
                    offset: self.offset(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "XOSC32M capacitor selection trim values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32mtrim(pub u32);
        impl Xosc32mtrim {
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub const fn slope(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Slope trim factor on twos complement form"]
            #[inline(always)]
            pub fn set_slope(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub const fn offset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Offset trim factor on integer form"]
            #[inline(always)]
            pub fn set_offset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Xosc32mtrim {
            #[inline(always)]
            fn default() -> Xosc32mtrim {
                Xosc32mtrim(0)
            }
        }
        impl core::fmt::Debug for Xosc32mtrim {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32mtrim")
                    .field("slope", &self.slope())
                    .field("offset", &self.offset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32mtrim {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Xosc32mtrim {
                    slope: u16,
                    offset: u16,
                }
                let proxy = Xosc32mtrim {
                    slope: self.slope(),
                    offset: self.offset(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Deviceaddrtype {
            #[doc = "Public address"]
            PUBLIC = 0x0,
            #[doc = "Random address"]
            RANDOM = 0x01,
        }
        impl Deviceaddrtype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Deviceaddrtype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Deviceaddrtype {
            #[inline(always)]
            fn from(val: u8) -> Deviceaddrtype {
                Deviceaddrtype::from_bits(val)
            }
        }
        impl From<Deviceaddrtype> for u8 {
            #[inline(always)]
            fn from(val: Deviceaddrtype) -> u8 {
                Deviceaddrtype::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Package(pub u32);
        impl Package {
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Package {
            pub const fn from_bits(val: u32) -> Package {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Package {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Package {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Package {
            #[inline(always)]
            fn from(val: u32) -> Package {
                Package::from_bits(val)
            }
        }
        impl From<Package> for u32 {
            #[inline(always)]
            fn from(val: Package) -> u32 {
                Package::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Part(pub u32);
        impl Part {
            #[doc = "nRF54L15"]
            pub const N54L15: Self = Self(0x0005_4b15);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Part {
            pub const fn from_bits(val: u32) -> Part {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Part {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0005_4b15 => f.write_str("N54L15"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Part {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0005_4b15 => defmt::write!(f, "N54L15"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Part {
            #[inline(always)]
            fn from(val: u32) -> Part {
                Part::from_bits(val)
            }
        }
        impl From<Part> for u32 {
            #[inline(always)]
            fn from(val: Part) -> u32 {
                Part::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Ram(pub u32);
        impl Ram {
            #[doc = "256 kByte RAM"]
            pub const K256: Self = Self(0x0100);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Ram {
            pub const fn from_bits(val: u32) -> Ram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Ram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0100 => f.write_str("K256"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0100 => defmt::write!(f, "K256"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Ram {
            #[inline(always)]
            fn from(val: u32) -> Ram {
                Ram::from_bits(val)
            }
        }
        impl From<Ram> for u32 {
            #[inline(always)]
            fn from(val: Ram) -> u32 {
                Ram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rram(pub u32);
        impl Rram {
            #[doc = "1524 KByte RRAM"]
            pub const K1524: Self = Self(0x05f4);
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Rram {
            pub const fn from_bits(val: u32) -> Rram {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rram {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x05f4 => f.write_str("K1524"),
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rram {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x05f4 => defmt::write!(f, "K1524"),
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rram {
            #[inline(always)]
            fn from(val: u32) -> Rram {
                Rram::from_bits(val)
            }
        }
        impl From<Rram> for u32 {
            #[inline(always)]
            fn from(val: Rram) -> u32 {
                Rram::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Variant(pub u32);
        impl Variant {
            #[doc = "Unspecified"]
            pub const UNSPECIFIED: Self = Self(0xffff_ffff);
        }
        impl Variant {
            pub const fn from_bits(val: u32) -> Variant {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Variant {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNSPECIFIED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Variant {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNSPECIFIED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Variant {
            #[inline(always)]
            fn from(val: u32) -> Variant {
                Variant::from_bits(val)
            }
        }
        impl From<Variant> for u32 {
            #[inline(always)]
            fn from(val: Variant) -> u32 {
                Variant::to_bits(val)
            }
        }
    }
}
pub mod glitchdet {
    #[doc = "Voltage glitch detectors"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchdet {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchdet {}
    unsafe impl Sync for Glitchdet {}
    impl Glitchdet {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration for glitch detector"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05a0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration for glitch detector"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable glitch detector"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable glitch detector"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Glitch detector mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Glitch detector mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("enable", &self.enable())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    enable: bool,
                    mode: super::vals::Mode,
                }
                let proxy = Config {
                    enable: self.enable(),
                    mode: self.mode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "High pass filter mode"]
            HIGH_PASS_FILTER = 0x0,
            #[doc = "Cap divider mode"]
            CAP_DIV = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod gpio {
    #[doc = "GPIO Port 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Write GPIO port"]
        #[inline(always)]
        pub const fn out(self) -> crate::common::Reg<regs::Out, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outset(self) -> crate::common::Reg<regs::Outset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[inline(always)]
        pub const fn outclr(self) -> crate::common::Reg<regs::Outclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Read GPIO port"]
        #[inline(always)]
        pub const fn in_(self) -> crate::common::Reg<regs::In, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Direction of GPIO pins"]
        #[inline(always)]
        pub const fn dir(self) -> crate::common::Reg<regs::Dir, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "DIR set register"]
        #[inline(always)]
        pub const fn dirset(self) -> crate::common::Reg<regs::Dirset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "DIR clear register"]
        #[inline(always)]
        pub const fn dirclr(self) -> crate::common::Reg<regs::Dirclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[inline(always)]
        pub const fn latch(self) -> crate::common::Reg<regs::Latch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
        #[inline(always)]
        pub const fn detectmode(self) -> crate::common::Reg<regs::Detectmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Description collection: Pin n configuration of GPIO pin"]
        #[inline(always)]
        pub const fn pin_cnf(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PinCnf, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Detectmode(pub u32);
        impl Detectmode {
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[inline(always)]
            pub const fn detectmode(&self) -> super::vals::Detectmode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detectmode::from_bits(val as u8)
            }
            #[doc = "Select between default DETECT signal behavior and LDETECT mode"]
            #[inline(always)]
            pub fn set_detectmode(&mut self, val: super::vals::Detectmode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Detectmode {
            #[inline(always)]
            fn default() -> Detectmode {
                Detectmode(0)
            }
        }
        impl core::fmt::Debug for Detectmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Detectmode")
                    .field("detectmode", &self.detectmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Detectmode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Detectmode {
                    detectmode: super::vals::Detectmode,
                }
                let proxy = Detectmode {
                    detectmode: self.detectmode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Direction of GPIO pins"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dir(pub u32);
        impl Dir {
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> super::vals::Dir {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: super::vals::Dir) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val.to_bits() as u32) & 0x01) << offs);
            }
        }
        impl Default for Dir {
            #[inline(always)]
            fn default() -> Dir {
                Dir(0)
            }
        }
        impl core::fmt::Debug for Dir {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dir")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dir {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dir {
                    pin: [super::vals::Dir; 32usize],
                }
                let proxy = Dir {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "DIR clear register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirclr(pub u32);
        impl Dirclr {
            #[doc = "Set as input pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as input pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirclr {
            #[inline(always)]
            fn default() -> Dirclr {
                Dirclr(0)
            }
        }
        impl core::fmt::Debug for Dirclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirclr")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirclr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dirclr {
                    pin: [bool; 32usize],
                }
                let proxy = Dirclr {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "DIR set register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dirset(pub u32);
        impl Dirset {
            #[doc = "Set as output pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Set as output pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Dirset {
            #[inline(always)]
            fn default() -> Dirset {
                Dirset(0)
            }
        }
        impl core::fmt::Debug for Dirset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dirset")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dirset {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dirset {
                    pin: [bool; 32usize],
                }
                let proxy = Dirset {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Read GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct In(pub u32);
        impl In {
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for In {
            #[inline(always)]
            fn default() -> In {
                In(0)
            }
        }
        impl core::fmt::Debug for In {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("In")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for In {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct In {
                    pin: [bool; 32usize],
                }
                let proxy = In {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Latch register indicating what GPIO pins that have met the criteria set in the PIN_CNF\\[n\\].SENSE registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Latch(pub u32);
        impl Latch {
            #[doc = "Status on whether PIN0 has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Status on whether PIN0 has met criteria set in PIN_CNF\\[0\\].SENSE register. Write '1' to clear."]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Latch {
            #[inline(always)]
            fn default() -> Latch {
                Latch(0)
            }
        }
        impl core::fmt::Debug for Latch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Latch")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Latch {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Latch {
                    pin: [bool; 32usize],
                }
                let proxy = Latch {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Write GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Out(pub u32);
        impl Out {
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Out {
            #[inline(always)]
            fn default() -> Out {
                Out(0)
            }
        }
        impl core::fmt::Debug for Out {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Out")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Out {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Out {
                    pin: [bool; 32usize],
                }
                let proxy = Out {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Clear individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outclr(pub u32);
        impl Outclr {
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outclr {
            #[inline(always)]
            fn default() -> Outclr {
                Outclr(0)
            }
        }
        impl core::fmt::Debug for Outclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outclr")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outclr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Outclr {
                    pin: [bool; 32usize],
                }
                let proxy = Outclr {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Set individual bits in GPIO port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Outset(pub u32);
        impl Outset {
            #[doc = "Pin 0"]
            #[inline(always)]
            pub const fn pin(&self, n: usize) -> bool {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Pin 0"]
            #[inline(always)]
            pub fn set_pin(&mut self, n: usize, val: bool) {
                assert!(n < 32usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Outset {
            #[inline(always)]
            fn default() -> Outset {
                Outset(0)
            }
        }
        impl core::fmt::Debug for Outset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Outset")
                    .field(
                        "pin",
                        &[
                            self.pin(0usize),
                            self.pin(1usize),
                            self.pin(2usize),
                            self.pin(3usize),
                            self.pin(4usize),
                            self.pin(5usize),
                            self.pin(6usize),
                            self.pin(7usize),
                            self.pin(8usize),
                            self.pin(9usize),
                            self.pin(10usize),
                            self.pin(11usize),
                            self.pin(12usize),
                            self.pin(13usize),
                            self.pin(14usize),
                            self.pin(15usize),
                            self.pin(16usize),
                            self.pin(17usize),
                            self.pin(18usize),
                            self.pin(19usize),
                            self.pin(20usize),
                            self.pin(21usize),
                            self.pin(22usize),
                            self.pin(23usize),
                            self.pin(24usize),
                            self.pin(25usize),
                            self.pin(26usize),
                            self.pin(27usize),
                            self.pin(28usize),
                            self.pin(29usize),
                            self.pin(30usize),
                            self.pin(31usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Outset {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Outset {
                    pin: [bool; 32usize],
                }
                let proxy = Outset {
                    pin: [
                        self.pin(0usize),
                        self.pin(1usize),
                        self.pin(2usize),
                        self.pin(3usize),
                        self.pin(4usize),
                        self.pin(5usize),
                        self.pin(6usize),
                        self.pin(7usize),
                        self.pin(8usize),
                        self.pin(9usize),
                        self.pin(10usize),
                        self.pin(11usize),
                        self.pin(12usize),
                        self.pin(13usize),
                        self.pin(14usize),
                        self.pin(15usize),
                        self.pin(16usize),
                        self.pin(17usize),
                        self.pin(18usize),
                        self.pin(19usize),
                        self.pin(20usize),
                        self.pin(21usize),
                        self.pin(22usize),
                        self.pin(23usize),
                        self.pin(24usize),
                        self.pin(25usize),
                        self.pin(26usize),
                        self.pin(27usize),
                        self.pin(28usize),
                        self.pin(29usize),
                        self.pin(30usize),
                        self.pin(31usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Pin n configuration of GPIO pin"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PinCnf(pub u32);
        impl PinCnf {
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[inline(always)]
            pub const fn dir(&self) -> super::vals::Dir {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Dir::from_bits(val as u8)
            }
            #[doc = "Pin direction. Same physical register as DIR register"]
            #[inline(always)]
            pub fn set_dir(&mut self, val: super::vals::Dir) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Connect or disconnect input buffer"]
            #[inline(always)]
            pub const fn input(&self) -> super::vals::Input {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Input::from_bits(val as u8)
            }
            #[doc = "Connect or disconnect input buffer"]
            #[inline(always)]
            pub fn set_input(&mut self, val: super::vals::Input) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Pull configuration"]
            #[inline(always)]
            pub const fn pull(&self) -> super::vals::Pull {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Pull::from_bits(val as u8)
            }
            #[doc = "Pull configuration"]
            #[inline(always)]
            pub fn set_pull(&mut self, val: super::vals::Pull) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Drive configuration for '0'"]
            #[inline(always)]
            pub const fn drive0(&self) -> super::vals::Drive {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration for '0'"]
            #[inline(always)]
            pub fn set_drive0(&mut self, val: super::vals::Drive) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
            #[doc = "Drive configuration for '1'"]
            #[inline(always)]
            pub const fn drive1(&self) -> super::vals::Drive {
                let val = (self.0 >> 10usize) & 0x03;
                super::vals::Drive::from_bits(val as u8)
            }
            #[doc = "Drive configuration for '1'"]
            #[inline(always)]
            pub fn set_drive1(&mut self, val: super::vals::Drive) {
                self.0 =
                    (self.0 & !(0x03 << 10usize)) | (((val.to_bits() as u32) & 0x03) << 10usize);
            }
            #[doc = "Pin sensing mechanism"]
            #[inline(always)]
            pub const fn sense(&self) -> super::vals::Sense {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Sense::from_bits(val as u8)
            }
            #[doc = "Pin sensing mechanism"]
            #[inline(always)]
            pub fn set_sense(&mut self, val: super::vals::Sense) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "Select which module has direct control over this pin"]
            #[inline(always)]
            pub const fn ctrlsel(&self) -> super::vals::Ctrlsel {
                let val = (self.0 >> 28usize) & 0x07;
                super::vals::Ctrlsel::from_bits(val as u8)
            }
            #[doc = "Select which module has direct control over this pin"]
            #[inline(always)]
            pub fn set_ctrlsel(&mut self, val: super::vals::Ctrlsel) {
                self.0 =
                    (self.0 & !(0x07 << 28usize)) | (((val.to_bits() as u32) & 0x07) << 28usize);
            }
        }
        impl Default for PinCnf {
            #[inline(always)]
            fn default() -> PinCnf {
                PinCnf(0)
            }
        }
        impl core::fmt::Debug for PinCnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PinCnf")
                    .field("dir", &self.dir())
                    .field("input", &self.input())
                    .field("pull", &self.pull())
                    .field("drive0", &self.drive0())
                    .field("drive1", &self.drive1())
                    .field("sense", &self.sense())
                    .field("ctrlsel", &self.ctrlsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PinCnf {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PinCnf {
                    dir: super::vals::Dir,
                    input: super::vals::Input,
                    pull: super::vals::Pull,
                    drive0: super::vals::Drive,
                    drive1: super::vals::Drive,
                    sense: super::vals::Sense,
                    ctrlsel: super::vals::Ctrlsel,
                }
                let proxy = PinCnf {
                    dir: self.dir(),
                    input: self.input(),
                    pull: self.pull(),
                    drive0: self.drive0(),
                    drive1: self.drive1(),
                    sense: self.sense(),
                    ctrlsel: self.ctrlsel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctrlsel {
            #[doc = "GPIO or peripherals with PSEL registers"]
            GPIO = 0x0,
            #[doc = "VPR processor"]
            VPR = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "GRTC peripheral"]
            GRTC = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ctrlsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctrlsel {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctrlsel {
            #[inline(always)]
            fn from(val: u8) -> Ctrlsel {
                Ctrlsel::from_bits(val)
            }
        }
        impl From<Ctrlsel> for u8 {
            #[inline(always)]
            fn from(val: Ctrlsel) -> u8 {
                Ctrlsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detectmode {
            #[doc = "DETECT directly connected to PIN DETECT signals"]
            DEFAULT = 0x0,
            #[doc = "Use the latched LDETECT behavior"]
            LDETECT = 0x01,
        }
        impl Detectmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detectmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detectmode {
            #[inline(always)]
            fn from(val: u8) -> Detectmode {
                Detectmode::from_bits(val)
            }
        }
        impl From<Detectmode> for u8 {
            #[inline(always)]
            fn from(val: Detectmode) -> u8 {
                Detectmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dir {
            #[doc = "Configure pin as an input pin"]
            INPUT = 0x0,
            #[doc = "Configure pin as an output pin"]
            OUTPUT = 0x01,
        }
        impl Dir {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dir {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dir {
            #[inline(always)]
            fn from(val: u8) -> Dir {
                Dir::from_bits(val)
            }
        }
        impl From<Dir> for u8 {
            #[inline(always)]
            fn from(val: Dir) -> u8 {
                Dir::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Drive {
            #[doc = "Standard '0'"]
            S = 0x0,
            #[doc = "High drive '0'"]
            H = 0x01,
            #[doc = "Disconnect '0'(normally used for wired-or connections)"]
            D = 0x02,
            #[doc = "Extra high drive '0'"]
            E = 0x03,
        }
        impl Drive {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Drive {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Drive {
            #[inline(always)]
            fn from(val: u8) -> Drive {
                Drive::from_bits(val)
            }
        }
        impl From<Drive> for u8 {
            #[inline(always)]
            fn from(val: Drive) -> u8 {
                Drive::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Input {
            #[doc = "Connect input buffer"]
            CONNECT = 0x0,
            #[doc = "Disconnect input buffer"]
            DISCONNECT = 0x01,
        }
        impl Input {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Input {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Input {
            #[inline(always)]
            fn from(val: u8) -> Input {
                Input::from_bits(val)
            }
        }
        impl From<Input> for u8 {
            #[inline(always)]
            fn from(val: Input) -> u8 {
                Input::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pull {
            #[doc = "No pull"]
            DISABLED = 0x0,
            #[doc = "Pull down on pin"]
            PULLDOWN = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Pull up on pin"]
            PULLUP = 0x03,
        }
        impl Pull {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pull {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pull {
            #[inline(always)]
            fn from(val: u8) -> Pull {
                Pull::from_bits(val)
            }
        }
        impl From<Pull> for u8 {
            #[inline(always)]
            fn from(val: Pull) -> u8 {
                Pull::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sense {
            #[doc = "Disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Sense for high level"]
            HIGH = 0x02,
            #[doc = "Sense for low level"]
            LOW = 0x03,
        }
        impl Sense {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sense {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sense {
            #[inline(always)]
            fn from(val: u8) -> Sense {
                Sense::from_bits(val)
            }
        }
        impl From<Sense> for u8 {
            #[inline(always)]
            fn from(val: Sense) -> u8 {
                Sense::to_bits(val)
            }
        }
    }
}
pub mod gpiote {
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsPort {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsPort {}
    unsafe impl Sync for EventsPort {}
    impl EventsPort {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Non-secure port event from owner n"]
        #[inline(always)]
        pub const fn nonsecure(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Secure port event from owner n"]
        #[inline(always)]
        pub const fn secure(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "GPIO Tasks and Events 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is configured in CONFIG\\[n\\].POLARITY."]
        #[inline(always)]
        pub const fn tasks_out(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it high."]
        #[inline(always)]
        pub const fn tasks_set(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Task for writing to pin specified in CONFIG\\[n\\].PSEL. Action on pin is to set it low."]
        #[inline(always)]
        pub const fn tasks_clr(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task OUT\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task SET\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_set(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CLR\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_clr(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Event from pin specified in CONFIG\\[n\\].PSEL"]
        #[inline(always)]
        pub const fn events_in(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_port(self, n: usize) -> EventsPort {
            assert!(n < 1usize);
            unsafe { EventsPort::from_ptr(self.ptr.add(0x0140usize + n * 8usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event IN\\[n\\]"]
        #[inline(always)]
        pub const fn publish_in(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_port(self, n: usize) -> PublishPort {
            assert!(n < 1usize);
            unsafe { PublishPort::from_ptr(self.ptr.add(0x01c0usize + n * 8usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize + n * 16usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize + n * 16usize) as _) }
        }
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[inline(always)]
        pub const fn config(self, n: usize) -> crate::common::Reg<regs::Config, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishPort {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishPort {}
    unsafe impl Sync for PublishPort {}
    impl PublishPort {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event PORT\\[n\\].NONSECURE"]
        #[inline(always)]
        pub const fn nonsecure(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event PORT\\[n\\].SECURE"]
        #[inline(always)]
        pub const fn secure(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Configuration for OUT\\[n\\], SET\\[n\\], and CLR\\[n\\] tasks and IN\\[n\\] event"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[inline(always)]
            pub const fn psel(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO number associated with SET\\[n\\], CLR\\[n\\], and OUT\\[n\\] tasks and IN\\[n\\] event"]
            #[inline(always)]
            pub fn set_psel(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 4usize)) | (((val as u32) & 0x1f) << 4usize);
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 9usize) & 0x0f;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val as u32) & 0x0f) << 9usize);
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[inline(always)]
            pub const fn polarity(&self) -> super::vals::Polarity {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Polarity::from_bits(val as u8)
            }
            #[doc = "When In task mode: Operation to be performed on output when OUT\\[n\\] task is triggered. When In event mode: Operation on input that shall trigger IN\\[n\\] event."]
            #[inline(always)]
            pub fn set_polarity(&mut self, val: super::vals::Polarity) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[inline(always)]
            pub const fn outinit(&self) -> super::vals::Outinit {
                let val = (self.0 >> 20usize) & 0x01;
                super::vals::Outinit::from_bits(val as u8)
            }
            #[doc = "When in task mode: Initial value of the output when the GPIOTE channel is configured. When in event mode: No effect."]
            #[inline(always)]
            pub fn set_outinit(&mut self, val: super::vals::Outinit) {
                self.0 =
                    (self.0 & !(0x01 << 20usize)) | (((val.to_bits() as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("mode", &self.mode())
                    .field("psel", &self.psel())
                    .field("port", &self.port())
                    .field("polarity", &self.polarity())
                    .field("outinit", &self.outinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    mode: super::vals::Mode,
                    psel: u8,
                    port: u8,
                    polarity: super::vals::Polarity,
                    outinit: super::vals::Outinit,
                }
                let proxy = Config {
                    mode: self.mode(),
                    psel: self.psel(),
                    port: self.port(),
                    polarity: self.polarity(),
                    outinit: self.outinit(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[inline(always)]
            pub const fn in_(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event IN\\[0\\]"]
            #[inline(always)]
            pub fn set_in_(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event PORT0NONSECURE"]
            #[inline(always)]
            pub const fn port0nonsecure(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT0NONSECURE"]
            #[inline(always)]
            pub fn set_port0nonsecure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event PORT0SECURE"]
            #[inline(always)]
            pub const fn port0secure(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PORT0SECURE"]
            #[inline(always)]
            pub fn set_port0secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field(
                        "in_",
                        &[
                            self.in_(0usize),
                            self.in_(1usize),
                            self.in_(2usize),
                            self.in_(3usize),
                            self.in_(4usize),
                            self.in_(5usize),
                            self.in_(6usize),
                            self.in_(7usize),
                        ],
                    )
                    .field("port0nonsecure", &self.port0nonsecure())
                    .field("port0secure", &self.port0secure())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    in_: [bool; 8usize],
                    port0nonsecure: bool,
                    port0secure: bool,
                }
                let proxy = Int {
                    in_: [
                        self.in_(0usize),
                        self.in_(1usize),
                        self.in_(2usize),
                        self.in_(3usize),
                        self.in_(4usize),
                        self.in_(5usize),
                        self.in_(6usize),
                        self.in_(7usize),
                    ],
                    port0nonsecure: self.port0nonsecure(),
                    port0secure: self.port0secure(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Disabled. Pin specified by PSEL will not be acquired by the GPIOTE module."]
            DISABLED = 0x0,
            #[doc = "Event mode"]
            EVENT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Task mode"]
            TASK = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Outinit {
            #[doc = "Task mode: Initial value of pin before task triggering is low"]
            LOW = 0x0,
            #[doc = "Task mode: Initial value of pin before task triggering is high"]
            HIGH = 0x01,
        }
        impl Outinit {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Outinit {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Outinit {
            #[inline(always)]
            fn from(val: u8) -> Outinit {
                Outinit::from_bits(val)
            }
        }
        impl From<Outinit> for u8 {
            #[inline(always)]
            fn from(val: Outinit) -> u8 {
                Outinit::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Polarity {
            #[doc = "Task mode: No effect on pin from OUT\\[n\\] task. Event mode: no IN\\[n\\] event generated on pin activity."]
            NONE = 0x0,
            #[doc = "Task mode: Set pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when rising edge on pin."]
            LO_TO_HI = 0x01,
            #[doc = "Task mode: Clear pin from OUT\\[n\\] task. Event mode: Generate IN\\[n\\] event when falling edge on pin."]
            HI_TO_LO = 0x02,
            #[doc = "Task mode: Toggle pin from OUT\\[n\\]. Event mode: Generate IN\\[n\\] when any change on pin."]
            TOGGLE = 0x03,
        }
        impl Polarity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Polarity {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Polarity {
            #[inline(always)]
            fn from(val: u8) -> Polarity {
                Polarity::from_bits(val)
            }
        }
        impl From<Polarity> for u8 {
            #[inline(always)]
            fn from(val: Polarity) -> u8 {
                Polarity::to_bits(val)
            }
        }
    }
}
pub mod grtc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cc {
        ptr: *mut u8,
    }
    unsafe impl Send for Cc {}
    unsafe impl Sync for Cc {}
    impl Cc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: The lower 32-bits of Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn ccl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: The higher 32-bits of Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn cch(self) -> crate::common::Reg<regs::Cch, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Count to add to CC\\[n\\] when this register is written."]
        #[inline(always)]
        pub const fn ccadd(self) -> crate::common::Reg<regs::Ccadd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Configure Capture/Compare register CC\\[n\\]"]
        #[inline(always)]
        pub const fn ccen(self) -> crate::common::Reg<regs::Ccen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Global Real-time counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Grtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Grtc {}
    unsafe impl Sync for Grtc {}
    impl Grtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Capture the counter value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Start the counter"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Stop the counter"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize) as _) }
        }
        #[doc = "Clear the counter"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x68usize) as _) }
        }
        #[doc = "Start the PWM"]
        #[inline(always)]
        pub const fn tasks_pwmstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x6cusize) as _) }
        }
        #[doc = "Stop the PWM"]
        #[inline(always)]
        pub const fn tasks_pwmstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x70usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "The GRTC low frequency timer is synchronized with the SYSCOUNTER"]
        #[inline(always)]
        pub const fn events_rtcomparesync(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0164usize) as _) }
        }
        #[doc = "Event on end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x016cusize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 12usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize + n * 16usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize + n * 16usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize + n * 16usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::R> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize + n * 16usize) as _) }
        }
        #[doc = "Enable or disable event routing"]
        #[inline(always)]
        pub const fn evten(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable event routing"]
        #[inline(always)]
        pub const fn evtenset(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Disable event routing"]
        #[inline(always)]
        pub const fn evtenclr(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0408usize) as _) }
        }
        #[doc = "Counter mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> Cc {
            assert!(n < 12usize);
            unsafe { Cc::from_ptr(self.ptr.add(0x0520usize + n * 16usize) as _) }
        }
        #[doc = "Timeout after all CPUs gone into sleep state to stop the SYSCOUNTER"]
        #[inline(always)]
        pub const fn timeout(self) -> crate::common::Reg<regs::Timeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06a4usize) as _) }
        }
        #[doc = "Count to add to CC\\[0\\] when the event EVENTS_COMPARE\\[0\\] triggers."]
        #[inline(always)]
        pub const fn interval(self) -> crate::common::Reg<regs::Interval, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06a8usize) as _) }
        }
        #[doc = "GRTC wake up time."]
        #[inline(always)]
        pub const fn waketime(self) -> crate::common::Reg<regs::Waketime, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06acusize) as _) }
        }
        #[doc = "PWM configuration."]
        #[inline(always)]
        pub const fn pwmconfig(self) -> crate::common::Reg<regs::Pwmconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0710usize) as _) }
        }
        #[doc = "Configuration of clock output"]
        #[inline(always)]
        pub const fn clkout(self) -> crate::common::Reg<regs::Clkout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0714usize) as _) }
        }
        #[doc = "Clock Configuration"]
        #[inline(always)]
        pub const fn clkcfg(self) -> crate::common::Reg<regs::Clkcfg, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0718usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn syscounter(self, n: usize) -> Syscounter {
            assert!(n < 4usize);
            unsafe { Syscounter::from_ptr(self.ptr.add(0x0720usize + n * 16usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Syscounter {
        ptr: *mut u8,
    }
    unsafe impl Send for Syscounter {}
    unsafe impl Sync for Syscounter {}
    impl Syscounter {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: The lower 32-bits of the SYSCOUNTER for index \\[n\\]"]
        #[inline(always)]
        pub const fn syscounterl(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: The higher 20-bits of the SYSCOUNTER for index \\[n\\]"]
        #[inline(always)]
        pub const fn syscounterh(self) -> crate::common::Reg<regs::Syscounterh, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Request to keep the SYSCOUNTER in the active state and prevent going to sleep for index \\[n\\]"]
        #[inline(always)]
        pub const fn active(self) -> crate::common::Reg<regs::Active, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Request to keep the SYSCOUNTER in the active state and prevent going to sleep for index \\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Active(pub u32);
        impl Active {
            #[doc = "Keep SYSCOUNTER in active state"]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep SYSCOUNTER in active state"]
            #[inline(always)]
            pub fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Active {
            #[inline(always)]
            fn default() -> Active {
                Active(0)
            }
        }
        impl core::fmt::Debug for Active {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Active")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Active {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Active {
                    active: bool,
                }
                let proxy = Active {
                    active: self.active(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Count to add to CC\\[n\\] when this register is written."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccadd(pub u32);
        impl Ccadd {
            #[doc = "Count to add to CC\\[n\\]"]
            #[inline(always)]
            pub const fn value(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x7fff_ffff;
                val as u32
            }
            #[doc = "Count to add to CC\\[n\\]"]
            #[inline(always)]
            pub fn set_value(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x7fff_ffff << 0usize)) | (((val as u32) & 0x7fff_ffff) << 0usize);
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub const fn reference(&self) -> super::vals::Reference {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Reference::from_bits(val as u8)
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub fn set_reference(&mut self, val: super::vals::Reference) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ccadd {
            #[inline(always)]
            fn default() -> Ccadd {
                Ccadd(0)
            }
        }
        impl core::fmt::Debug for Ccadd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccadd")
                    .field("value", &self.value())
                    .field("reference", &self.reference())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccadd {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ccadd {
                    value: u32,
                    reference: super::vals::Reference,
                }
                let proxy = Ccadd {
                    value: self.value(),
                    reference: self.reference(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Configure Capture/Compare register CC\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccen(pub u32);
        impl Ccen {
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Configure the Capture/Compare register"]
            #[inline(always)]
            pub fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ccen {
            #[inline(always)]
            fn default() -> Ccen {
                Ccen(0)
            }
        }
        impl core::fmt::Debug for Ccen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccen")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ccen {
                    active: bool,
                }
                let proxy = Ccen {
                    active: self.active(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: The higher 32-bits of Capture/Compare register CC\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cch(pub u32);
        impl Cch {
            #[doc = "Capture/Compare high value in 1 us"]
            #[inline(always)]
            pub const fn cch(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Capture/Compare high value in 1 us"]
            #[inline(always)]
            pub fn set_cch(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Cch {
            #[inline(always)]
            fn default() -> Cch {
                Cch(0)
            }
        }
        impl core::fmt::Debug for Cch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cch").field("cch", &self.cch()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cch {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cch {
                    cch: u32,
                }
                let proxy = Cch { cch: self.cch() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Clock Configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkcfg(pub u32);
        impl Clkcfg {
            #[doc = "Fast clock divisor value of clock output"]
            #[inline(always)]
            pub const fn clkfastdiv(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Fast clock divisor value of clock output"]
            #[inline(always)]
            pub fn set_clkfastdiv(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "GRTC LFCLK clock source selection"]
            #[inline(always)]
            pub const fn clksel(&self) -> super::vals::Clksel {
                let val = (self.0 >> 16usize) & 0x03;
                super::vals::Clksel::from_bits(val as u8)
            }
            #[doc = "GRTC LFCLK clock source selection"]
            #[inline(always)]
            pub fn set_clksel(&mut self, val: super::vals::Clksel) {
                self.0 =
                    (self.0 & !(0x03 << 16usize)) | (((val.to_bits() as u32) & 0x03) << 16usize);
            }
        }
        impl Default for Clkcfg {
            #[inline(always)]
            fn default() -> Clkcfg {
                Clkcfg(0)
            }
        }
        impl core::fmt::Debug for Clkcfg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkcfg")
                    .field("clkfastdiv", &self.clkfastdiv())
                    .field("clksel", &self.clksel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkcfg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Clkcfg {
                    clkfastdiv: u8,
                    clksel: super::vals::Clksel,
                }
                let proxy = Clkcfg {
                    clkfastdiv: self.clkfastdiv(),
                    clksel: self.clksel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of clock output"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clkout(pub u32);
        impl Clkout {
            #[doc = "Enable 32Ki clock output on pin"]
            #[inline(always)]
            pub const fn clkout32k(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable 32Ki clock output on pin"]
            #[inline(always)]
            pub fn set_clkout32k(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable fast clock output on pin"]
            #[inline(always)]
            pub const fn clkoutfast(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable fast clock output on pin"]
            #[inline(always)]
            pub fn set_clkoutfast(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Clkout {
            #[inline(always)]
            fn default() -> Clkout {
                Clkout(0)
            }
        }
        impl core::fmt::Debug for Clkout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clkout")
                    .field("clkout32k", &self.clkout32k())
                    .field("clkoutfast", &self.clkoutfast())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clkout {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Clkout {
                    clkout32k: bool,
                    clkoutfast: bool,
                }
                let proxy = Clkout {
                    clkout32k: self.clkout32k(),
                    clkoutfast: self.clkoutfast(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable event routing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Evt(pub u32);
        impl Evt {
            #[doc = "Enable or disable event routing for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event PWMPERIODEND"]
            #[inline(always)]
            pub fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Evt {
            #[inline(always)]
            fn default() -> Evt {
                Evt(0)
            }
        }
        impl core::fmt::Debug for Evt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Evt")
                    .field("pwmperiodend", &self.pwmperiodend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Evt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Evt {
                    pwmperiodend: bool,
                }
                let proxy = Evt {
                    pwmperiodend: self.pwmperiodend(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn compare0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub fn set_compare0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[1\\]"]
            #[inline(always)]
            pub const fn compare1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[1\\]"]
            #[inline(always)]
            pub fn set_compare1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[2\\]"]
            #[inline(always)]
            pub const fn compare2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[2\\]"]
            #[inline(always)]
            pub fn set_compare2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[3\\]"]
            #[inline(always)]
            pub const fn compare3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[3\\]"]
            #[inline(always)]
            pub fn set_compare3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[4\\]"]
            #[inline(always)]
            pub const fn compare4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[4\\]"]
            #[inline(always)]
            pub fn set_compare4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[5\\]"]
            #[inline(always)]
            pub const fn compare5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[5\\]"]
            #[inline(always)]
            pub fn set_compare5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[6\\]"]
            #[inline(always)]
            pub const fn compare6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[6\\]"]
            #[inline(always)]
            pub fn set_compare6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[7\\]"]
            #[inline(always)]
            pub const fn compare7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[7\\]"]
            #[inline(always)]
            pub fn set_compare7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[8\\]"]
            #[inline(always)]
            pub const fn compare8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[8\\]"]
            #[inline(always)]
            pub fn set_compare8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[9\\]"]
            #[inline(always)]
            pub const fn compare9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[9\\]"]
            #[inline(always)]
            pub fn set_compare9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[10\\]"]
            #[inline(always)]
            pub const fn compare10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[10\\]"]
            #[inline(always)]
            pub fn set_compare10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[11\\]"]
            #[inline(always)]
            pub const fn compare11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[11\\]"]
            #[inline(always)]
            pub fn set_compare11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event RTCOMPARESYNC"]
            #[inline(always)]
            pub const fn rtcomparesync(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RTCOMPARESYNC"]
            #[inline(always)]
            pub fn set_rtcomparesync(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("compare0", &self.compare0())
                    .field("compare1", &self.compare1())
                    .field("compare2", &self.compare2())
                    .field("compare3", &self.compare3())
                    .field("compare4", &self.compare4())
                    .field("compare5", &self.compare5())
                    .field("compare6", &self.compare6())
                    .field("compare7", &self.compare7())
                    .field("compare8", &self.compare8())
                    .field("compare9", &self.compare9())
                    .field("compare10", &self.compare10())
                    .field("compare11", &self.compare11())
                    .field("rtcomparesync", &self.rtcomparesync())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    compare0: bool,
                    compare1: bool,
                    compare2: bool,
                    compare3: bool,
                    compare4: bool,
                    compare5: bool,
                    compare6: bool,
                    compare7: bool,
                    compare8: bool,
                    compare9: bool,
                    compare10: bool,
                    compare11: bool,
                    rtcomparesync: bool,
                    pwmperiodend: bool,
                }
                let proxy = Int {
                    compare0: self.compare0(),
                    compare1: self.compare1(),
                    compare2: self.compare2(),
                    compare3: self.compare3(),
                    compare4: self.compare4(),
                    compare5: self.compare5(),
                    compare6: self.compare6(),
                    compare7: self.compare7(),
                    compare8: self.compare8(),
                    compare9: self.compare9(),
                    compare10: self.compare10(),
                    compare11: self.compare11(),
                    rtcomparesync: self.rtcomparesync(),
                    pwmperiodend: self.pwmperiodend(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Count to add to CC\\[0\\] when the event EVENTS_COMPARE\\[0\\] triggers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Interval(pub u32);
        impl Interval {
            #[doc = "Count to add to CC\\[0\\]"]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Count to add to CC\\[0\\]"]
            #[inline(always)]
            pub fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Interval {
            #[inline(always)]
            fn default() -> Interval {
                Interval(0)
            }
        }
        impl core::fmt::Debug for Interval {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Interval")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Interval {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Interval {
                    value: u16,
                }
                let proxy = Interval {
                    value: self.value(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Counter mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Automatic enable to keep the SYSCOUNTER active."]
            #[inline(always)]
            pub const fn autoen(&self) -> super::vals::Autoen {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Autoen::from_bits(val as u8)
            }
            #[doc = "Automatic enable to keep the SYSCOUNTER active."]
            #[inline(always)]
            pub fn set_autoen(&mut self, val: super::vals::Autoen) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable the SYSCOUNTER"]
            #[inline(always)]
            pub const fn syscounteren(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the SYSCOUNTER"]
            #[inline(always)]
            pub fn set_syscounteren(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("autoen", &self.autoen())
                    .field("syscounteren", &self.syscounteren())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    autoen: super::vals::Autoen,
                    syscounteren: bool,
                }
                let proxy = Mode {
                    autoen: self.autoen(),
                    syscounteren: self.syscounteren(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "PWM configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwmconfig(pub u32);
        impl Pwmconfig {
            #[doc = "The PWM compare value"]
            #[inline(always)]
            pub const fn comparevalue(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "The PWM compare value"]
            #[inline(always)]
            pub fn set_comparevalue(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Pwmconfig {
            #[inline(always)]
            fn default() -> Pwmconfig {
                Pwmconfig(0)
            }
        }
        impl core::fmt::Debug for Pwmconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwmconfig")
                    .field("comparevalue", &self.comparevalue())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwmconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pwmconfig {
                    comparevalue: u8,
                }
                let proxy = Pwmconfig {
                    comparevalue: self.comparevalue(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event RTCOMPARE and task CLEAR"]
            #[inline(always)]
            pub const fn rtcompare_clear(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RTCOMPARE and task CLEAR"]
            #[inline(always)]
            pub fn set_rtcompare_clear(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("rtcompare_clear", &self.rtcompare_clear())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    rtcompare_clear: bool,
                }
                let proxy = Shorts {
                    rtcompare_clear: self.rtcompare_clear(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: The higher 20-bits of the SYSCOUNTER for index \\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscounterh(pub u32);
        impl Syscounterh {
            #[doc = "The higher 20-bits of the SYSCOUNTER value."]
            #[inline(always)]
            pub const fn value(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "The higher 20-bits of the SYSCOUNTER value."]
            #[inline(always)]
            pub fn set_value(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
            #[doc = "SYSCOUNTER busy status"]
            #[inline(always)]
            pub const fn busy(&self) -> super::vals::Busy {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Busy::from_bits(val as u8)
            }
            #[doc = "SYSCOUNTER busy status"]
            #[inline(always)]
            pub fn set_busy(&mut self, val: super::vals::Busy) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "The SYSCOUNTERL overflow indication after reading it."]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "The SYSCOUNTERL overflow indication after reading it."]
            #[inline(always)]
            pub fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Syscounterh {
            #[inline(always)]
            fn default() -> Syscounterh {
                Syscounterh(0)
            }
        }
        impl core::fmt::Debug for Syscounterh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscounterh")
                    .field("value", &self.value())
                    .field("busy", &self.busy())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscounterh {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Syscounterh {
                    value: u32,
                    busy: super::vals::Busy,
                    overflow: bool,
                }
                let proxy = Syscounterh {
                    value: self.value(),
                    busy: self.busy(),
                    overflow: self.overflow(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Timeout after all CPUs gone into sleep state to stop the SYSCOUNTER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timeout(pub u32);
        impl Timeout {
            #[doc = "Number of 32Ki cycles"]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of 32Ki cycles"]
            #[inline(always)]
            pub fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Timeout {
            #[inline(always)]
            fn default() -> Timeout {
                Timeout(0)
            }
        }
        impl core::fmt::Debug for Timeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timeout")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timeout {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Timeout {
                    value: u16,
                }
                let proxy = Timeout {
                    value: self.value(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "GRTC wake up time."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Waketime(pub u32);
        impl Waketime {
            #[doc = "Number of LFCLK clock cycles to wake up before the next scheduled EVENTS_COMPARE event"]
            #[inline(always)]
            pub const fn value(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Number of LFCLK clock cycles to wake up before the next scheduled EVENTS_COMPARE event"]
            #[inline(always)]
            pub fn set_value(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Waketime {
            #[inline(always)]
            fn default() -> Waketime {
                Waketime(0)
            }
        }
        impl core::fmt::Debug for Waketime {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Waketime")
                    .field("value", &self.value())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Waketime {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Waketime {
                    value: u8,
                }
                let proxy = Waketime {
                    value: self.value(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Autoen {
            #[doc = "Default configuration to keep the SYSCOUNTER active."]
            DEFAULT = 0x0,
            #[doc = "In addition to the above mode, any local CPU that is not sleeping keep the SYSCOUNTER active."]
            CPU_ACTIVE = 0x01,
        }
        impl Autoen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Autoen {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Autoen {
            #[inline(always)]
            fn from(val: u8) -> Autoen {
                Autoen::from_bits(val)
            }
        }
        impl From<Autoen> for u8 {
            #[inline(always)]
            fn from(val: Autoen) -> u8 {
                Autoen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Busy {
            #[doc = "SYSCOUNTER is ready for read"]
            READY = 0x0,
            #[doc = "SYSCOUNTER is busy, so not ready for read (value returned in the VALUE field of this register is not valid)"]
            BUSY = 0x01,
        }
        impl Busy {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Busy {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Busy {
            #[inline(always)]
            fn from(val: u8) -> Busy {
                Busy::from_bits(val)
            }
        }
        impl From<Busy> for u8 {
            #[inline(always)]
            fn from(val: Busy) -> u8 {
                Busy::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clksel {
            #[doc = "GRTC LFCLK clock source is LFXO"]
            LFXO = 0x0,
            #[doc = "GRTC LFCLK clock source is system LFCLK"]
            SYSTEM_LFCLK = 0x01,
            #[doc = "GRTC LFCLK clock source is LFLPRC"]
            LFLPRC = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Clksel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clksel {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clksel {
            #[inline(always)]
            fn from(val: u8) -> Clksel {
                Clksel::from_bits(val)
            }
        }
        impl From<Clksel> for u8 {
            #[inline(always)]
            fn from(val: Clksel) -> u8 {
                Clksel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reference {
            #[doc = "Adds SYSCOUNTER value."]
            SYSCOUNTER = 0x0,
            #[doc = "Adds CC value."]
            CC = 0x01,
        }
        impl Reference {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reference {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reference {
            #[inline(always)]
            fn from(val: u8) -> Reference {
                Reference::from_bits(val)
            }
        }
        impl From<Reference> for u8 {
            #[inline(always)]
            fn from(val: Reference) -> u8 {
                Reference::to_bits(val)
            }
        }
    }
}
pub mod i2s {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Channel {
        ptr: *mut u8,
    }
    unsafe impl Send for Channel {}
    unsafe impl Sync for Channel {}
    impl Channel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "I2S mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Reception (RX) enable"]
        #[inline(always)]
        pub const fn rxen(self) -> crate::common::Reg<regs::Rxen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Transmission (TX) enable"]
        #[inline(always)]
        pub const fn txen(self) -> crate::common::Reg<regs::Txen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Master clock generator enable"]
        #[inline(always)]
        pub const fn mcken(self) -> crate::common::Reg<regs::Mcken, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "I2S clock generator control"]
        #[inline(always)]
        pub const fn mckfreq(self) -> crate::common::Reg<regs::Mckfreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "MCK / LRCK ratio"]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Sample width"]
        #[inline(always)]
        pub const fn swidth(self) -> crate::common::Reg<regs::Swidth, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Alignment of sample within a frame"]
        #[inline(always)]
        pub const fn align(self) -> crate::common::Reg<regs::Align, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Frame format"]
        #[inline(always)]
        pub const fn format(self) -> crate::common::Reg<regs::Format, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Enable channels"]
        #[inline(always)]
        pub const fn channels(self) -> crate::common::Reg<regs::Channels, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Inter-IC Sound 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct I2s {
        ptr: *mut u8,
    }
    unsafe impl Send for I2s {}
    unsafe impl Sync for I2s {}
    impl I2s {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous I2S transfer. Also starts MCK generator when this is enabled"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops I2S transfer and MCK generator. Triggering this task will cause the event STOPPED to be generated."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "The RXD.PTR register has been copied to internal double-buffers. When the I2S module is started and RX is enabled, this event will be generated for every RXTXD.MAXCNT words received on the SDIN pin."]
        #[inline(always)]
        pub const fn events_rxptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "I2S transfer stopped."]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "The TDX.PTR register has been copied to internal double-buffers. When the I2S module is started and TX is enabled, this event will be generated for every RXTXD.MAXCNT words that are sent on the SDOUT pin."]
        #[inline(always)]
        pub const fn events_txptrupd(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Frame start event, generated on the active edge of LRCK"]
        #[inline(always)]
        pub const fn events_framestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Publish configuration for event RXPTRUPD"]
        #[inline(always)]
        pub const fn publish_rxptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event TXPTRUPD"]
        #[inline(always)]
        pub const fn publish_txptrupd(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event FRAMESTART"]
        #[inline(always)]
        pub const fn publish_framestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable I2S module"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxtxd(self) -> Rxtxd {
            unsafe { Rxtxd::from_ptr(self.ptr.add(0x0550usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0560usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn channel(self, n: usize) -> Channel {
            assert!(n < 2usize);
            unsafe { Channel::from_ptr(self.ptr.add(0x0580usize + n * 8usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for MCK signal"]
        #[inline(always)]
        pub const fn mck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for SCK signal"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for LRCK signal"]
        #[inline(always)]
        pub const fn lrck(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for SDIN signal"]
        #[inline(always)]
        pub const fn sdin(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Pin select for SDOUT signal"]
        #[inline(always)]
        pub const fn sdout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Receive buffer RAM start address."]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxtxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxtxd {}
    unsafe impl Sync for Rxtxd {}
    impl Rxtxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Size of RXD and TXD buffers"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Transmit buffer RAM start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Alignment of sample within a frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Align(pub u32);
        impl Align {
            #[doc = "Alignment of sample within a frame"]
            #[inline(always)]
            pub const fn align(&self) -> super::vals::Align {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Align::from_bits(val as u8)
            }
            #[doc = "Alignment of sample within a frame"]
            #[inline(always)]
            pub fn set_align(&mut self, val: super::vals::Align) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Align {
            #[inline(always)]
            fn default() -> Align {
                Align(0)
            }
        }
        impl core::fmt::Debug for Align {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Align")
                    .field("align", &self.align())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Align {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Align {
                    align: super::vals::Align,
                }
                let proxy = Align {
                    align: self.align(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable channels"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Channels(pub u32);
        impl Channels {
            #[doc = "Enable channels"]
            #[inline(always)]
            pub const fn channels(&self) -> super::vals::Channels {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Channels::from_bits(val as u8)
            }
            #[doc = "Enable channels"]
            #[inline(always)]
            pub fn set_channels(&mut self, val: super::vals::Channels) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Channels {
            #[inline(always)]
            fn default() -> Channels {
                Channels(0)
            }
        }
        impl core::fmt::Debug for Channels {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Channels")
                    .field("channels", &self.channels())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Channels {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Channels {
                    channels: super::vals::Channels,
                }
                let proxy = Channels {
                    channels: self.channels(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable I2S module"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable I2S module"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable I2S module"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Frame format"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Format(pub u32);
        impl Format {
            #[doc = "Frame format"]
            #[inline(always)]
            pub const fn format(&self) -> super::vals::Format {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Format::from_bits(val as u8)
            }
            #[doc = "Frame format"]
            #[inline(always)]
            pub fn set_format(&mut self, val: super::vals::Format) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Format {
            #[inline(always)]
            fn default() -> Format {
                Format(0)
            }
        }
        impl core::fmt::Debug for Format {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Format")
                    .field("format", &self.format())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Format {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Format {
                    format: super::vals::Format,
                }
                let proxy = Format {
                    format: self.format(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[inline(always)]
            pub const fn rxptrupd(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXPTRUPD"]
            #[inline(always)]
            pub fn set_rxptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[inline(always)]
            pub const fn txptrupd(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXPTRUPD"]
            #[inline(always)]
            pub fn set_txptrupd(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub const fn framestart(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub fn set_framestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("rxptrupd", &self.rxptrupd())
                    .field("stopped", &self.stopped())
                    .field("txptrupd", &self.txptrupd())
                    .field("framestart", &self.framestart())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    rxptrupd: bool,
                    stopped: bool,
                    txptrupd: bool,
                    framestart: bool,
                }
                let proxy = Int {
                    rxptrupd: self.rxptrupd(),
                    stopped: self.stopped(),
                    txptrupd: self.txptrupd(),
                    framestart: self.framestart(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Size of RXD and TXD buffers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Size of RXD and TXD buffers in number of 32 bit words"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[doc = "Size of RXD and TXD buffers in number of 32 bit words"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxcnt {
                    maxcnt: u16,
                }
                let proxy = Maxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Master clock generator enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mcken(pub u32);
        impl Mcken {
            #[doc = "Master clock generator enable"]
            #[inline(always)]
            pub const fn mcken(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Master clock generator enable"]
            #[inline(always)]
            pub fn set_mcken(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mcken {
            #[inline(always)]
            fn default() -> Mcken {
                Mcken(0)
            }
        }
        impl core::fmt::Debug for Mcken {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mcken")
                    .field("mcken", &self.mcken())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mcken {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mcken {
                    mcken: bool,
                }
                let proxy = Mcken {
                    mcken: self.mcken(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "I2S clock generator control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mckfreq(pub u32);
        impl Mckfreq {
            #[doc = "I2S MCK frequency configuration NOTE: Enumerations are deprecated, use MCKFREQ equation. NOTE: The 12 least significant bits of the register are ignored and shall be set to zero."]
            #[inline(always)]
            pub const fn mckfreq(&self) -> super::vals::Mckfreq {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Mckfreq::from_bits(val as u32)
            }
            #[doc = "I2S MCK frequency configuration NOTE: Enumerations are deprecated, use MCKFREQ equation. NOTE: The 12 least significant bits of the register are ignored and shall be set to zero."]
            #[inline(always)]
            pub fn set_mckfreq(&mut self, val: super::vals::Mckfreq) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Mckfreq {
            #[inline(always)]
            fn default() -> Mckfreq {
                Mckfreq(0)
            }
        }
        impl core::fmt::Debug for Mckfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mckfreq")
                    .field("mckfreq", &self.mckfreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mckfreq {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mckfreq {
                    mckfreq: super::vals::Mckfreq,
                }
                let proxy = Mckfreq {
                    mckfreq: self.mckfreq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "I2S mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "I2S mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "I2S mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    mode: super::vals::Mode,
                }
                let proxy = Mode { mode: self.mode() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "MCK / LRCK ratio"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "MCK / LRCK ratio"]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "MCK / LRCK ratio"]
            #[inline(always)]
            pub fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ratio {
                    ratio: super::vals::Ratio,
                }
                let proxy = Ratio {
                    ratio: self.ratio(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Reception (RX) enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxen(pub u32);
        impl Rxen {
            #[doc = "Reception (RX) enable"]
            #[inline(always)]
            pub const fn rxen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reception (RX) enable"]
            #[inline(always)]
            pub fn set_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Rxen {
            #[inline(always)]
            fn default() -> Rxen {
                Rxen(0)
            }
        }
        impl core::fmt::Debug for Rxen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxen").field("rxen", &self.rxen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rxen {
                    rxen: bool,
                }
                let proxy = Rxen { rxen: self.rxen() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sample width"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Swidth(pub u32);
        impl Swidth {
            #[doc = "Sample and half-frame width"]
            #[inline(always)]
            pub const fn swidth(&self) -> super::vals::Swidth {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Swidth::from_bits(val as u8)
            }
            #[doc = "Sample and half-frame width"]
            #[inline(always)]
            pub fn set_swidth(&mut self, val: super::vals::Swidth) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Swidth {
            #[inline(always)]
            fn default() -> Swidth {
                Swidth(0)
            }
        }
        impl core::fmt::Debug for Swidth {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Swidth")
                    .field("swidth", &self.swidth())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Swidth {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Swidth {
                    swidth: super::vals::Swidth,
                }
                let proxy = Swidth {
                    swidth: self.swidth(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Terminateonbuserror {
                    enable: bool,
                }
                let proxy = Terminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Transmission (TX) enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txen(pub u32);
        impl Txen {
            #[doc = "Transmission (TX) enable"]
            #[inline(always)]
            pub const fn txen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Transmission (TX) enable"]
            #[inline(always)]
            pub fn set_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Txen {
            #[inline(always)]
            fn default() -> Txen {
                Txen(0)
            }
        }
        impl core::fmt::Debug for Txen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txen").field("txen", &self.txen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Txen {
                    txen: bool,
                }
                let proxy = Txen { txen: self.txen() };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Align {
            #[doc = "Left-aligned."]
            LEFT = 0x0,
            #[doc = "Right-aligned."]
            RIGHT = 0x01,
        }
        impl Align {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Align {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Align {
            #[inline(always)]
            fn from(val: u8) -> Align {
                Align::from_bits(val)
            }
        }
        impl From<Align> for u8 {
            #[inline(always)]
            fn from(val: Align) -> u8 {
                Align::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Channels {
            #[doc = "Stereo."]
            STEREO = 0x0,
            #[doc = "Left only."]
            LEFT = 0x01,
            #[doc = "Right only."]
            RIGHT = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Channels {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Channels {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Channels {
            #[inline(always)]
            fn from(val: u8) -> Channels {
                Channels::from_bits(val)
            }
        }
        impl From<Channels> for u8 {
            #[inline(always)]
            fn from(val: Channels) -> u8 {
                Channels::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Format {
            #[doc = "Original I2S format."]
            I2S = 0x0,
            #[doc = "Alternate (left- or right-aligned) format."]
            ALIGNED = 0x01,
        }
        impl Format {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Format {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Format {
            #[inline(always)]
            fn from(val: u8) -> Format {
                Format::from_bits(val)
            }
        }
        impl From<Format> for u8 {
            #[inline(always)]
            fn from(val: Format) -> u8 {
                Format::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Mckfreq(pub u32);
        impl Mckfreq {
            #[doc = "32 MHz / 125 = 0.256 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV125: Self = Self(0x020c_0000);
            #[doc = "32 MHz / 63 = 0.5079365 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV63: Self = Self(0x0410_0000);
            #[doc = "32 MHz / 42 = 0.7619048 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV42: Self = Self(0x0600_0000);
            #[doc = "32 MHz / 32 = 1.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV32: Self = Self(0x0800_0000);
            #[doc = "32 MHz / 31 = 1.0322581 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV31: Self = Self(0x0840_0000);
            #[doc = "32 MHz / 30 = 1.0666667 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV30: Self = Self(0x0880_0000);
            #[doc = "32 MHz / 23 = 1.3913043 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV23: Self = Self(0x0b00_0000);
            #[doc = "32 MHz / 21 = 1.5238095 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV21: Self = Self(0x0c00_0000);
            #[doc = "32 MHz / 16 = 2.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV16: Self = Self(0x1000_0000);
            #[doc = "32 MHz / 15 = 2.1333333 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV15: Self = Self(0x1100_0000);
            #[doc = "32 MHz / 11 = 2.9090909 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV11: Self = Self(0x1600_0000);
            #[doc = "32 MHz / 10 = 3.2 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV10: Self = Self(0x1800_0000);
            #[doc = "32 MHz / 8 = 4.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV8: Self = Self(0x2000_0000);
            #[doc = "32 MHz / 6 = 5.3333333 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV6: Self = Self(0x2800_0000);
            #[doc = "32 MHz / 5 = 6.4 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV5: Self = Self(0x3000_0000);
            #[doc = "32 MHz / 4 = 8.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV4: Self = Self(0x4000_0000);
            #[doc = "32 MHz / 3 = 10.6666667 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV3: Self = Self(0x5000_0000);
            #[doc = "32 MHz / 2 = 16.0 MHz Deprecated, use MCKFREQ equation."]
            pub const _32MDIV2: Self = Self(0x8000_0000);
        }
        impl Mckfreq {
            pub const fn from_bits(val: u32) -> Mckfreq {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Mckfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x020c_0000 => f.write_str("_32MDIV125"),
                    0x0410_0000 => f.write_str("_32MDIV63"),
                    0x0600_0000 => f.write_str("_32MDIV42"),
                    0x0800_0000 => f.write_str("_32MDIV32"),
                    0x0840_0000 => f.write_str("_32MDIV31"),
                    0x0880_0000 => f.write_str("_32MDIV30"),
                    0x0b00_0000 => f.write_str("_32MDIV23"),
                    0x0c00_0000 => f.write_str("_32MDIV21"),
                    0x1000_0000 => f.write_str("_32MDIV16"),
                    0x1100_0000 => f.write_str("_32MDIV15"),
                    0x1600_0000 => f.write_str("_32MDIV11"),
                    0x1800_0000 => f.write_str("_32MDIV10"),
                    0x2000_0000 => f.write_str("_32MDIV8"),
                    0x2800_0000 => f.write_str("_32MDIV6"),
                    0x3000_0000 => f.write_str("_32MDIV5"),
                    0x4000_0000 => f.write_str("_32MDIV4"),
                    0x5000_0000 => f.write_str("_32MDIV3"),
                    0x8000_0000 => f.write_str("_32MDIV2"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mckfreq {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x020c_0000 => defmt::write!(f, "_32MDIV125"),
                    0x0410_0000 => defmt::write!(f, "_32MDIV63"),
                    0x0600_0000 => defmt::write!(f, "_32MDIV42"),
                    0x0800_0000 => defmt::write!(f, "_32MDIV32"),
                    0x0840_0000 => defmt::write!(f, "_32MDIV31"),
                    0x0880_0000 => defmt::write!(f, "_32MDIV30"),
                    0x0b00_0000 => defmt::write!(f, "_32MDIV23"),
                    0x0c00_0000 => defmt::write!(f, "_32MDIV21"),
                    0x1000_0000 => defmt::write!(f, "_32MDIV16"),
                    0x1100_0000 => defmt::write!(f, "_32MDIV15"),
                    0x1600_0000 => defmt::write!(f, "_32MDIV11"),
                    0x1800_0000 => defmt::write!(f, "_32MDIV10"),
                    0x2000_0000 => defmt::write!(f, "_32MDIV8"),
                    0x2800_0000 => defmt::write!(f, "_32MDIV6"),
                    0x3000_0000 => defmt::write!(f, "_32MDIV5"),
                    0x4000_0000 => defmt::write!(f, "_32MDIV4"),
                    0x5000_0000 => defmt::write!(f, "_32MDIV3"),
                    0x8000_0000 => defmt::write!(f, "_32MDIV2"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Mckfreq {
            #[inline(always)]
            fn from(val: u32) -> Mckfreq {
                Mckfreq::from_bits(val)
            }
        }
        impl From<Mckfreq> for u32 {
            #[inline(always)]
            fn from(val: Mckfreq) -> u32 {
                Mckfreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Master mode. SCK and LRCK generated from internal master clcok (MCK) and output on pins defined by PSEL.xxx."]
            MASTER = 0x0,
            #[doc = "Slave mode. SCK and LRCK generated by external master and received on pins defined by PSEL.xxx"]
            SLAVE = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "LRCK = MCK / 32"]
            _32X = 0x0,
            #[doc = "LRCK = MCK / 48"]
            _48X = 0x01,
            #[doc = "LRCK = MCK / 64"]
            _64X = 0x02,
            #[doc = "LRCK = MCK / 96"]
            _96X = 0x03,
            #[doc = "LRCK = MCK / 128"]
            _128X = 0x04,
            #[doc = "LRCK = MCK / 192"]
            _192X = 0x05,
            #[doc = "LRCK = MCK / 256"]
            _256X = 0x06,
            #[doc = "LRCK = MCK / 384"]
            _384X = 0x07,
            #[doc = "LRCK = MCK / 512"]
            _512X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Swidth {
            #[doc = "8 bit sample."]
            _8BIT = 0x0,
            #[doc = "16 bit sample."]
            _16BIT = 0x01,
            #[doc = "24 bit sample."]
            _24BIT = 0x02,
            #[doc = "32 bit sample."]
            _32BIT = 0x03,
            #[doc = "8 bit sample in a 16-bit half-frame."]
            _8BIT_IN16 = 0x04,
            #[doc = "8 bit sample in a 32-bit half-frame."]
            _8BIT_IN32 = 0x05,
            #[doc = "16 bit sample in a 32-bit half-frame."]
            _16BIT_IN32 = 0x06,
            #[doc = "24 bit sample in a 32-bit half-frame."]
            _24BIT_IN32 = 0x07,
        }
        impl Swidth {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Swidth {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Swidth {
            #[inline(always)]
            fn from(val: u8) -> Swidth {
                Swidth::from_bits(val)
            }
        }
        impl From<Swidth> for u8 {
            #[inline(always)]
            fn from(val: Swidth) -> u8 {
                Swidth::to_bits(val)
            }
        }
    }
}
pub mod kmu {
    #[doc = "Key management unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Kmu {
        ptr: *mut u8,
    }
    unsafe impl Send for Kmu {}
    unsafe impl Sync for Kmu {}
    impl Kmu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Provision key slot"]
        #[inline(always)]
        pub const fn tasks_provision(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Push key slot"]
        #[inline(always)]
        pub const fn tasks_push(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Revoke key slot"]
        #[inline(always)]
        pub const fn tasks_revoke(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Read key slot metedata into METADATA register"]
        #[inline(always)]
        pub const fn tasks_readmetadata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Block the PUSH operation of key slot, preventing the key slot being PUSH until next reset"]
        #[inline(always)]
        pub const fn tasks_pushblock(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Key slot successfully provisioned"]
        #[inline(always)]
        pub const fn events_provisioned(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Key slot successfully pushed"]
        #[inline(always)]
        pub const fn events_pushed(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Key slot has been revoked and can no longer be used"]
        #[inline(always)]
        pub const fn events_revoked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Error during PROVISION, PUSH, or REVOKE operations"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Key slot metedata has been read into METADATA register"]
        #[inline(always)]
        pub const fn events_metadataread(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "The PUSHBLOCK operation was succesful"]
        #[inline(always)]
        pub const fn events_pushblocked(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "KMU status register"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Select key slot to operate on"]
        #[inline(always)]
        pub const fn keyslot(self) -> crate::common::Reg<regs::Keyslot, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Source address for provisioning"]
        #[inline(always)]
        pub const fn src(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Key slot metadata as read by TASKS_READMETADATA."]
        #[inline(always)]
        pub const fn metadata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Select key slot to operate on"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Keyslot(pub u32);
        impl Keyslot {
            #[doc = "Select key slot ID to provision, read, or push when TASKS_PROVISION, TASKS_PUSH, TASKS_READMETADATA, or TASKS_REVOKE, is triggered."]
            #[inline(always)]
            pub const fn id(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Select key slot ID to provision, read, or push when TASKS_PROVISION, TASKS_PUSH, TASKS_READMETADATA, or TASKS_REVOKE, is triggered."]
            #[inline(always)]
            pub fn set_id(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Keyslot {
            #[inline(always)]
            fn default() -> Keyslot {
                Keyslot(0)
            }
        }
        impl core::fmt::Debug for Keyslot {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Keyslot").field("id", &self.id()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Keyslot {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Keyslot {
                    id: u8,
                }
                let proxy = Keyslot { id: self.id() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "KMU status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "KMU status"]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "KMU status"]
            #[inline(always)]
            pub fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Status {
                    status: super::vals::Status,
                }
                let proxy = Status {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "KMU is ready for new operation"]
            READY = 0x0,
            #[doc = "KMU is busy, an operation is in progress"]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
    }
}
pub mod lpcomp {
    #[doc = "Low-power comparator 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Lpcomp {
        ptr: *mut u8,
    }
    unsafe impl Send for Lpcomp {}
    unsafe impl Sync for Lpcomp {}
    impl Lpcomp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start comparator"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop comparator"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Sample comparator value. This task requires that LPCOMP has been started by the START task."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "LPCOMP is ready and output is valid"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Downward crossing"]
        #[inline(always)]
        pub const fn events_down(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Upward crossing"]
        #[inline(always)]
        pub const fn events_up(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Downward or upward crossing"]
        #[inline(always)]
        pub const fn events_cross(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event DOWN"]
        #[inline(always)]
        pub const fn publish_down(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event UP"]
        #[inline(always)]
        pub const fn publish_up(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event CROSS"]
        #[inline(always)]
        pub const fn publish_cross(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Compare result"]
        #[inline(always)]
        pub const fn result(self) -> crate::common::Reg<regs::Result, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable LPCOMP"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Input pin select"]
        #[inline(always)]
        pub const fn psel(self) -> crate::common::Reg<regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Reference select"]
        #[inline(always)]
        pub const fn refsel(self) -> crate::common::Reg<regs::Refsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "External reference select"]
        #[inline(always)]
        pub const fn extrefsel(self) -> crate::common::Reg<regs::Extrefsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Analog detect configuration"]
        #[inline(always)]
        pub const fn anadetect(self) -> crate::common::Reg<regs::Anadetect, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Comparator hysteresis enable"]
        #[inline(always)]
        pub const fn hyst(self) -> crate::common::Reg<regs::Hyst, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Analog detect configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Anadetect(pub u32);
        impl Anadetect {
            #[doc = "Analog detect configuration"]
            #[inline(always)]
            pub const fn anadetect(&self) -> super::vals::Anadetect {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Anadetect::from_bits(val as u8)
            }
            #[doc = "Analog detect configuration"]
            #[inline(always)]
            pub fn set_anadetect(&mut self, val: super::vals::Anadetect) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Anadetect {
            #[inline(always)]
            fn default() -> Anadetect {
                Anadetect(0)
            }
        }
        impl core::fmt::Debug for Anadetect {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Anadetect")
                    .field("anadetect", &self.anadetect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Anadetect {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Anadetect {
                    anadetect: super::vals::Anadetect,
                }
                let proxy = Anadetect {
                    anadetect: self.anadetect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable LPCOMP"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable LPCOMP"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable LPCOMP"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "External reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extrefsel(pub u32);
        impl Extrefsel {
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "External analog reference pin select"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Extrefsel {
            #[inline(always)]
            fn default() -> Extrefsel {
                Extrefsel(0)
            }
        }
        impl core::fmt::Debug for Extrefsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extrefsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extrefsel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Extrefsel {
                    pin: u8,
                    port: u8,
                }
                let proxy = Extrefsel {
                    pin: self.pin(),
                    port: self.port(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Comparator hysteresis enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hyst(pub u32);
        impl Hyst {
            #[doc = "Comparator hysteresis enable"]
            #[inline(always)]
            pub const fn hyst(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Comparator hysteresis enable"]
            #[inline(always)]
            pub fn set_hyst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Hyst {
            #[inline(always)]
            fn default() -> Hyst {
                Hyst(0)
            }
        }
        impl core::fmt::Debug for Hyst {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hyst").field("hyst", &self.hyst()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hyst {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Hyst {
                    hyst: bool,
                }
                let proxy = Hyst { hyst: self.hyst() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub const fn down(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DOWN"]
            #[inline(always)]
            pub fn set_down(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub const fn up(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event UP"]
            #[inline(always)]
            pub fn set_up(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub const fn cross(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CROSS"]
            #[inline(always)]
            pub fn set_cross(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("down", &self.down())
                    .field("up", &self.up())
                    .field("cross", &self.cross())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    ready: bool,
                    down: bool,
                    up: bool,
                    cross: bool,
                }
                let proxy = Int {
                    ready: self.ready(),
                    down: self.down(),
                    up: self.up(),
                    cross: self.cross(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Input pin select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Analog pin select"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Psel {
                    pin: u8,
                    port: u8,
                }
                let proxy = Psel {
                    pin: self.pin(),
                    port: self.port(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Reference select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refsel(pub u32);
        impl Refsel {
            #[doc = "Reference select"]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference select"]
            #[inline(always)]
            pub fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Refsel {
            #[inline(always)]
            fn default() -> Refsel {
                Refsel(0)
            }
        }
        impl core::fmt::Debug for Refsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refsel")
                    .field("refsel", &self.refsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refsel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Refsel {
                    refsel: super::vals::Refsel,
                }
                let proxy = Refsel {
                    refsel: self.refsel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Compare result"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Result(pub u32);
        impl Result {
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub const fn result(&self) -> super::vals::Result {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Result::from_bits(val as u8)
            }
            #[doc = "Result of last compare. Decision point SAMPLE task."]
            #[inline(always)]
            pub fn set_result(&mut self, val: super::vals::Result) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Result {
            #[inline(always)]
            fn default() -> Result {
                Result(0)
            }
        }
        impl core::fmt::Debug for Result {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Result")
                    .field("result", &self.result())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Result {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Result {
                    result: super::vals::Result,
                }
                let proxy = Result {
                    result: self.result(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub const fn ready_sample(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task SAMPLE"]
            #[inline(always)]
            pub fn set_ready_sample(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub const fn ready_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task STOP"]
            #[inline(always)]
            pub fn set_ready_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub const fn down_stop(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DOWN and task STOP"]
            #[inline(always)]
            pub fn set_down_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub const fn up_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event UP and task STOP"]
            #[inline(always)]
            pub fn set_up_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub const fn cross_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CROSS and task STOP"]
            #[inline(always)]
            pub fn set_cross_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_sample", &self.ready_sample())
                    .field("ready_stop", &self.ready_stop())
                    .field("down_stop", &self.down_stop())
                    .field("up_stop", &self.up_stop())
                    .field("cross_stop", &self.cross_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    ready_sample: bool,
                    ready_stop: bool,
                    down_stop: bool,
                    up_stop: bool,
                    cross_stop: bool,
                }
                let proxy = Shorts {
                    ready_sample: self.ready_sample(),
                    ready_stop: self.ready_stop(),
                    down_stop: self.down_stop(),
                    up_stop: self.up_stop(),
                    cross_stop: self.cross_stop(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Anadetect {
            #[doc = "Generate ANADETECT on crossing, both upward crossing and downward crossing"]
            CROSS = 0x0,
            #[doc = "Generate ANADETECT on upward crossing only"]
            UP = 0x01,
            #[doc = "Generate ANADETECT on downward crossing only"]
            DOWN = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Anadetect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Anadetect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Anadetect {
            #[inline(always)]
            fn from(val: u8) -> Anadetect {
                Anadetect::from_bits(val)
            }
        }
        impl From<Anadetect> for u8 {
            #[inline(always)]
            fn from(val: Anadetect) -> u8 {
                Anadetect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable"]
            DISABLED = 0x0,
            #[doc = "Enable"]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "VDD * 1/8 selected as reference"]
            REF1_8VDD = 0x0,
            #[doc = "VDD * 2/8 selected as reference"]
            REF2_8VDD = 0x01,
            #[doc = "VDD * 3/8 selected as reference"]
            REF3_8VDD = 0x02,
            #[doc = "VDD * 4/8 selected as reference"]
            REF4_8VDD = 0x03,
            #[doc = "VDD * 5/8 selected as reference"]
            REF5_8VDD = 0x04,
            #[doc = "VDD * 6/8 selected as reference"]
            REF6_8VDD = 0x05,
            #[doc = "VDD * 7/8 selected as reference"]
            REF7_8VDD = 0x06,
            #[doc = "External analog reference selected"]
            AREF = 0x07,
            #[doc = "VDD * 1/16 selected as reference"]
            REF1_16VDD = 0x08,
            #[doc = "VDD * 3/16 selected as reference"]
            REF3_16VDD = 0x09,
            #[doc = "VDD * 5/16 selected as reference"]
            REF5_16VDD = 0x0a,
            #[doc = "VDD * 7/16 selected as reference"]
            REF7_16VDD = 0x0b,
            #[doc = "VDD * 9/16 selected as reference"]
            REF9_16VDD = 0x0c,
            #[doc = "VDD * 11/16 selected as reference"]
            REF11_16VDD = 0x0d,
            #[doc = "VDD * 13/16 selected as reference"]
            REF13_16VDD = 0x0e,
            #[doc = "VDD * 15/16 selected as reference"]
            REF15_16VDD = 0x0f,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Result {
            #[doc = "Input voltage is below the reference threshold (VIN+ &lt; VIN-)"]
            BELOW = 0x0,
            #[doc = "Input voltage is above the reference threshold (VIN+ &gt; VIN-)"]
            ABOVE = 0x01,
        }
        impl Result {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Result {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Result {
            #[inline(always)]
            fn from(val: u8) -> Result {
                Result::from_bits(val)
            }
        }
        impl From<Result> for u8 {
            #[inline(always)]
            fn from(val: Result) -> u8 {
                Result::to_bits(val)
            }
        }
    }
}
pub mod memconf {
    #[doc = "Memory configuration 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memconf {
        ptr: *mut u8,
    }
    unsafe impl Send for Memconf {}
    unsafe impl Sync for Memconf {}
    impl Memconf {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn power(self, n: usize) -> Power {
            assert!(n < 2usize);
            unsafe { Power::from_ptr(self.ptr.add(0x0500usize + n * 16usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control memory block power."]
        #[inline(always)]
        pub const fn control(self) -> crate::common::Reg<regs::Control, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: RAM retention for RAM \\[n\\]."]
        #[inline(always)]
        pub const fn ret(self) -> crate::common::Reg<regs::Ret, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: RAM retention for the second bank in the RAM block"]
        #[inline(always)]
        pub const fn ret2(self) -> crate::common::Reg<regs::Ret2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Control memory block power."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Control(pub u32);
        impl Control {
            #[doc = "Keep the memory block MEM\\[0\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[0\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the memory block MEM\\[1\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[1\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the memory block MEM\\[2\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[2\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the memory block MEM\\[3\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[3\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the memory block MEM\\[4\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[4\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the memory block MEM\\[5\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[5\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the memory block MEM\\[6\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[6\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the memory block MEM\\[7\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[7\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the memory block MEM\\[8\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[8\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the memory block MEM\\[9\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[9\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the memory block MEM\\[10\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[10\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the memory block MEM\\[11\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[11\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the memory block MEM\\[12\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[12\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the memory block MEM\\[13\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[13\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the memory block MEM\\[14\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[14\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the memory block MEM\\[15\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[15\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the memory block MEM\\[16\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[16\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the memory block MEM\\[17\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[17\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the memory block MEM\\[18\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[18\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the memory block MEM\\[19\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[19\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the memory block MEM\\[20\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[20\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the memory block MEM\\[21\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[21\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the memory block MEM\\[22\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[22\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the memory block MEM\\[23\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[23\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the memory block MEM\\[24\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[24\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the memory block MEM\\[25\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[25\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the memory block MEM\\[26\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[26\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the memory block MEM\\[27\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[27\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the memory block MEM\\[28\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[28\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the memory block MEM\\[29\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[29\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the memory block MEM\\[30\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[30\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the memory block MEM\\[31\\] on or off when in System ON mode."]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the memory block MEM\\[31\\] on or off when in System ON mode."]
            #[inline(always)]
            pub fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Control {
            #[inline(always)]
            fn default() -> Control {
                Control(0)
            }
        }
        impl core::fmt::Debug for Control {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Control")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Control {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Control {
                    mem0: bool,
                    mem1: bool,
                    mem2: bool,
                    mem3: bool,
                    mem4: bool,
                    mem5: bool,
                    mem6: bool,
                    mem7: bool,
                    mem8: bool,
                    mem9: bool,
                    mem10: bool,
                    mem11: bool,
                    mem12: bool,
                    mem13: bool,
                    mem14: bool,
                    mem15: bool,
                    mem16: bool,
                    mem17: bool,
                    mem18: bool,
                    mem19: bool,
                    mem20: bool,
                    mem21: bool,
                    mem22: bool,
                    mem23: bool,
                    mem24: bool,
                    mem25: bool,
                    mem26: bool,
                    mem27: bool,
                    mem28: bool,
                    mem29: bool,
                    mem30: bool,
                    mem31: bool,
                }
                let proxy = Control {
                    mem0: self.mem0(),
                    mem1: self.mem1(),
                    mem2: self.mem2(),
                    mem3: self.mem3(),
                    mem4: self.mem4(),
                    mem5: self.mem5(),
                    mem6: self.mem6(),
                    mem7: self.mem7(),
                    mem8: self.mem8(),
                    mem9: self.mem9(),
                    mem10: self.mem10(),
                    mem11: self.mem11(),
                    mem12: self.mem12(),
                    mem13: self.mem13(),
                    mem14: self.mem14(),
                    mem15: self.mem15(),
                    mem16: self.mem16(),
                    mem17: self.mem17(),
                    mem18: self.mem18(),
                    mem19: self.mem19(),
                    mem20: self.mem20(),
                    mem21: self.mem21(),
                    mem22: self.mem22(),
                    mem23: self.mem23(),
                    mem24: self.mem24(),
                    mem25: self.mem25(),
                    mem26: self.mem26(),
                    mem27: self.mem27(),
                    mem28: self.mem28(),
                    mem29: self.mem29(),
                    mem30: self.mem30(),
                    mem31: self.mem31(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: RAM retention for RAM \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ret(pub u32);
        impl Ret {
            #[doc = "Keep the RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ret {
            #[inline(always)]
            fn default() -> Ret {
                Ret(0)
            }
        }
        impl core::fmt::Debug for Ret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ret")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ret {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ret {
                    mem0: bool,
                    mem1: bool,
                    mem2: bool,
                    mem3: bool,
                    mem4: bool,
                    mem5: bool,
                    mem6: bool,
                    mem7: bool,
                    mem8: bool,
                    mem9: bool,
                    mem10: bool,
                    mem11: bool,
                    mem12: bool,
                    mem13: bool,
                    mem14: bool,
                    mem15: bool,
                    mem16: bool,
                    mem17: bool,
                    mem18: bool,
                    mem19: bool,
                    mem20: bool,
                    mem21: bool,
                    mem22: bool,
                    mem23: bool,
                    mem24: bool,
                    mem25: bool,
                    mem26: bool,
                    mem27: bool,
                    mem28: bool,
                    mem29: bool,
                    mem30: bool,
                    mem31: bool,
                }
                let proxy = Ret {
                    mem0: self.mem0(),
                    mem1: self.mem1(),
                    mem2: self.mem2(),
                    mem3: self.mem3(),
                    mem4: self.mem4(),
                    mem5: self.mem5(),
                    mem6: self.mem6(),
                    mem7: self.mem7(),
                    mem8: self.mem8(),
                    mem9: self.mem9(),
                    mem10: self.mem10(),
                    mem11: self.mem11(),
                    mem12: self.mem12(),
                    mem13: self.mem13(),
                    mem14: self.mem14(),
                    mem15: self.mem15(),
                    mem16: self.mem16(),
                    mem17: self.mem17(),
                    mem18: self.mem18(),
                    mem19: self.mem19(),
                    mem20: self.mem20(),
                    mem21: self.mem21(),
                    mem22: self.mem22(),
                    mem23: self.mem23(),
                    mem24: self.mem24(),
                    mem25: self.mem25(),
                    mem26: self.mem26(),
                    mem27: self.mem27(),
                    mem28: self.mem28(),
                    mem29: self.mem29(),
                    mem30: self.mem30(),
                    mem31: self.mem31(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: RAM retention for the second bank in the RAM block"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ret2(pub u32);
        impl Ret2 {
            #[doc = "Keep the second bank in RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[0\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[1\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[2\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[3\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[4\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[5\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[6\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[7\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[8\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[9\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[10\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[11\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[12\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[13\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[14\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[15\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[16\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[17\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[18\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[19\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[20\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[21\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[22\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[23\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[24\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[25\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[26\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[27\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[28\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[29\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[30\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Keep the second bank in RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub const fn mem31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Keep the second bank in RAM block MEM\\[31\\] retained when in System OFF mode."]
            #[inline(always)]
            pub fn set_mem31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Ret2 {
            #[inline(always)]
            fn default() -> Ret2 {
                Ret2(0)
            }
        }
        impl core::fmt::Debug for Ret2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ret2")
                    .field("mem0", &self.mem0())
                    .field("mem1", &self.mem1())
                    .field("mem2", &self.mem2())
                    .field("mem3", &self.mem3())
                    .field("mem4", &self.mem4())
                    .field("mem5", &self.mem5())
                    .field("mem6", &self.mem6())
                    .field("mem7", &self.mem7())
                    .field("mem8", &self.mem8())
                    .field("mem9", &self.mem9())
                    .field("mem10", &self.mem10())
                    .field("mem11", &self.mem11())
                    .field("mem12", &self.mem12())
                    .field("mem13", &self.mem13())
                    .field("mem14", &self.mem14())
                    .field("mem15", &self.mem15())
                    .field("mem16", &self.mem16())
                    .field("mem17", &self.mem17())
                    .field("mem18", &self.mem18())
                    .field("mem19", &self.mem19())
                    .field("mem20", &self.mem20())
                    .field("mem21", &self.mem21())
                    .field("mem22", &self.mem22())
                    .field("mem23", &self.mem23())
                    .field("mem24", &self.mem24())
                    .field("mem25", &self.mem25())
                    .field("mem26", &self.mem26())
                    .field("mem27", &self.mem27())
                    .field("mem28", &self.mem28())
                    .field("mem29", &self.mem29())
                    .field("mem30", &self.mem30())
                    .field("mem31", &self.mem31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ret2 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ret2 {
                    mem0: bool,
                    mem1: bool,
                    mem2: bool,
                    mem3: bool,
                    mem4: bool,
                    mem5: bool,
                    mem6: bool,
                    mem7: bool,
                    mem8: bool,
                    mem9: bool,
                    mem10: bool,
                    mem11: bool,
                    mem12: bool,
                    mem13: bool,
                    mem14: bool,
                    mem15: bool,
                    mem16: bool,
                    mem17: bool,
                    mem18: bool,
                    mem19: bool,
                    mem20: bool,
                    mem21: bool,
                    mem22: bool,
                    mem23: bool,
                    mem24: bool,
                    mem25: bool,
                    mem26: bool,
                    mem27: bool,
                    mem28: bool,
                    mem29: bool,
                    mem30: bool,
                    mem31: bool,
                }
                let proxy = Ret2 {
                    mem0: self.mem0(),
                    mem1: self.mem1(),
                    mem2: self.mem2(),
                    mem3: self.mem3(),
                    mem4: self.mem4(),
                    mem5: self.mem5(),
                    mem6: self.mem6(),
                    mem7: self.mem7(),
                    mem8: self.mem8(),
                    mem9: self.mem9(),
                    mem10: self.mem10(),
                    mem11: self.mem11(),
                    mem12: self.mem12(),
                    mem13: self.mem13(),
                    mem14: self.mem14(),
                    mem15: self.mem15(),
                    mem16: self.mem16(),
                    mem17: self.mem17(),
                    mem18: self.mem18(),
                    mem19: self.mem19(),
                    mem20: self.mem20(),
                    mem21: self.mem21(),
                    mem22: self.mem22(),
                    mem23: self.mem23(),
                    mem24: self.mem24(),
                    mem25: self.mem25(),
                    mem26: self.mem26(),
                    mem27: self.mem27(),
                    mem28: self.mem28(),
                    mem29: self.mem29(),
                    mem30: self.mem30(),
                    mem31: self.mem31(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod mpc {
    #[doc = "Global slave master port connection information"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Globalslave {
        ptr: *mut u8,
    }
    unsafe impl Send for Globalslave {}
    unsafe impl Sync for Globalslave {}
    impl Globalslave {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Global slave connection information for master port"]
        #[inline(always)]
        pub const fn masterport(
            self,
        ) -> crate::common::Reg<regs::GlobalslaveMasterport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Lock global slave registers"]
        #[inline(always)]
        pub const fn lock(self) -> crate::common::Reg<regs::Lock, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Memory Access Error status registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Memaccerr {
        ptr: *mut u8,
    }
    unsafe impl Send for Memaccerr {}
    unsafe impl Sync for Memaccerr {}
    impl Memaccerr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Target Address of Memory Access Error. Register content won't be changed as long as MEMACCERR event is active."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Access information for the transaction that triggered a memory access error. Register content won't be changed as long as MEMACCERR event is active."]
        #[inline(always)]
        pub const fn info(self) -> crate::common::Reg<regs::Info, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Memory Privilege Controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Mpc {
        ptr: *mut u8,
    }
    unsafe impl Send for Mpc {}
    unsafe impl Sync for Mpc {}
    impl Mpc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Memory Access Error event"]
        #[inline(always)]
        pub const fn events_memaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Memory Access Error status registers"]
        #[inline(always)]
        pub const fn memaccerr(self) -> Memaccerr {
            unsafe { Memaccerr::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Global slave master port connection information"]
        #[inline(always)]
        pub const fn globalslave(self) -> Globalslave {
            unsafe { Globalslave::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Memory region to slave decoding table"]
        #[inline(always)]
        pub const fn region(self, n: usize) -> Region {
            assert!(n < 8usize);
            unsafe { Region::from_ptr(self.ptr.add(0x0600usize + n * 16usize) as _) }
        }
        #[doc = "Special privilege tables"]
        #[inline(always)]
        pub const fn override_(self, n: usize) -> Override {
            assert!(n < 7usize);
            unsafe { Override::from_ptr(self.ptr.add(0x0800usize + n * 32usize) as _) }
        }
    }
    #[doc = "Special privilege tables"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Override {
        ptr: *mut u8,
    }
    unsafe impl Send for Override {}
    unsafe impl Sync for Override {}
    impl Override {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Override region n Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::OverrideConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Override region n Start Address"]
        #[inline(always)]
        pub const fn startaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Override region n End Address"]
        #[inline(always)]
        pub const fn endaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Permission settings for override region n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Masks permission setting fields from register OVERRIDE.PERM"]
        #[inline(always)]
        pub const fn permmask(self) -> crate::common::Reg<regs::Permmask, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Description cluster: Owner for override region"]
        #[inline(always)]
        pub const fn owner(self) -> crate::common::Reg<regs::Owner, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Description cluster: Override region n local master enable"]
        #[inline(always)]
        pub const fn masterport(
            self,
        ) -> crate::common::Reg<regs::OverrideMasterport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Memory region to slave decoding table"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Region {
        ptr: *mut u8,
    }
    unsafe impl Send for Region {}
    unsafe impl Sync for Region {}
    impl Region {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Slave region n Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RegionConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Region n start address"]
        #[inline(always)]
        pub const fn startaddr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Select which bits of the incoming address are compared against the STARTADDR"]
        #[inline(always)]
        pub const fn addrmask(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Region n local master enable"]
        #[inline(always)]
        pub const fn masterport(
            self,
        ) -> crate::common::Reg<regs::RegionMasterport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Global slave connection information for master port"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlobalslaveMasterport(pub u32);
        impl GlobalslaveMasterport {
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub const fn connection_14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Global slave connection information for master port"]
            #[inline(always)]
            pub fn set_connection_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for GlobalslaveMasterport {
            #[inline(always)]
            fn default() -> GlobalslaveMasterport {
                GlobalslaveMasterport(0)
            }
        }
        impl core::fmt::Debug for GlobalslaveMasterport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlobalslaveMasterport")
                    .field("connection_0", &self.connection_0())
                    .field("connection_1", &self.connection_1())
                    .field("connection_2", &self.connection_2())
                    .field("connection_3", &self.connection_3())
                    .field("connection_4", &self.connection_4())
                    .field("connection_5", &self.connection_5())
                    .field("connection_6", &self.connection_6())
                    .field("connection_7", &self.connection_7())
                    .field("connection_8", &self.connection_8())
                    .field("connection_9", &self.connection_9())
                    .field("connection_10", &self.connection_10())
                    .field("connection_11", &self.connection_11())
                    .field("connection_12", &self.connection_12())
                    .field("connection_13", &self.connection_13())
                    .field("connection_14", &self.connection_14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlobalslaveMasterport {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GlobalslaveMasterport {
                    connection_0: bool,
                    connection_1: bool,
                    connection_2: bool,
                    connection_3: bool,
                    connection_4: bool,
                    connection_5: bool,
                    connection_6: bool,
                    connection_7: bool,
                    connection_8: bool,
                    connection_9: bool,
                    connection_10: bool,
                    connection_11: bool,
                    connection_12: bool,
                    connection_13: bool,
                    connection_14: bool,
                }
                let proxy = GlobalslaveMasterport {
                    connection_0: self.connection_0(),
                    connection_1: self.connection_1(),
                    connection_2: self.connection_2(),
                    connection_3: self.connection_3(),
                    connection_4: self.connection_4(),
                    connection_5: self.connection_5(),
                    connection_6: self.connection_6(),
                    connection_7: self.connection_7(),
                    connection_8: self.connection_8(),
                    connection_9: self.connection_9(),
                    connection_10: self.connection_10(),
                    connection_11: self.connection_11(),
                    connection_12: self.connection_12(),
                    connection_13: self.connection_13(),
                    connection_14: self.connection_14(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Access information for the transaction that triggered a memory access error. Register content won't be changed as long as MEMACCERR event is active."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Info(pub u32);
        impl Info {
            #[doc = "Owner identifier of the erroneous access"]
            #[inline(always)]
            pub const fn ownerid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Owner identifier of the erroneous access"]
            #[inline(always)]
            pub fn set_ownerid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Master port where erroneous access is detected"]
            #[inline(always)]
            pub const fn masterport(&self) -> u8 {
                let val = (self.0 >> 4usize) & 0x1f;
                val as u8
            }
            #[doc = "Master port where erroneous access is detected"]
            #[inline(always)]
            pub fn set_masterport(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 4usize)) | (((val as u32) & 0x1f) << 4usize);
            }
            #[doc = "Read bit of bus access"]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Read bit of bus access"]
            #[inline(always)]
            pub fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write bit of bus access"]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Write bit of bus access"]
            #[inline(always)]
            pub fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Execute bit of bus access"]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Execute bit of bus access"]
            #[inline(always)]
            pub fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Secure bit of bus access"]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Secure bit of bus access"]
            #[inline(always)]
            pub fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Source of memory access error"]
            #[inline(always)]
            pub const fn errorsource(&self) -> super::vals::Errorsource {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Errorsource::from_bits(val as u8)
            }
            #[doc = "Source of memory access error"]
            #[inline(always)]
            pub fn set_errorsource(&mut self, val: super::vals::Errorsource) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for Info {
            #[inline(always)]
            fn default() -> Info {
                Info(0)
            }
        }
        impl core::fmt::Debug for Info {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Info")
                    .field("ownerid", &self.ownerid())
                    .field("masterport", &self.masterport())
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("errorsource", &self.errorsource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Info {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Info {
                    ownerid: u8,
                    masterport: u8,
                    read: bool,
                    write: bool,
                    execute: bool,
                    secure: bool,
                    errorsource: super::vals::Errorsource,
                }
                let proxy = Info {
                    ownerid: self.ownerid(),
                    masterport: self.masterport(),
                    read: self.read(),
                    write: self.write(),
                    execute: self.execute(),
                    secure: self.secure(),
                    errorsource: self.errorsource(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event MEMACCERR"]
            #[inline(always)]
            pub const fn memaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event MEMACCERR"]
            #[inline(always)]
            pub fn set_memaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("memaccerr", &self.memaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    memaccerr: bool,
                }
                let proxy = Int {
                    memaccerr: self.memaccerr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Lock global slave registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lock(pub u32);
        impl Lock {
            #[doc = "Enable lock"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Lock {
            #[inline(always)]
            fn default() -> Lock {
                Lock(0)
            }
        }
        impl core::fmt::Debug for Lock {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lock").field("lock", &self.lock()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lock {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lock {
                    lock: bool,
                }
                let proxy = Lock { lock: self.lock() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Override region n Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OverrideConfig(pub u32);
        impl OverrideConfig {
            #[doc = "Target slave number for override region n accesses. Slave number 0 is reserved for default slave"]
            #[inline(always)]
            pub const fn slavenumber(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Target slave number for override region n accesses. Slave number 0 is reserved for default slave"]
            #[inline(always)]
            pub fn set_slavenumber(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Lock Override region n"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Lock Override region n"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable Override region n"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable Override region n"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Secure mask enable for Override region n"]
            #[inline(always)]
            pub const fn securemask(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Secure mask enable for Override region n"]
            #[inline(always)]
            pub fn set_securemask(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
        }
        impl Default for OverrideConfig {
            #[inline(always)]
            fn default() -> OverrideConfig {
                OverrideConfig(0)
            }
        }
        impl core::fmt::Debug for OverrideConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OverrideConfig")
                    .field("slavenumber", &self.slavenumber())
                    .field("lock", &self.lock())
                    .field("enable", &self.enable())
                    .field("securemask", &self.securemask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OverrideConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct OverrideConfig {
                    slavenumber: u8,
                    lock: bool,
                    enable: bool,
                    securemask: bool,
                }
                let proxy = OverrideConfig {
                    slavenumber: self.slavenumber(),
                    lock: self.lock(),
                    enable: self.enable(),
                    securemask: self.securemask(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Override region n local master enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct OverrideMasterport(pub u32);
        impl OverrideMasterport {
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub const fn enable14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable override"]
            #[inline(always)]
            pub fn set_enable14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for OverrideMasterport {
            #[inline(always)]
            fn default() -> OverrideMasterport {
                OverrideMasterport(0)
            }
        }
        impl core::fmt::Debug for OverrideMasterport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("OverrideMasterport")
                    .field("enable0", &self.enable0())
                    .field("enable1", &self.enable1())
                    .field("enable2", &self.enable2())
                    .field("enable3", &self.enable3())
                    .field("enable4", &self.enable4())
                    .field("enable5", &self.enable5())
                    .field("enable6", &self.enable6())
                    .field("enable7", &self.enable7())
                    .field("enable8", &self.enable8())
                    .field("enable9", &self.enable9())
                    .field("enable10", &self.enable10())
                    .field("enable11", &self.enable11())
                    .field("enable12", &self.enable12())
                    .field("enable13", &self.enable13())
                    .field("enable14", &self.enable14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for OverrideMasterport {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct OverrideMasterport {
                    enable0: bool,
                    enable1: bool,
                    enable2: bool,
                    enable3: bool,
                    enable4: bool,
                    enable5: bool,
                    enable6: bool,
                    enable7: bool,
                    enable8: bool,
                    enable9: bool,
                    enable10: bool,
                    enable11: bool,
                    enable12: bool,
                    enable13: bool,
                    enable14: bool,
                }
                let proxy = OverrideMasterport {
                    enable0: self.enable0(),
                    enable1: self.enable1(),
                    enable2: self.enable2(),
                    enable3: self.enable3(),
                    enable4: self.enable4(),
                    enable5: self.enable5(),
                    enable6: self.enable6(),
                    enable7: self.enable7(),
                    enable8: self.enable8(),
                    enable9: self.enable9(),
                    enable10: self.enable10(),
                    enable11: self.enable11(),
                    enable12: self.enable12(),
                    enable13: self.enable13(),
                    enable14: self.enable14(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Owner for override region"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Owner(pub u32);
        impl Owner {
            #[doc = "owner identifier for override region n"]
            #[inline(always)]
            pub const fn ownerid(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "owner identifier for override region n"]
            #[inline(always)]
            pub fn set_ownerid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Owner {
            #[inline(always)]
            fn default() -> Owner {
                Owner(0)
            }
        }
        impl core::fmt::Debug for Owner {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Owner")
                    .field("ownerid", &self.ownerid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Owner {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Owner {
                    ownerid: u8,
                }
                let proxy = Owner {
                    ownerid: self.ownerid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Permission settings for override region n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Security mapping"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Security mapping"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Perm {
                    read: bool,
                    write: bool,
                    execute: bool,
                    secattr: bool,
                }
                let proxy = Perm {
                    read: self.read(),
                    write: self.write(),
                    execute: self.execute(),
                    secattr: self.secattr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Masks permission setting fields from register OVERRIDE.PERM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Permmask(pub u32);
        impl Permmask {
            #[doc = "Read mask"]
            #[inline(always)]
            pub const fn read(&self) -> super::vals::PermmaskRead {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::PermmaskRead::from_bits(val as u8)
            }
            #[doc = "Read mask"]
            #[inline(always)]
            pub fn set_read(&mut self, val: super::vals::PermmaskRead) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Write mask"]
            #[inline(always)]
            pub const fn write(&self) -> super::vals::PermmaskWrite {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::PermmaskWrite::from_bits(val as u8)
            }
            #[doc = "Write mask"]
            #[inline(always)]
            pub fn set_write(&mut self, val: super::vals::PermmaskWrite) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute mask"]
            #[inline(always)]
            pub const fn execute(&self) -> super::vals::PermmaskExecute {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::PermmaskExecute::from_bits(val as u8)
            }
            #[doc = "Execute mask"]
            #[inline(always)]
            pub fn set_execute(&mut self, val: super::vals::PermmaskExecute) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Security mapping mask"]
            #[inline(always)]
            pub const fn secattr(&self) -> super::vals::PermmaskSecattr {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::PermmaskSecattr::from_bits(val as u8)
            }
            #[doc = "Security mapping mask"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: super::vals::PermmaskSecattr) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Permmask {
            #[inline(always)]
            fn default() -> Permmask {
                Permmask(0)
            }
        }
        impl core::fmt::Debug for Permmask {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Permmask")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Permmask {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Permmask {
                    read: super::vals::PermmaskRead,
                    write: super::vals::PermmaskWrite,
                    execute: super::vals::PermmaskExecute,
                    secattr: super::vals::PermmaskSecattr,
                }
                let proxy = Permmask {
                    read: self.read(),
                    write: self.write(),
                    execute: self.execute(),
                    secattr: self.secattr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Slave region n Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionConfig(pub u32);
        impl RegionConfig {
            #[doc = "Target slave number for region n accesses. Slave number 0 is reserved for default slave"]
            #[inline(always)]
            pub const fn slavenumber(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Target slave number for region n accesses. Slave number 0 is reserved for default slave"]
            #[inline(always)]
            pub fn set_slavenumber(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Locks the region n setting"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Locks the region n setting"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Region n enable"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Region n enable"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Software execute"]
            #[inline(always)]
            pub fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Memory security mapping"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Memory security mapping"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Region owner identifier."]
            #[inline(always)]
            pub const fn ownerid(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Region owner identifier."]
            #[inline(always)]
            pub fn set_ownerid(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
        }
        impl Default for RegionConfig {
            #[inline(always)]
            fn default() -> RegionConfig {
                RegionConfig(0)
            }
        }
        impl core::fmt::Debug for RegionConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionConfig")
                    .field("slavenumber", &self.slavenumber())
                    .field("lock", &self.lock())
                    .field("enable", &self.enable())
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secattr", &self.secattr())
                    .field("ownerid", &self.ownerid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RegionConfig {
                    slavenumber: u8,
                    lock: bool,
                    enable: bool,
                    read: bool,
                    write: bool,
                    execute: bool,
                    secattr: bool,
                    ownerid: u8,
                }
                let proxy = RegionConfig {
                    slavenumber: self.slavenumber(),
                    lock: self.lock(),
                    enable: self.enable(),
                    read: self.read(),
                    write: self.write(),
                    execute: self.execute(),
                    secattr: self.secattr(),
                    ownerid: self.ownerid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Region n local master enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionMasterport(pub u32);
        impl RegionMasterport {
            #[doc = "Enable region n for master port 0"]
            #[inline(always)]
            pub const fn enable0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 0"]
            #[inline(always)]
            pub fn set_enable0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable region n for master port 1"]
            #[inline(always)]
            pub const fn enable1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 1"]
            #[inline(always)]
            pub fn set_enable1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable region n for master port 2"]
            #[inline(always)]
            pub const fn enable2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 2"]
            #[inline(always)]
            pub fn set_enable2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable region n for master port 3"]
            #[inline(always)]
            pub const fn enable3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 3"]
            #[inline(always)]
            pub fn set_enable3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable region n for master port 4"]
            #[inline(always)]
            pub const fn enable4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 4"]
            #[inline(always)]
            pub fn set_enable4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable region n for master port 5"]
            #[inline(always)]
            pub const fn enable5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 5"]
            #[inline(always)]
            pub fn set_enable5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable region n for master port 6"]
            #[inline(always)]
            pub const fn enable6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 6"]
            #[inline(always)]
            pub fn set_enable6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable region n for master port 7"]
            #[inline(always)]
            pub const fn enable7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 7"]
            #[inline(always)]
            pub fn set_enable7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable region n for master port 8"]
            #[inline(always)]
            pub const fn enable8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 8"]
            #[inline(always)]
            pub fn set_enable8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable region n for master port 9"]
            #[inline(always)]
            pub const fn enable9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 9"]
            #[inline(always)]
            pub fn set_enable9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable region n for master port 10"]
            #[inline(always)]
            pub const fn enable10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 10"]
            #[inline(always)]
            pub fn set_enable10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable region n for master port 11"]
            #[inline(always)]
            pub const fn enable11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 11"]
            #[inline(always)]
            pub fn set_enable11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable region n for master port 12"]
            #[inline(always)]
            pub const fn enable12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 12"]
            #[inline(always)]
            pub fn set_enable12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable region n for master port 13"]
            #[inline(always)]
            pub const fn enable13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 13"]
            #[inline(always)]
            pub fn set_enable13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable region n for master port 14"]
            #[inline(always)]
            pub const fn enable14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable region n for master port 14"]
            #[inline(always)]
            pub fn set_enable14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for RegionMasterport {
            #[inline(always)]
            fn default() -> RegionMasterport {
                RegionMasterport(0)
            }
        }
        impl core::fmt::Debug for RegionMasterport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionMasterport")
                    .field("enable0", &self.enable0())
                    .field("enable1", &self.enable1())
                    .field("enable2", &self.enable2())
                    .field("enable3", &self.enable3())
                    .field("enable4", &self.enable4())
                    .field("enable5", &self.enable5())
                    .field("enable6", &self.enable6())
                    .field("enable7", &self.enable7())
                    .field("enable8", &self.enable8())
                    .field("enable9", &self.enable9())
                    .field("enable10", &self.enable10())
                    .field("enable11", &self.enable11())
                    .field("enable12", &self.enable12())
                    .field("enable13", &self.enable13())
                    .field("enable14", &self.enable14())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionMasterport {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RegionMasterport {
                    enable0: bool,
                    enable1: bool,
                    enable2: bool,
                    enable3: bool,
                    enable4: bool,
                    enable5: bool,
                    enable6: bool,
                    enable7: bool,
                    enable8: bool,
                    enable9: bool,
                    enable10: bool,
                    enable11: bool,
                    enable12: bool,
                    enable13: bool,
                    enable14: bool,
                }
                let proxy = RegionMasterport {
                    enable0: self.enable0(),
                    enable1: self.enable1(),
                    enable2: self.enable2(),
                    enable3: self.enable3(),
                    enable4: self.enable4(),
                    enable5: self.enable5(),
                    enable6: self.enable6(),
                    enable7: self.enable7(),
                    enable8: self.enable8(),
                    enable9: self.enable9(),
                    enable10: self.enable10(),
                    enable11: self.enable11(),
                    enable12: self.enable12(),
                    enable13: self.enable13(),
                    enable14: self.enable14(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Errorsource {
            #[doc = "Error was triggered by an AXI slave"]
            SLAVE = 0x0,
            #[doc = "Error was triggered by MPC module"]
            MPC = 0x01,
        }
        impl Errorsource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Errorsource {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Errorsource {
            #[inline(always)]
            fn from(val: u8) -> Errorsource {
                Errorsource::from_bits(val)
            }
        }
        impl From<Errorsource> for u8 {
            #[inline(always)]
            fn from(val: Errorsource) -> u8 {
                Errorsource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskExecute {
            #[doc = "Permission setting EXECUTE in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting EXECUTE in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskExecute {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskExecute {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskExecute {
            #[inline(always)]
            fn from(val: u8) -> PermmaskExecute {
                PermmaskExecute::from_bits(val)
            }
        }
        impl From<PermmaskExecute> for u8 {
            #[inline(always)]
            fn from(val: PermmaskExecute) -> u8 {
                PermmaskExecute::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskRead {
            #[doc = "Permission setting READ in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting READ in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskRead {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskRead {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskRead {
            #[inline(always)]
            fn from(val: u8) -> PermmaskRead {
                PermmaskRead::from_bits(val)
            }
        }
        impl From<PermmaskRead> for u8 {
            #[inline(always)]
            fn from(val: PermmaskRead) -> u8 {
                PermmaskRead::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskSecattr {
            #[doc = "Permission setting SECATTR in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting SECATTR in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskSecattr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskSecattr {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskSecattr {
            #[inline(always)]
            fn from(val: u8) -> PermmaskSecattr {
                PermmaskSecattr::from_bits(val)
            }
        }
        impl From<PermmaskSecattr> for u8 {
            #[inline(always)]
            fn from(val: PermmaskSecattr) -> u8 {
                PermmaskSecattr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PermmaskWrite {
            #[doc = "Permission setting WRITE in OVERRIDE register will not be applied"]
            MASKED = 0x0,
            #[doc = "Permission setting WRITE in OVERRIDE register will be applied"]
            UN_MASKED = 0x01,
        }
        impl PermmaskWrite {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PermmaskWrite {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PermmaskWrite {
            #[inline(always)]
            fn from(val: u8) -> PermmaskWrite {
                PermmaskWrite::from_bits(val)
            }
        }
        impl From<PermmaskWrite> for u8 {
            #[inline(always)]
            fn from(val: PermmaskWrite) -> u8 {
                PermmaskWrite::to_bits(val)
            }
        }
    }
}
pub mod nfct {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Framestatus {
        ptr: *mut u8,
    }
    unsafe impl Send for Framestatus {}
    unsafe impl Sync for Framestatus {}
    impl Framestatus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Result of last incoming frame"]
        #[inline(always)]
        pub const fn rx(self) -> crate::common::Reg<regs::Rx, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfcid1 {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfcid1 {}
    unsafe impl Sync for Nfcid1 {}
    impl Nfcid1 {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"]
        #[inline(always)]
        pub const fn last(self) -> crate::common::Reg<regs::Last, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Second last NFCID1 part (7 or 10 bytes ID)"]
        #[inline(always)]
        pub const fn secondlast(self) -> crate::common::Reg<regs::Secondlast, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Third last NFCID1 part (10 bytes ID)"]
        #[inline(always)]
        pub const fn thirdlast(self) -> crate::common::Reg<regs::Thirdlast, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "NFC-A compatible radio NFC-A compatible radio 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Nfct {
        ptr: *mut u8,
    }
    unsafe impl Send for Nfct {}
    unsafe impl Sync for Nfct {}
    impl Nfct {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Activate NFCT peripheral for incoming and outgoing frames, change state to activated"]
        #[inline(always)]
        pub const fn tasks_activate(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Disable NFCT peripheral"]
        #[inline(always)]
        pub const fn tasks_disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Enable NFC sense field mode, change state to sense mode"]
        #[inline(always)]
        pub const fn tasks_sense(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Start transmission of an outgoing frame, change state to transmit"]
        #[inline(always)]
        pub const fn tasks_starttx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Stops an issued transmission of a frame"]
        #[inline(always)]
        pub const fn tasks_stoptx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Initializes the EasyDMA for receive."]
        #[inline(always)]
        pub const fn tasks_enablerxdata(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Force state machine to IDLE state"]
        #[inline(always)]
        pub const fn tasks_goidle(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Force state machine to SLEEP_A state"]
        #[inline(always)]
        pub const fn tasks_gosleep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACTIVATE"]
        #[inline(always)]
        pub const fn subscribe_activate(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task DISABLE"]
        #[inline(always)]
        pub const fn subscribe_disable(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SENSE"]
        #[inline(always)]
        pub const fn subscribe_sense(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task STARTTX"]
        #[inline(always)]
        pub const fn subscribe_starttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task STOPTX"]
        #[inline(always)]
        pub const fn subscribe_stoptx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task ENABLERXDATA"]
        #[inline(always)]
        pub const fn subscribe_enablerxdata(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for task GOIDLE"]
        #[inline(always)]
        pub const fn subscribe_goidle(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task GOSLEEP"]
        #[inline(always)]
        pub const fn subscribe_gosleep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "The NFCT peripheral is ready to receive and send frames"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Remote NFC field detected"]
        #[inline(always)]
        pub const fn events_fielddetected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Remote NFC field lost"]
        #[inline(always)]
        pub const fn events_fieldlost(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Marks the start of the first symbol of a transmitted frame"]
        #[inline(always)]
        pub const fn events_txframestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Marks the end of the last transmitted on-air symbol of a frame"]
        #[inline(always)]
        pub const fn events_txframeend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Marks the end of the first symbol of a received frame"]
        #[inline(always)]
        pub const fn events_rxframestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Received data has been checked (CRC, parity) and transferred to RAM, and EasyDMA has ended accessing the RX buffer"]
        #[inline(always)]
        pub const fn events_rxframeend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "NFC error reported. The ERRORSTATUS register contains details on the source of the error."]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "NFC RX frame error reported. The FRAMESTATUS.RX register contains details on the source of the error."]
        #[inline(always)]
        pub const fn events_rxerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "RX buffer (as defined by PACKETPTR and MAXLEN) in Data RAM full."]
        #[inline(always)]
        pub const fn events_endrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Transmission of data in RAM has ended, and EasyDMA has ended accessing the TX buffer"]
        #[inline(always)]
        pub const fn events_endtx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Auto collision resolution process has started"]
        #[inline(always)]
        pub const fn events_autocolresstarted(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "NFC auto collision resolution error reported."]
        #[inline(always)]
        pub const fn events_collision(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0148usize) as _) }
        }
        #[doc = "NFC auto collision resolution successfully completed"]
        #[inline(always)]
        pub const fn events_selected(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "EasyDMA is ready to receive or send frames."]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0150usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event FIELDDETECTED"]
        #[inline(always)]
        pub const fn publish_fielddetected(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event FIELDLOST"]
        #[inline(always)]
        pub const fn publish_fieldlost(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event TXFRAMESTART"]
        #[inline(always)]
        pub const fn publish_txframestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event TXFRAMEEND"]
        #[inline(always)]
        pub const fn publish_txframeend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event RXFRAMESTART"]
        #[inline(always)]
        pub const fn publish_rxframestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event RXFRAMEEND"]
        #[inline(always)]
        pub const fn publish_rxframeend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event RXERROR"]
        #[inline(always)]
        pub const fn publish_rxerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a8usize) as _) }
        }
        #[doc = "Publish configuration for event ENDRX"]
        #[inline(always)]
        pub const fn publish_endrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01acusize) as _) }
        }
        #[doc = "Publish configuration for event ENDTX"]
        #[inline(always)]
        pub const fn publish_endtx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for event AUTOCOLRESSTARTED"]
        #[inline(always)]
        pub const fn publish_autocolresstarted(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "Publish configuration for event COLLISION"]
        #[inline(always)]
        pub const fn publish_collision(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c8usize) as _) }
        }
        #[doc = "Publish configuration for event SELECTED"]
        #[inline(always)]
        pub const fn publish_selected(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01d0usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "NFC Error Status register"]
        #[inline(always)]
        pub const fn errorstatus(self) -> crate::common::Reg<regs::Errorstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn framestatus(self) -> Framestatus {
            unsafe { Framestatus::from_ptr(self.ptr.add(0x040cusize) as _) }
        }
        #[doc = "Current operating state of NFC tag"]
        #[inline(always)]
        pub const fn nfctagstate(self) -> crate::common::Reg<regs::Nfctagstate, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Sleep state during automatic collision resolution"]
        #[inline(always)]
        pub const fn sleepstate(self) -> crate::common::Reg<regs::Sleepstate, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0420usize) as _) }
        }
        #[doc = "Indicates the presence or not of a valid field"]
        #[inline(always)]
        pub const fn fieldpresent(
            self,
        ) -> crate::common::Reg<regs::Fieldpresent, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x043cusize) as _) }
        }
        #[doc = "Minimum frame delay"]
        #[inline(always)]
        pub const fn framedelaymin(
            self,
        ) -> crate::common::Reg<regs::Framedelaymin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Maximum frame delay"]
        #[inline(always)]
        pub const fn framedelaymax(
            self,
        ) -> crate::common::Reg<regs::Framedelaymax, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Configuration register for the Frame Delay Timer"]
        #[inline(always)]
        pub const fn framedelaymode(
            self,
        ) -> crate::common::Reg<regs::Framedelaymode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Packet pointer for TXD and RXD data storage in Data RAM"]
        #[inline(always)]
        pub const fn packetptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
        #[inline(always)]
        pub const fn maxlen(self) -> crate::common::Reg<regs::Maxlen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0514usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn txd(self) -> Txd {
            unsafe { Txd::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rxd(self) -> Rxd {
            unsafe { Rxd::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Enables the modulation output to a GPIO pin which can be connected to a second external antenna."]
        #[inline(always)]
        pub const fn modulationctrl(
            self,
        ) -> crate::common::Reg<regs::Modulationctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x052cusize) as _) }
        }
        #[doc = "Pin select for Modulation control"]
        #[inline(always)]
        pub const fn modulationpsel(
            self,
        ) -> crate::common::Reg<regs::Modulationpsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Configure EasyDMA mode"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0550usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn nfcid1(self) -> Nfcid1 {
            unsafe { Nfcid1::from_ptr(self.ptr.add(0x0590usize) as _) }
        }
        #[doc = "Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated."]
        #[inline(always)]
        pub const fn autocolresconfig(
            self,
        ) -> crate::common::Reg<regs::Autocolresconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x059cusize) as _) }
        }
        #[doc = "NFC-A SENS_RES auto-response settings"]
        #[inline(always)]
        pub const fn sensres(self) -> crate::common::Reg<regs::Sensres, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05a0usize) as _) }
        }
        #[doc = "NFC-A SEL_RES auto-response settings"]
        #[inline(always)]
        pub const fn selres(self) -> crate::common::Reg<regs::Selres, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05a4usize) as _) }
        }
        #[doc = "NFC pad configuration"]
        #[inline(always)]
        pub const fn padconfig(self) -> crate::common::Reg<regs::Padconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x06d4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rxd {
        ptr: *mut u8,
    }
    unsafe impl Send for Rxd {}
    unsafe impl Sync for Rxd {}
    impl Rxd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration of incoming frames"]
        #[inline(always)]
        pub const fn frameconfig(
            self,
        ) -> crate::common::Reg<regs::RxdFrameconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Size of last incoming frame"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxdAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Txd {
        ptr: *mut u8,
    }
    unsafe impl Send for Txd {}
    unsafe impl Sync for Txd {}
    impl Txd {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration of outgoing frames"]
        #[inline(always)]
        pub const fn frameconfig(
            self,
        ) -> crate::common::Reg<regs::TxdFrameconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Size of outgoing frame"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxdAmount, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Controls the auto collision resolution function. This setting must be done before the NFCT peripheral is activated."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Autocolresconfig(pub u32);
        impl Autocolresconfig {
            #[doc = "Enables/disables auto collision resolution"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Enables/disables auto collision resolution"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Autocolresconfig {
            #[inline(always)]
            fn default() -> Autocolresconfig {
                Autocolresconfig(0)
            }
        }
        impl core::fmt::Debug for Autocolresconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Autocolresconfig")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Autocolresconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Autocolresconfig {
                    mode: super::vals::Mode,
                }
                let proxy = Autocolresconfig { mode: self.mode() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "NFC Error Status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorstatus(pub u32);
        impl Errorstatus {
            #[doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"]
            #[inline(always)]
            pub const fn framedelaytimeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "No STARTTX task triggered before expiration of the time set in FRAMEDELAYMAX"]
            #[inline(always)]
            pub fn set_framedelaytimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Errorstatus {
            #[inline(always)]
            fn default() -> Errorstatus {
                Errorstatus(0)
            }
        }
        impl core::fmt::Debug for Errorstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorstatus")
                    .field("framedelaytimeout", &self.framedelaytimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorstatus {
                    framedelaytimeout: bool,
                }
                let proxy = Errorstatus {
                    framedelaytimeout: self.framedelaytimeout(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates the presence or not of a valid field"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fieldpresent(pub u32);
        impl Fieldpresent {
            #[doc = "Indicates if a valid field is present. Available only in the activated state."]
            #[inline(always)]
            pub const fn fieldpresent(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if a valid field is present. Available only in the activated state."]
            #[inline(always)]
            pub fn set_fieldpresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates if the low level has locked to the field"]
            #[inline(always)]
            pub const fn lockdetect(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if the low level has locked to the field"]
            #[inline(always)]
            pub fn set_lockdetect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Fieldpresent {
            #[inline(always)]
            fn default() -> Fieldpresent {
                Fieldpresent(0)
            }
        }
        impl core::fmt::Debug for Fieldpresent {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fieldpresent")
                    .field("fieldpresent", &self.fieldpresent())
                    .field("lockdetect", &self.lockdetect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fieldpresent {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Fieldpresent {
                    fieldpresent: bool,
                    lockdetect: bool,
                }
                let proxy = Fieldpresent {
                    fieldpresent: self.fieldpresent(),
                    lockdetect: self.lockdetect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum frame delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymax(pub u32);
        impl Framedelaymax {
            #[doc = "Maximum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub const fn framedelaymax(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x000f_ffff;
                val as u32
            }
            #[doc = "Maximum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub fn set_framedelaymax(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x000f_ffff << 0usize)) | (((val as u32) & 0x000f_ffff) << 0usize);
            }
        }
        impl Default for Framedelaymax {
            #[inline(always)]
            fn default() -> Framedelaymax {
                Framedelaymax(0)
            }
        }
        impl core::fmt::Debug for Framedelaymax {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymax")
                    .field("framedelaymax", &self.framedelaymax())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymax {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Framedelaymax {
                    framedelaymax: u32,
                }
                let proxy = Framedelaymax {
                    framedelaymax: self.framedelaymax(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Minimum frame delay"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymin(pub u32);
        impl Framedelaymin {
            #[doc = "Minimum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub const fn framedelaymin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Minimum frame delay in number of 13.56 MHz clock cycles"]
            #[inline(always)]
            pub fn set_framedelaymin(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Framedelaymin {
            #[inline(always)]
            fn default() -> Framedelaymin {
                Framedelaymin(0)
            }
        }
        impl core::fmt::Debug for Framedelaymin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymin")
                    .field("framedelaymin", &self.framedelaymin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymin {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Framedelaymin {
                    framedelaymin: u16,
                }
                let proxy = Framedelaymin {
                    framedelaymin: self.framedelaymin(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration register for the Frame Delay Timer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Framedelaymode(pub u32);
        impl Framedelaymode {
            #[doc = "Configuration register for the Frame Delay Timer"]
            #[inline(always)]
            pub const fn framedelaymode(&self) -> super::vals::Framedelaymode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Framedelaymode::from_bits(val as u8)
            }
            #[doc = "Configuration register for the Frame Delay Timer"]
            #[inline(always)]
            pub fn set_framedelaymode(&mut self, val: super::vals::Framedelaymode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Framedelaymode {
            #[inline(always)]
            fn default() -> Framedelaymode {
                Framedelaymode(0)
            }
        }
        impl core::fmt::Debug for Framedelaymode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Framedelaymode")
                    .field("framedelaymode", &self.framedelaymode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Framedelaymode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Framedelaymode {
                    framedelaymode: super::vals::Framedelaymode,
                }
                let proxy = Framedelaymode {
                    framedelaymode: self.framedelaymode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event FIELDDETECTED"]
            #[inline(always)]
            pub const fn fielddetected(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FIELDDETECTED"]
            #[inline(always)]
            pub fn set_fielddetected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event FIELDLOST"]
            #[inline(always)]
            pub const fn fieldlost(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FIELDLOST"]
            #[inline(always)]
            pub fn set_fieldlost(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event TXFRAMESTART"]
            #[inline(always)]
            pub const fn txframestart(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXFRAMESTART"]
            #[inline(always)]
            pub fn set_txframestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event TXFRAMEEND"]
            #[inline(always)]
            pub const fn txframeend(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXFRAMEEND"]
            #[inline(always)]
            pub fn set_txframeend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event RXFRAMESTART"]
            #[inline(always)]
            pub const fn rxframestart(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXFRAMESTART"]
            #[inline(always)]
            pub fn set_rxframestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RXFRAMEEND"]
            #[inline(always)]
            pub const fn rxframeend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXFRAMEEND"]
            #[inline(always)]
            pub fn set_rxframeend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event RXERROR"]
            #[inline(always)]
            pub const fn rxerror(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXERROR"]
            #[inline(always)]
            pub fn set_rxerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[inline(always)]
            pub const fn endrx(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDRX"]
            #[inline(always)]
            pub fn set_endrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[inline(always)]
            pub const fn endtx(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ENDTX"]
            #[inline(always)]
            pub fn set_endtx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event AUTOCOLRESSTARTED"]
            #[inline(always)]
            pub const fn autocolresstarted(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event AUTOCOLRESSTARTED"]
            #[inline(always)]
            pub fn set_autocolresstarted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event COLLISION"]
            #[inline(always)]
            pub const fn collision(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COLLISION"]
            #[inline(always)]
            pub fn set_collision(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event SELECTED"]
            #[inline(always)]
            pub const fn selected(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SELECTED"]
            #[inline(always)]
            pub fn set_selected(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("fielddetected", &self.fielddetected())
                    .field("fieldlost", &self.fieldlost())
                    .field("txframestart", &self.txframestart())
                    .field("txframeend", &self.txframeend())
                    .field("rxframestart", &self.rxframestart())
                    .field("rxframeend", &self.rxframeend())
                    .field("error", &self.error())
                    .field("rxerror", &self.rxerror())
                    .field("endrx", &self.endrx())
                    .field("endtx", &self.endtx())
                    .field("autocolresstarted", &self.autocolresstarted())
                    .field("collision", &self.collision())
                    .field("selected", &self.selected())
                    .field("started", &self.started())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    ready: bool,
                    fielddetected: bool,
                    fieldlost: bool,
                    txframestart: bool,
                    txframeend: bool,
                    rxframestart: bool,
                    rxframeend: bool,
                    error: bool,
                    rxerror: bool,
                    endrx: bool,
                    endtx: bool,
                    autocolresstarted: bool,
                    collision: bool,
                    selected: bool,
                    started: bool,
                }
                let proxy = Int {
                    ready: self.ready(),
                    fielddetected: self.fielddetected(),
                    fieldlost: self.fieldlost(),
                    txframestart: self.txframestart(),
                    txframeend: self.txframeend(),
                    rxframestart: self.rxframestart(),
                    rxframeend: self.rxframeend(),
                    error: self.error(),
                    rxerror: self.rxerror(),
                    endrx: self.endrx(),
                    endtx: self.endtx(),
                    autocolresstarted: self.autocolresstarted(),
                    collision: self.collision(),
                    selected: self.selected(),
                    started: self.started(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Last NFCID1 part (4, 7 or 10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Last(pub u32);
        impl Last {
            #[doc = "NFCID1 byte Z (very last byte sent)"]
            #[inline(always)]
            pub const fn z(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Z (very last byte sent)"]
            #[inline(always)]
            pub fn set_z(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte Y"]
            #[inline(always)]
            pub const fn y(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Y"]
            #[inline(always)]
            pub fn set_y(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte X"]
            #[inline(always)]
            pub const fn x(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte X"]
            #[inline(always)]
            pub fn set_x(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "NFCID1 byte W"]
            #[inline(always)]
            pub const fn w(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte W"]
            #[inline(always)]
            pub fn set_w(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Last {
            #[inline(always)]
            fn default() -> Last {
                Last(0)
            }
        }
        impl core::fmt::Debug for Last {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Last")
                    .field("z", &self.z())
                    .field("y", &self.y())
                    .field("x", &self.x())
                    .field("w", &self.w())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Last {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Last {
                    z: u8,
                    y: u8,
                    x: u8,
                    w: u8,
                }
                let proxy = Last {
                    z: self.z(),
                    y: self.y(),
                    x: self.x(),
                    w: self.w(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxlen(pub u32);
        impl Maxlen {
            #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
            #[inline(always)]
            pub const fn maxlen(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Size of the RAM buffer allocated to TXD and RXD data storage each"]
            #[inline(always)]
            pub fn set_maxlen(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Maxlen {
            #[inline(always)]
            fn default() -> Maxlen {
                Maxlen(0)
            }
        }
        impl core::fmt::Debug for Maxlen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxlen")
                    .field("maxlen", &self.maxlen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxlen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxlen {
                    maxlen: u16,
                }
                let proxy = Maxlen {
                    maxlen: self.maxlen(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Enable low-power operation, or use low-latency"]
            #[inline(always)]
            pub const fn lpop(&self) -> super::vals::Lpop {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Lpop::from_bits(val as u8)
            }
            #[doc = "Enable low-power operation, or use low-latency"]
            #[inline(always)]
            pub fn set_lpop(&mut self, val: super::vals::Lpop) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("lpop", &self.lpop()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    lpop: super::vals::Lpop,
                }
                let proxy = Mode { lpop: self.lpop() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enables the modulation output to a GPIO pin which can be connected to a second external antenna."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Modulationctrl(pub u32);
        impl Modulationctrl {
            #[doc = "Configuration of modulation control."]
            #[inline(always)]
            pub const fn modulationctrl(&self) -> super::vals::Modulationctrl {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Modulationctrl::from_bits(val as u8)
            }
            #[doc = "Configuration of modulation control."]
            #[inline(always)]
            pub fn set_modulationctrl(&mut self, val: super::vals::Modulationctrl) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Modulationctrl {
            #[inline(always)]
            fn default() -> Modulationctrl {
                Modulationctrl(0)
            }
        }
        impl core::fmt::Debug for Modulationctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Modulationctrl")
                    .field("modulationctrl", &self.modulationctrl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Modulationctrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Modulationctrl {
                    modulationctrl: super::vals::Modulationctrl,
                }
                let proxy = Modulationctrl {
                    modulationctrl: self.modulationctrl(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Pin select for Modulation control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Modulationpsel(pub u32);
        impl Modulationpsel {
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn connect(&self) -> super::super::shared::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::super::shared::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub fn set_connect(&mut self, val: super::super::shared::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Modulationpsel {
            #[inline(always)]
            fn default() -> Modulationpsel {
                Modulationpsel(0)
            }
        }
        impl core::fmt::Debug for Modulationpsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Modulationpsel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Modulationpsel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Modulationpsel {
                    pin: u8,
                    port: u8,
                    connect: super::super::shared::vals::Connect,
                }
                let proxy = Modulationpsel {
                    pin: self.pin(),
                    port: self.port(),
                    connect: self.connect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Current operating state of NFC tag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nfctagstate(pub u32);
        impl Nfctagstate {
            #[doc = "NfcTag state"]
            #[inline(always)]
            pub const fn nfctagstate(&self) -> super::vals::Nfctagstate {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Nfctagstate::from_bits(val as u8)
            }
            #[doc = "NfcTag state"]
            #[inline(always)]
            pub fn set_nfctagstate(&mut self, val: super::vals::Nfctagstate) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Nfctagstate {
            #[inline(always)]
            fn default() -> Nfctagstate {
                Nfctagstate(0)
            }
        }
        impl core::fmt::Debug for Nfctagstate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nfctagstate")
                    .field("nfctagstate", &self.nfctagstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nfctagstate {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Nfctagstate {
                    nfctagstate: super::vals::Nfctagstate,
                }
                let proxy = Nfctagstate {
                    nfctagstate: self.nfctagstate(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "NFC pad configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Padconfig(pub u32);
        impl Padconfig {
            #[doc = "Enable NFC pads"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable NFC pads"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Padconfig {
            #[inline(always)]
            fn default() -> Padconfig {
                Padconfig(0)
            }
        }
        impl core::fmt::Debug for Padconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Padconfig")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Padconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Padconfig {
                    enable: bool,
                }
                let proxy = Padconfig {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Result of last incoming frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rx(pub u32);
        impl Rx {
            #[doc = "No valid end of frame (EoF) detected"]
            #[inline(always)]
            pub const fn crcerror(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "No valid end of frame (EoF) detected"]
            #[inline(always)]
            pub fn set_crcerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity status of received frame"]
            #[inline(always)]
            pub const fn paritystatus(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Parity status of received frame"]
            #[inline(always)]
            pub fn set_paritystatus(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Overrun detected"]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun detected"]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Rx {
            #[inline(always)]
            fn default() -> Rx {
                Rx(0)
            }
        }
        impl core::fmt::Debug for Rx {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rx")
                    .field("crcerror", &self.crcerror())
                    .field("paritystatus", &self.paritystatus())
                    .field("overrun", &self.overrun())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rx {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rx {
                    crcerror: bool,
                    paritystatus: bool,
                    overrun: bool,
                }
                let proxy = Rx {
                    crcerror: self.crcerror(),
                    paritystatus: self.paritystatus(),
                    overrun: self.overrun(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Size of last incoming frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdAmount(pub u32);
        impl RxdAmount {
            #[doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."]
            #[inline(always)]
            pub const fn rxdatabits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Number of bits in the last byte in the frame, if less than 8 (including CRC, but excluding parity and SoF/EoF framing)."]
            #[inline(always)]
            pub fn set_rxdatabits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"]
            #[inline(always)]
            pub const fn rxdatabytes(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x01ff;
                val as u16
            }
            #[doc = "Number of complete bytes received in the frame (including CRC, but excluding parity and SoF/EoF framing)"]
            #[inline(always)]
            pub fn set_rxdatabytes(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 3usize)) | (((val as u32) & 0x01ff) << 3usize);
            }
        }
        impl Default for RxdAmount {
            #[inline(always)]
            fn default() -> RxdAmount {
                RxdAmount(0)
            }
        }
        impl core::fmt::Debug for RxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdAmount")
                    .field("rxdatabits", &self.rxdatabits())
                    .field("rxdatabytes", &self.rxdatabytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxdAmount {
                    rxdatabits: u8,
                    rxdatabytes: u16,
                }
                let proxy = RxdAmount {
                    rxdatabits: self.rxdatabits(),
                    rxdatabytes: self.rxdatabytes(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of incoming frames"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxdFrameconfig(pub u32);
        impl RxdFrameconfig {
            #[doc = "Indicates if parity expected in RX frame"]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if parity expected in RX frame"]
            #[inline(always)]
            pub fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "SoF expected or not in RX frames"]
            #[inline(always)]
            pub const fn sof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "SoF expected or not in RX frames"]
            #[inline(always)]
            pub fn set_sof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CRC mode for incoming frames"]
            #[inline(always)]
            pub const fn crcmoderx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CRC mode for incoming frames"]
            #[inline(always)]
            pub fn set_crcmoderx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for RxdFrameconfig {
            #[inline(always)]
            fn default() -> RxdFrameconfig {
                RxdFrameconfig(0)
            }
        }
        impl core::fmt::Debug for RxdFrameconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxdFrameconfig")
                    .field("parity", &self.parity())
                    .field("sof", &self.sof())
                    .field("crcmoderx", &self.crcmoderx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxdFrameconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxdFrameconfig {
                    parity: bool,
                    sof: bool,
                    crcmoderx: bool,
                }
                let proxy = RxdFrameconfig {
                    parity: self.parity(),
                    sof: self.sof(),
                    crcmoderx: self.crcmoderx(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Second last NFCID1 part (7 or 10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Secondlast(pub u32);
        impl Secondlast {
            #[doc = "NFCID1 byte V"]
            #[inline(always)]
            pub const fn v(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte V"]
            #[inline(always)]
            pub fn set_v(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte U"]
            #[inline(always)]
            pub const fn u(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte U"]
            #[inline(always)]
            pub fn set_u(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte T"]
            #[inline(always)]
            pub const fn t(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte T"]
            #[inline(always)]
            pub fn set_t(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Secondlast {
            #[inline(always)]
            fn default() -> Secondlast {
                Secondlast(0)
            }
        }
        impl core::fmt::Debug for Secondlast {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Secondlast")
                    .field("v", &self.v())
                    .field("u", &self.u())
                    .field("t", &self.t())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Secondlast {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Secondlast {
                    v: u8,
                    u: u8,
                    t: u8,
                }
                let proxy = Secondlast {
                    v: self.v(),
                    u: self.u(),
                    t: self.t(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "NFC-A SEL_RES auto-response settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Selres(pub u32);
        impl Selres {
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn rfu10(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x03;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub fn set_rfu10(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val as u32) & 0x03) << 0usize);
            }
            #[doc = "Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)"]
            #[inline(always)]
            pub const fn cascade(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Cascade as defined by the b3 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification (controlled by hardware, shall be 0)"]
            #[inline(always)]
            pub fn set_cascade(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn rfu43(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x03;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub fn set_rfu43(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 3usize)) | (((val as u32) & 0x03) << 3usize);
            }
            #[doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn protocol(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x03;
                val as u8
            }
            #[doc = "Protocol as defined by the b7:b6 of SEL_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub fn set_protocol(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 5usize)) | (((val as u32) & 0x03) << 5usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn rfu7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub fn set_rfu7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Selres {
            #[inline(always)]
            fn default() -> Selres {
                Selres(0)
            }
        }
        impl core::fmt::Debug for Selres {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Selres")
                    .field("rfu10", &self.rfu10())
                    .field("cascade", &self.cascade())
                    .field("rfu43", &self.rfu43())
                    .field("protocol", &self.protocol())
                    .field("rfu7", &self.rfu7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Selres {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Selres {
                    rfu10: u8,
                    cascade: bool,
                    rfu43: u8,
                    protocol: u8,
                    rfu7: bool,
                }
                let proxy = Selres {
                    rfu10: self.rfu10(),
                    cascade: self.cascade(),
                    rfu43: self.rfu43(),
                    protocol: self.protocol(),
                    rfu7: self.rfu7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "NFC-A SENS_RES auto-response settings"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sensres(pub u32);
        impl Sensres {
            #[doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn bitframesdd(&self) -> super::vals::Bitframesdd {
                let val = (self.0 >> 0usize) & 0x1f;
                super::vals::Bitframesdd::from_bits(val as u8)
            }
            #[doc = "Bit frame SDD as defined by the b5:b1 of byte 1 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub fn set_bitframesdd(&mut self, val: super::vals::Bitframesdd) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val.to_bits() as u32) & 0x1f) << 0usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn rfu5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub fn set_rfu5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "NFCID1 size. This value is used by the auto collision resolution engine."]
            #[inline(always)]
            pub const fn nfcidsize(&self) -> super::vals::Nfcidsize {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Nfcidsize::from_bits(val as u8)
            }
            #[doc = "NFCID1 size. This value is used by the auto collision resolution engine."]
            #[inline(always)]
            pub fn set_nfcidsize(&mut self, val: super::vals::Nfcidsize) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub const fn platfconfig(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "Tag platform configuration as defined by the b4:b1 of byte 2 in SENS_RES response in the NFC Forum, NFC Digital Protocol Technical Specification"]
            #[inline(always)]
            pub fn set_platfconfig(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub const fn rfu74(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Reserved for future use. Shall be 0."]
            #[inline(always)]
            pub fn set_rfu74(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
        }
        impl Default for Sensres {
            #[inline(always)]
            fn default() -> Sensres {
                Sensres(0)
            }
        }
        impl core::fmt::Debug for Sensres {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sensres")
                    .field("bitframesdd", &self.bitframesdd())
                    .field("rfu5", &self.rfu5())
                    .field("nfcidsize", &self.nfcidsize())
                    .field("platfconfig", &self.platfconfig())
                    .field("rfu74", &self.rfu74())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sensres {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Sensres {
                    bitframesdd: super::vals::Bitframesdd,
                    rfu5: bool,
                    nfcidsize: super::vals::Nfcidsize,
                    platfconfig: u8,
                    rfu74: u8,
                }
                let proxy = Sensres {
                    bitframesdd: self.bitframesdd(),
                    rfu5: self.rfu5(),
                    nfcidsize: self.nfcidsize(),
                    platfconfig: self.platfconfig(),
                    rfu74: self.rfu74(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event FIELDDETECTED and task ACTIVATE"]
            #[inline(always)]
            pub const fn fielddetected_activate(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FIELDDETECTED and task ACTIVATE"]
            #[inline(always)]
            pub fn set_fielddetected_activate(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event FIELDLOST and task SENSE"]
            #[inline(always)]
            pub const fn fieldlost_sense(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FIELDLOST and task SENSE"]
            #[inline(always)]
            pub fn set_fieldlost_sense(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event TXFRAMEEND and task ENABLERXDATA"]
            #[inline(always)]
            pub const fn txframeend_enablerxdata(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event TXFRAMEEND and task ENABLERXDATA"]
            #[inline(always)]
            pub fn set_txframeend_enablerxdata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("fielddetected_activate", &self.fielddetected_activate())
                    .field("fieldlost_sense", &self.fieldlost_sense())
                    .field("txframeend_enablerxdata", &self.txframeend_enablerxdata())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    fielddetected_activate: bool,
                    fieldlost_sense: bool,
                    txframeend_enablerxdata: bool,
                }
                let proxy = Shorts {
                    fielddetected_activate: self.fielddetected_activate(),
                    fieldlost_sense: self.fieldlost_sense(),
                    txframeend_enablerxdata: self.txframeend_enablerxdata(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sleep state during automatic collision resolution"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sleepstate(pub u32);
        impl Sleepstate {
            #[doc = "Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task."]
            #[inline(always)]
            pub const fn sleepstate(&self) -> super::vals::Sleepstate {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleepstate::from_bits(val as u8)
            }
            #[doc = "Reflects the sleep state during automatic collision resolution. Set to IDLE by a GOIDLE task. Set to SLEEP_A when a valid SLEEP_REQ frame is received or by a GOSLEEP task."]
            #[inline(always)]
            pub fn set_sleepstate(&mut self, val: super::vals::Sleepstate) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Sleepstate {
            #[inline(always)]
            fn default() -> Sleepstate {
                Sleepstate(0)
            }
        }
        impl core::fmt::Debug for Sleepstate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sleepstate")
                    .field("sleepstate", &self.sleepstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sleepstate {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Sleepstate {
                    sleepstate: super::vals::Sleepstate,
                }
                let proxy = Sleepstate {
                    sleepstate: self.sleepstate(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Third last NFCID1 part (10 bytes ID)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Thirdlast(pub u32);
        impl Thirdlast {
            #[doc = "NFCID1 byte S"]
            #[inline(always)]
            pub const fn s(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte S"]
            #[inline(always)]
            pub fn set_s(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "NFCID1 byte R"]
            #[inline(always)]
            pub const fn r(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte R"]
            #[inline(always)]
            pub fn set_r(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "NFCID1 byte Q"]
            #[inline(always)]
            pub const fn q(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "NFCID1 byte Q"]
            #[inline(always)]
            pub fn set_q(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
        }
        impl Default for Thirdlast {
            #[inline(always)]
            fn default() -> Thirdlast {
                Thirdlast(0)
            }
        }
        impl core::fmt::Debug for Thirdlast {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Thirdlast")
                    .field("s", &self.s())
                    .field("r", &self.r())
                    .field("q", &self.q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Thirdlast {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Thirdlast {
                    s: u8,
                    r: u8,
                    q: u8,
                }
                let proxy = Thirdlast {
                    s: self.s(),
                    r: self.r(),
                    q: self.q(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Size of outgoing frame"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdAmount(pub u32);
        impl TxdAmount {
            #[doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."]
            #[inline(always)]
            pub const fn txdatabits(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Number of bits in the last or first byte read from RAM that shall be included in the frame (excluding parity bit)."]
            #[inline(always)]
            pub fn set_txdatabits(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
            #[doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity, and framing."]
            #[inline(always)]
            pub const fn txdatabytes(&self) -> u16 {
                let val = (self.0 >> 3usize) & 0x01ff;
                val as u16
            }
            #[doc = "Number of complete bytes that shall be included in the frame, excluding CRC, parity, and framing."]
            #[inline(always)]
            pub fn set_txdatabytes(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 3usize)) | (((val as u32) & 0x01ff) << 3usize);
            }
        }
        impl Default for TxdAmount {
            #[inline(always)]
            fn default() -> TxdAmount {
                TxdAmount(0)
            }
        }
        impl core::fmt::Debug for TxdAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdAmount")
                    .field("txdatabits", &self.txdatabits())
                    .field("txdatabytes", &self.txdatabytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxdAmount {
                    txdatabits: u8,
                    txdatabytes: u16,
                }
                let proxy = TxdAmount {
                    txdatabits: self.txdatabits(),
                    txdatabytes: self.txdatabytes(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of outgoing frames"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxdFrameconfig(pub u32);
        impl TxdFrameconfig {
            #[doc = "Indicates if parity is added to the frame"]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates if parity is added to the frame"]
            #[inline(always)]
            pub fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Discarding unused bits at start or end of a frame"]
            #[inline(always)]
            pub const fn discardmode(&self) -> super::vals::Discardmode {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Discardmode::from_bits(val as u8)
            }
            #[doc = "Discarding unused bits at start or end of a frame"]
            #[inline(always)]
            pub fn set_discardmode(&mut self, val: super::vals::Discardmode) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Adding SoF or not in TX frames"]
            #[inline(always)]
            pub const fn sof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Adding SoF or not in TX frames"]
            #[inline(always)]
            pub fn set_sof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "CRC mode for outgoing frames"]
            #[inline(always)]
            pub const fn crcmodetx(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "CRC mode for outgoing frames"]
            #[inline(always)]
            pub fn set_crcmodetx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for TxdFrameconfig {
            #[inline(always)]
            fn default() -> TxdFrameconfig {
                TxdFrameconfig(0)
            }
        }
        impl core::fmt::Debug for TxdFrameconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxdFrameconfig")
                    .field("parity", &self.parity())
                    .field("discardmode", &self.discardmode())
                    .field("sof", &self.sof())
                    .field("crcmodetx", &self.crcmodetx())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxdFrameconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxdFrameconfig {
                    parity: bool,
                    discardmode: super::vals::Discardmode,
                    sof: bool,
                    crcmodetx: bool,
                }
                let proxy = TxdFrameconfig {
                    parity: self.parity(),
                    discardmode: self.discardmode(),
                    sof: self.sof(),
                    crcmodetx: self.crcmodetx(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitframesdd {
            #[doc = "SDD pattern 00000"]
            SDD00000 = 0x0,
            #[doc = "SDD pattern 00001"]
            SDD00001 = 0x01,
            #[doc = "SDD pattern 00010"]
            SDD00010 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "SDD pattern 00100"]
            SDD00100 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "SDD pattern 01000"]
            SDD01000 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
            #[doc = "SDD pattern 10000"]
            SDD10000 = 0x10,
            _RESERVED_11 = 0x11,
            _RESERVED_12 = 0x12,
            _RESERVED_13 = 0x13,
            _RESERVED_14 = 0x14,
            _RESERVED_15 = 0x15,
            _RESERVED_16 = 0x16,
            _RESERVED_17 = 0x17,
            _RESERVED_18 = 0x18,
            _RESERVED_19 = 0x19,
            _RESERVED_1a = 0x1a,
            _RESERVED_1b = 0x1b,
            _RESERVED_1c = 0x1c,
            _RESERVED_1d = 0x1d,
            _RESERVED_1e = 0x1e,
            _RESERVED_1f = 0x1f,
        }
        impl Bitframesdd {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitframesdd {
                unsafe { core::mem::transmute(val & 0x1f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitframesdd {
            #[inline(always)]
            fn from(val: u8) -> Bitframesdd {
                Bitframesdd::from_bits(val)
            }
        }
        impl From<Bitframesdd> for u8 {
            #[inline(always)]
            fn from(val: Bitframesdd) -> u8 {
                Bitframesdd::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Discardmode {
            #[doc = "Unused bits are discarded at end of frame (EoF)"]
            DISCARD_END = 0x0,
            #[doc = "Unused bits are discarded at start of frame (SoF)"]
            DISCARD_START = 0x01,
        }
        impl Discardmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Discardmode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Discardmode {
            #[inline(always)]
            fn from(val: u8) -> Discardmode {
                Discardmode::from_bits(val)
            }
        }
        impl From<Discardmode> for u8 {
            #[inline(always)]
            fn from(val: Discardmode) -> u8 {
                Discardmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Framedelaymode {
            #[doc = "Transmission is independent of frame timer and will start when the STARTTX task is triggered. No timeout."]
            FREE_RUN = 0x0,
            #[doc = "Frame is transmitted between FRAMEDELAYMIN and FRAMEDELAYMAX"]
            WINDOW = 0x01,
            #[doc = "Frame is transmitted exactly at FRAMEDELAYMAX"]
            EXACT_VAL = 0x02,
            #[doc = "Frame is transmitted on a bit grid between FRAMEDELAYMIN and FRAMEDELAYMAX"]
            WINDOW_GRID = 0x03,
        }
        impl Framedelaymode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Framedelaymode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Framedelaymode {
            #[inline(always)]
            fn from(val: u8) -> Framedelaymode {
                Framedelaymode::from_bits(val)
            }
        }
        impl From<Framedelaymode> for u8 {
            #[inline(always)]
            fn from(val: Framedelaymode) -> u8 {
                Framedelaymode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Lpop {
            #[doc = "Low-latency operation"]
            LOW_LAT = 0x0,
            #[doc = "Low-power operation"]
            LOW_POWER = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "Full Low-power operation"]
            FULL_LOW_POWER = 0x03,
        }
        impl Lpop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Lpop {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Lpop {
            #[inline(always)]
            fn from(val: u8) -> Lpop {
                Lpop::from_bits(val)
            }
        }
        impl From<Lpop> for u8 {
            #[inline(always)]
            fn from(val: Lpop) -> u8 {
                Lpop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Auto collision resolution enabled"]
            ENABLED = 0x0,
            #[doc = "Auto collision resolution disabled"]
            DISABLED = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Modulationctrl {
            #[doc = "Invalid, defaults to same behaviour as for Internal"]
            INVALID = 0x0,
            #[doc = "Use internal modulator only"]
            INTERNAL = 0x01,
            #[doc = "Output digital modulation signal to a GPIO pin."]
            MOD_TO_GPIO = 0x02,
            #[doc = "Use internal modulator and output digital modulation signal to a GPIO pin."]
            INTERNAL_AND_MOD_TO_GPIO = 0x03,
        }
        impl Modulationctrl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Modulationctrl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Modulationctrl {
            #[inline(always)]
            fn from(val: u8) -> Modulationctrl {
                Modulationctrl::from_bits(val)
            }
        }
        impl From<Modulationctrl> for u8 {
            #[inline(always)]
            fn from(val: Modulationctrl) -> u8 {
                Modulationctrl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfcidsize {
            #[doc = "NFCID1 size: single (4 bytes)"]
            NFCID1SINGLE = 0x0,
            #[doc = "NFCID1 size: double (7 bytes)"]
            NFCID1DOUBLE = 0x01,
            #[doc = "NFCID1 size: triple (10 bytes)"]
            NFCID1TRIPLE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nfcidsize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfcidsize {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfcidsize {
            #[inline(always)]
            fn from(val: u8) -> Nfcidsize {
                Nfcidsize::from_bits(val)
            }
        }
        impl From<Nfcidsize> for u8 {
            #[inline(always)]
            fn from(val: Nfcidsize) -> u8 {
                Nfcidsize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nfctagstate {
            #[doc = "Disabled or sense"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "RampUp"]
            RAMP_UP = 0x02,
            #[doc = "Idle"]
            IDLE = 0x03,
            #[doc = "Receive"]
            RECEIVE = 0x04,
            #[doc = "FrameDelay"]
            FRAME_DELAY = 0x05,
            #[doc = "Transmit"]
            TRANSMIT = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Nfctagstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nfctagstate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nfctagstate {
            #[inline(always)]
            fn from(val: u8) -> Nfctagstate {
                Nfctagstate::from_bits(val)
            }
        }
        impl From<Nfctagstate> for u8 {
            #[inline(always)]
            fn from(val: Nfctagstate) -> u8 {
                Nfctagstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleepstate {
            #[doc = "State is IDLE."]
            IDLE = 0x0,
            #[doc = "State is SLEEP_A."]
            SLEEP_A = 0x01,
        }
        impl Sleepstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleepstate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleepstate {
            #[inline(always)]
            fn from(val: u8) -> Sleepstate {
                Sleepstate::from_bits(val)
            }
        }
        impl From<Sleepstate> for u8 {
            #[inline(always)]
            fn from(val: Sleepstate) -> u8 {
                Sleepstate::to_bits(val)
            }
        }
    }
}
pub mod oscillators {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Config {
        ptr: *mut u8,
    }
    unsafe impl Send for Config {}
    unsafe impl Sync for Config {}
    impl Config {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
        #[inline(always)]
        pub const fn intcap(self) -> crate::common::Reg<regs::ConfigIntcap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Oscillator control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Oscillators {
        ptr: *mut u8,
    }
    unsafe impl Send for Oscillators {}
    unsafe impl Sync for Oscillators {}
    impl Oscillators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "32 MHz oscillator control"]
        #[inline(always)]
        pub const fn xosc32m(self) -> Xosc32m {
            unsafe { Xosc32m::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
        #[doc = "Oscillator control"]
        #[inline(always)]
        pub const fn pll(self) -> Pll {
            unsafe { Pll::from_ptr(self.ptr.add(0x0800usize) as _) }
        }
        #[doc = "32.768 kHz oscillator control"]
        #[inline(always)]
        pub const fn xosc32ki(self) -> Xosc32ki {
            unsafe { Xosc32ki::from_ptr(self.ptr.add(0x0900usize) as _) }
        }
    }
    #[doc = "Oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pll {
        ptr: *mut u8,
    }
    unsafe impl Send for Pll {}
    unsafe impl Sync for Pll {}
    impl Pll {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Set speed of MCU power domain, including CPU"]
        #[inline(always)]
        pub const fn freq(self) -> crate::common::Reg<regs::Freq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Current speed of MCU power domain, including CPU"]
        #[inline(always)]
        pub const fn currentfreq(self) -> crate::common::Reg<regs::Currentfreq, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "32.768 kHz oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xosc32ki {
        ptr: *mut u8,
    }
    unsafe impl Send for Xosc32ki {}
    unsafe impl Sync for Xosc32ki {}
    impl Xosc32ki {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Programmable capacitance of XL1 and XL2"]
        #[inline(always)]
        pub const fn intcap(self) -> crate::common::Reg<regs::Xosc32kiIntcap, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "32 MHz oscillator control"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Xosc32m {
        ptr: *mut u8,
    }
    unsafe impl Send for Xosc32m {}
    unsafe impl Sync for Xosc32m {}
    impl Xosc32m {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn config(self) -> Config {
            unsafe { Config::from_ptr(self.ptr.add(0x14usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ConfigIntcap(pub u32);
        impl ConfigIntcap {
            #[doc = "Crystal load capacitor value"]
            #[inline(always)]
            pub const fn val(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Crystal load capacitor value"]
            #[inline(always)]
            pub fn set_val(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
        }
        impl Default for ConfigIntcap {
            #[inline(always)]
            fn default() -> ConfigIntcap {
                ConfigIntcap(0)
            }
        }
        impl core::fmt::Debug for ConfigIntcap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ConfigIntcap")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ConfigIntcap {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ConfigIntcap {
                    val: u8,
                }
                let proxy = ConfigIntcap { val: self.val() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Current speed of MCU power domain, including CPU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentfreq(pub u32);
        impl Currentfreq {
            #[doc = "Active CPU speed"]
            #[inline(always)]
            pub const fn currentfreq(&self) -> super::vals::Currentfreq {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Currentfreq::from_bits(val as u8)
            }
            #[doc = "Active CPU speed"]
            #[inline(always)]
            pub fn set_currentfreq(&mut self, val: super::vals::Currentfreq) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Currentfreq {
            #[inline(always)]
            fn default() -> Currentfreq {
                Currentfreq(0)
            }
        }
        impl core::fmt::Debug for Currentfreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentfreq")
                    .field("currentfreq", &self.currentfreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentfreq {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Currentfreq {
                    currentfreq: super::vals::Currentfreq,
                }
                let proxy = Currentfreq {
                    currentfreq: self.currentfreq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Set speed of MCU power domain, including CPU"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freq(pub u32);
        impl Freq {
            #[doc = "Select CPU speed"]
            #[inline(always)]
            pub const fn freq(&self) -> super::vals::Freq {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Freq::from_bits(val as u8)
            }
            #[doc = "Select CPU speed"]
            #[inline(always)]
            pub fn set_freq(&mut self, val: super::vals::Freq) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Freq {
            #[inline(always)]
            fn default() -> Freq {
                Freq(0)
            }
        }
        impl core::fmt::Debug for Freq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freq").field("freq", &self.freq()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freq {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Freq {
                    freq: super::vals::Freq,
                }
                let proxy = Freq { freq: self.freq() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Programmable capacitance of XL1 and XL2"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Xosc32kiIntcap(pub u32);
        impl Xosc32kiIntcap {
            #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
            #[inline(always)]
            pub const fn val(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Crystal load capacitor as seen by the crystal across its terminals, including pin capacitance but excluding PCB stray capacitance."]
            #[inline(always)]
            pub fn set_val(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
        }
        impl Default for Xosc32kiIntcap {
            #[inline(always)]
            fn default() -> Xosc32kiIntcap {
                Xosc32kiIntcap(0)
            }
        }
        impl core::fmt::Debug for Xosc32kiIntcap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Xosc32kiIntcap")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Xosc32kiIntcap {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Xosc32kiIntcap {
                    val: u8,
                }
                let proxy = Xosc32kiIntcap { val: self.val() };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Currentfreq {
            _RESERVED_0 = 0x0,
            #[doc = "128 MHz"]
            CK128M = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "64 MHz"]
            CK64M = 0x03,
        }
        impl Currentfreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Currentfreq {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Currentfreq {
            #[inline(always)]
            fn from(val: u8) -> Currentfreq {
                Currentfreq::from_bits(val)
            }
        }
        impl From<Currentfreq> for u8 {
            #[inline(always)]
            fn from(val: Currentfreq) -> u8 {
                Currentfreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Freq {
            _RESERVED_0 = 0x0,
            #[doc = "128 MHz"]
            CK128M = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "64 MHz"]
            CK64M = 0x03,
        }
        impl Freq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Freq {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Freq {
            #[inline(always)]
            fn from(val: u8) -> Freq {
                Freq::from_bits(val)
            }
        }
        impl From<Freq> for u8 {
            #[inline(always)]
            fn from(val: Freq) -> u8 {
                Freq::to_bits(val)
            }
        }
    }
}
pub mod pdm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "This event is generated if an error occurs during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Pulse Density Modulation (Digital Microphone) Interface 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pdm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pdm {}
    unsafe impl Sync for Pdm {}
    impl Pdm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts continuous PDM transfer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops PDM transfer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "PDM transfer has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "PDM transfer has finished"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "The PDM has written the last sample specified by SAMPLE.MAXCNT (or the last sample after a STOP task has been received) to Data RAM"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "PDM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Defines the routing of the connected PDM microphone signals"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Left output gain adjustment"]
        #[inline(always)]
        pub const fn gainl(self) -> crate::common::Reg<regs::Gainl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Right output gain adjustment"]
        #[inline(always)]
        pub const fn gainr(self) -> crate::common::Reg<regs::Gainr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x051cusize) as _) }
        }
        #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate. Change PRESCALER accordingly."]
        #[inline(always)]
        pub const fn ratio(self) -> crate::common::Reg<regs::Ratio, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn sample(self) -> Sample {
            unsafe { Sample::from_ptr(self.ptr.add(0x0560usize) as _) }
        }
        #[doc = "The prescaler is used to set the PDM frequency"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0580usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin number configuration for PDM CLK signal"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin number configuration for PDM DIN signal"]
        #[inline(always)]
        pub const fn din(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event DMA.BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sample {
        ptr: *mut u8,
    }
    unsafe impl Send for Sample {}
    unsafe impl Sync for Sample {}
    impl Sample {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM address pointer to write samples to with EasyDMA"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Number of samples to allocate memory for in EasyDMA mode"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "PDM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PDM module"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PDM module"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Left output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainl(pub u32);
        impl Gainl {
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[inline(always)]
            pub const fn gainl(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Left output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters) 0x00 -20 dB gain adjust 0x01 -19.5 dB gain adjust (...) 0x27 -0.5 dB gain adjust 0x28 0 dB gain adjust 0x29 +0.5 dB gain adjust (...) 0x4F +19.5 dB gain adjust 0x50 +20 dB gain adjust"]
            #[inline(always)]
            pub fn set_gainl(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainl {
            #[inline(always)]
            fn default() -> Gainl {
                Gainl(0)
            }
        }
        impl core::fmt::Debug for Gainl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainl")
                    .field("gainl", &self.gainl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Gainl {
                    gainl: super::vals::Gain,
                }
                let proxy = Gainl {
                    gainl: self.gainl(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Right output gain adjustment"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gainr(pub u32);
        impl Gainr {
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[inline(always)]
            pub const fn gainr(&self) -> super::vals::Gain {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Right output gain adjustment, in 0.5 dB steps, around the default module gain (see electrical parameters)"]
            #[inline(always)]
            pub fn set_gainr(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Gainr {
            #[inline(always)]
            fn default() -> Gainr {
                Gainr(0)
            }
        }
        impl core::fmt::Debug for Gainr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gainr")
                    .field("gainr", &self.gainr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gainr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Gainr {
                    gainr: super::vals::Gain,
                }
                let proxy = Gainr {
                    gainr: self.gainr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event DMABUSERROR"]
            #[inline(always)]
            pub const fn dmabuserror(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMABUSERROR"]
            #[inline(always)]
            pub fn set_dmabuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .field("dmabuserror", &self.dmabuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    started: bool,
                    stopped: bool,
                    end: bool,
                    dmabuserror: bool,
                }
                let proxy = Int {
                    started: self.started(),
                    stopped: self.stopped(),
                    end: self.end(),
                    dmabuserror: self.dmabuserror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of samples to allocate memory for in EasyDMA mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Length of DMA RAM allocation in number of samples"]
            #[inline(always)]
            pub const fn buffsize(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Length of DMA RAM allocation in number of samples"]
            #[inline(always)]
            pub fn set_buffsize(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("buffsize", &self.buffsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxcnt {
                    buffsize: u16,
                }
                let proxy = Maxcnt {
                    buffsize: self.buffsize(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Defines the routing of the connected PDM microphone signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Mono or stereo operation"]
            #[inline(always)]
            pub const fn operation(&self) -> super::vals::Operation {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Operation::from_bits(val as u8)
            }
            #[doc = "Mono or stereo operation"]
            #[inline(always)]
            pub fn set_operation(&mut self, val: super::vals::Operation) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled."]
            #[inline(always)]
            pub const fn edge(&self) -> super::vals::Edge {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Edge::from_bits(val as u8)
            }
            #[doc = "Defines on which PDM_CLK edge left (or mono) is sampled."]
            #[inline(always)]
            pub fn set_edge(&mut self, val: super::vals::Edge) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("operation", &self.operation())
                    .field("edge", &self.edge())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    operation: super::vals::Operation,
                    edge: super::vals::Edge,
                }
                let proxy = Mode {
                    operation: self.operation(),
                    edge: self.edge(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate. Change PRESCALER accordingly."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ratio(pub u32);
        impl Ratio {
            #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate"]
            #[inline(always)]
            pub const fn ratio(&self) -> super::vals::Ratio {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ratio::from_bits(val as u8)
            }
            #[doc = "Selects the decimation ratio between PDM_CLK and output sample rate"]
            #[inline(always)]
            pub fn set_ratio(&mut self, val: super::vals::Ratio) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Ratio {
            #[inline(always)]
            fn default() -> Ratio {
                Ratio(0)
            }
        }
        impl core::fmt::Debug for Ratio {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ratio")
                    .field("ratio", &self.ratio())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ratio {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ratio {
                    ratio: super::vals::Ratio,
                }
                let proxy = Ratio {
                    ratio: self.ratio(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Terminateonbuserror {
                    enable: bool,
                }
                let proxy = Terminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Edge {
            #[doc = "Left (or mono) is sampled on falling edge of PDM_CLK"]
            LEFT_FALLING = 0x0,
            #[doc = "Left (or mono) is sampled on rising edge of PDM_CLK"]
            LEFT_RISING = 0x01,
        }
        impl Edge {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Edge {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Edge {
            #[inline(always)]
            fn from(val: u8) -> Edge {
                Edge::from_bits(val)
            }
        }
        impl From<Edge> for u8 {
            #[inline(always)]
            fn from(val: Edge) -> u8 {
                Edge::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Gain(pub u8);
        impl Gain {
            #[doc = "-20 dB gain adjustment (minimum)"]
            pub const MIN_GAIN: Self = Self(0x0);
            #[doc = "0 dB gain adjustment"]
            pub const DEFAULT_GAIN: Self = Self(0x28);
            #[doc = "+20 dB gain adjustment (maximum)"]
            pub const MAX_GAIN: Self = Self(0x50);
        }
        impl Gain {
            pub const fn from_bits(val: u8) -> Gain {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Gain {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("MIN_GAIN"),
                    0x28 => f.write_str("DEFAULT_GAIN"),
                    0x50 => f.write_str("MAX_GAIN"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gain {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "MIN_GAIN"),
                    0x28 => defmt::write!(f, "DEFAULT_GAIN"),
                    0x50 => defmt::write!(f, "MAX_GAIN"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Operation {
            #[doc = "Sample and store one pair (left + right) of 16-bit samples per RAM word R=\\[31:16\\]; L=\\[15:0\\]"]
            STEREO = 0x0,
            #[doc = "Sample and store two successive left samples (16 bits each) per RAM word L1=\\[31:16\\]; L0=\\[15:0\\]"]
            MONO = 0x01,
        }
        impl Operation {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Operation {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Operation {
            #[inline(always)]
            fn from(val: u8) -> Operation {
                Operation::from_bits(val)
            }
        }
        impl From<Operation> for u8 {
            #[inline(always)]
            fn from(val: Operation) -> u8 {
                Operation::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ratio {
            #[doc = "Ratio of 32"]
            RATIO32 = 0x0,
            #[doc = "Ratio of 48"]
            RATIO48 = 0x01,
            #[doc = "Ratio of 50"]
            RATIO50 = 0x02,
            #[doc = "Ratio of 64"]
            RATIO64 = 0x03,
            #[doc = "Ratio of 80"]
            RATIO80 = 0x04,
            #[doc = "Ratio of 96"]
            RATIO96 = 0x05,
            #[doc = "Ratio of 100"]
            RATIO100 = 0x06,
            #[doc = "Ratio of 128"]
            RATIO128 = 0x07,
        }
        impl Ratio {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ratio {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ratio {
            #[inline(always)]
            fn from(val: u8) -> Ratio {
                Ratio::from_bits(val)
            }
        }
        impl From<Ratio> for u8 {
            #[inline(always)]
            fn from(val: Ratio) -> u8 {
                Ratio::to_bits(val)
            }
        }
    }
}
pub mod power {
    #[doc = "Power control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable Constant Latency mode"]
        #[inline(always)]
        pub const fn tasks_constlat(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Enable Low-power mode (variable latency)"]
        #[inline(always)]
        pub const fn tasks_lowpwr(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Subscribe configuration for task CONSTLAT"]
        #[inline(always)]
        pub const fn subscribe_constlat(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "Subscribe configuration for task LOWPWR"]
        #[inline(always)]
        pub const fn subscribe_lowpwr(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xb4usize) as _) }
        }
        #[doc = "Power failure warning"]
        #[inline(always)]
        pub const fn events_pofwarn(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "CPU entered WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepenter(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "CPU exited WFI/WFE sleep"]
        #[inline(always)]
        pub const fn events_sleepexit(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Publish configuration for event POFWARN"]
        #[inline(always)]
        pub const fn publish_pofwarn(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPENTER"]
        #[inline(always)]
        pub const fn publish_sleepenter(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b4usize) as _) }
        }
        #[doc = "Publish configuration for event SLEEPEXIT"]
        #[inline(always)]
        pub const fn publish_sleepexit(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[inline(always)]
        pub const fn gpregret(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Gpregret, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
        #[doc = "Status of constant latency"]
        #[inline(always)]
        pub const fn constlatstat(
            self,
        ) -> crate::common::Reg<regs::Constlatstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Status of constant latency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Constlatstat(pub u32);
        impl Constlatstat {
            #[doc = "Status"]
            #[inline(always)]
            pub const fn status(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Status"]
            #[inline(always)]
            pub fn set_status(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Constlatstat {
            #[inline(always)]
            fn default() -> Constlatstat {
                Constlatstat(0)
            }
        }
        impl core::fmt::Debug for Constlatstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Constlatstat")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Constlatstat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Constlatstat {
                    status: bool,
                }
                let proxy = Constlatstat {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: General purpose retention register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Gpregret(pub u32);
        impl Gpregret {
            #[doc = "General purpose retention register"]
            #[inline(always)]
            pub const fn gpregret(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "General purpose retention register"]
            #[inline(always)]
            pub fn set_gpregret(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Gpregret {
            #[inline(always)]
            fn default() -> Gpregret {
                Gpregret(0)
            }
        }
        impl core::fmt::Debug for Gpregret {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Gpregret")
                    .field("gpregret", &self.gpregret())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Gpregret {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Gpregret {
                    gpregret: u8,
                }
                let proxy = Gpregret {
                    gpregret: self.gpregret(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[inline(always)]
            pub const fn pofwarn(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event POFWARN"]
            #[inline(always)]
            pub fn set_pofwarn(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[inline(always)]
            pub const fn sleepenter(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPENTER"]
            #[inline(always)]
            pub fn set_sleepenter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[inline(always)]
            pub const fn sleepexit(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SLEEPEXIT"]
            #[inline(always)]
            pub fn set_sleepexit(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("pofwarn", &self.pofwarn())
                    .field("sleepenter", &self.sleepenter())
                    .field("sleepexit", &self.sleepexit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    pofwarn: bool,
                    sleepenter: bool,
                    sleepexit: bool,
                }
                let proxy = Int {
                    pofwarn: self.pofwarn(),
                    sleepenter: self.sleepenter(),
                    sleepexit: self.sleepexit(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod ppib {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Overflow {
        ptr: *mut u8,
    }
    unsafe impl Send for Overflow {}
    unsafe impl Sync for Overflow {}
    impl Overflow {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "The task overflow for SEND tasks using SUBSCRIBE_SEND. Write 0 to clear."]
        #[inline(always)]
        pub const fn send(self) -> crate::common::Reg<regs::Send, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "PPIB APB registers 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ppib {
        ptr: *mut u8,
    }
    unsafe impl Send for Ppib {}
    unsafe impl Sync for Ppib {}
    impl Ppib {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: This task is unused, but the PPIB provides the SUBSCRIBE task to connect SEND \\[n\\] task."]
        #[inline(always)]
        pub const fn tasks_send(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task SEND\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_send(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: This event is unused, but the PPIB provides the PUBLISH event to connect RECEIVE \\[n\\] event."]
        #[inline(always)]
        pub const fn events_receive(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event RECEIVE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_receive(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn overflow(self) -> Overflow {
            unsafe { Overflow::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "The task overflow for SEND tasks using SUBSCRIBE_SEND. Write 0 to clear."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Send(pub u32);
        impl Send {
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[0\\]."]
            #[inline(always)]
            pub const fn send_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[0\\]."]
            #[inline(always)]
            pub fn set_send_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[1\\]."]
            #[inline(always)]
            pub const fn send_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[1\\]."]
            #[inline(always)]
            pub fn set_send_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[2\\]."]
            #[inline(always)]
            pub const fn send_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[2\\]."]
            #[inline(always)]
            pub fn set_send_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[3\\]."]
            #[inline(always)]
            pub const fn send_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[3\\]."]
            #[inline(always)]
            pub fn set_send_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[4\\]."]
            #[inline(always)]
            pub const fn send_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[4\\]."]
            #[inline(always)]
            pub fn set_send_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[5\\]."]
            #[inline(always)]
            pub const fn send_5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[5\\]."]
            #[inline(always)]
            pub fn set_send_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[6\\]."]
            #[inline(always)]
            pub const fn send_6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[6\\]."]
            #[inline(always)]
            pub fn set_send_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[7\\]."]
            #[inline(always)]
            pub const fn send_7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[7\\]."]
            #[inline(always)]
            pub fn set_send_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[8\\]."]
            #[inline(always)]
            pub const fn send_8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[8\\]."]
            #[inline(always)]
            pub fn set_send_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[9\\]."]
            #[inline(always)]
            pub const fn send_9(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[9\\]."]
            #[inline(always)]
            pub fn set_send_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[10\\]."]
            #[inline(always)]
            pub const fn send_10(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[10\\]."]
            #[inline(always)]
            pub fn set_send_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[11\\]."]
            #[inline(always)]
            pub const fn send_11(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[11\\]."]
            #[inline(always)]
            pub fn set_send_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[12\\]."]
            #[inline(always)]
            pub const fn send_12(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[12\\]."]
            #[inline(always)]
            pub fn set_send_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[13\\]."]
            #[inline(always)]
            pub const fn send_13(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[13\\]."]
            #[inline(always)]
            pub fn set_send_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[14\\]."]
            #[inline(always)]
            pub const fn send_14(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[14\\]."]
            #[inline(always)]
            pub fn set_send_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[15\\]."]
            #[inline(always)]
            pub const fn send_15(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[15\\]."]
            #[inline(always)]
            pub fn set_send_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[16\\]."]
            #[inline(always)]
            pub const fn send_16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[16\\]."]
            #[inline(always)]
            pub fn set_send_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[17\\]."]
            #[inline(always)]
            pub const fn send_17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[17\\]."]
            #[inline(always)]
            pub fn set_send_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[18\\]."]
            #[inline(always)]
            pub const fn send_18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[18\\]."]
            #[inline(always)]
            pub fn set_send_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[19\\]."]
            #[inline(always)]
            pub const fn send_19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[19\\]."]
            #[inline(always)]
            pub fn set_send_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[20\\]."]
            #[inline(always)]
            pub const fn send_20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[20\\]."]
            #[inline(always)]
            pub fn set_send_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[21\\]."]
            #[inline(always)]
            pub const fn send_21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[21\\]."]
            #[inline(always)]
            pub fn set_send_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[22\\]."]
            #[inline(always)]
            pub const fn send_22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[22\\]."]
            #[inline(always)]
            pub fn set_send_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[23\\]."]
            #[inline(always)]
            pub const fn send_23(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[23\\]."]
            #[inline(always)]
            pub fn set_send_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[24\\]."]
            #[inline(always)]
            pub const fn send_24(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[24\\]."]
            #[inline(always)]
            pub fn set_send_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[25\\]."]
            #[inline(always)]
            pub const fn send_25(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[25\\]."]
            #[inline(always)]
            pub fn set_send_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[26\\]."]
            #[inline(always)]
            pub const fn send_26(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[26\\]."]
            #[inline(always)]
            pub fn set_send_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[27\\]."]
            #[inline(always)]
            pub const fn send_27(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[27\\]."]
            #[inline(always)]
            pub fn set_send_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[28\\]."]
            #[inline(always)]
            pub const fn send_28(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[28\\]."]
            #[inline(always)]
            pub fn set_send_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[29\\]."]
            #[inline(always)]
            pub const fn send_29(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[29\\]."]
            #[inline(always)]
            pub fn set_send_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[30\\]."]
            #[inline(always)]
            pub const fn send_30(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[30\\]."]
            #[inline(always)]
            pub fn set_send_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[31\\]."]
            #[inline(always)]
            pub const fn send_31(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "The status for tasks overflow at SUBSCRIBE_SEND\\[31\\]."]
            #[inline(always)]
            pub fn set_send_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Send {
            #[inline(always)]
            fn default() -> Send {
                Send(0)
            }
        }
        impl core::fmt::Debug for Send {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Send")
                    .field("send_0", &self.send_0())
                    .field("send_1", &self.send_1())
                    .field("send_2", &self.send_2())
                    .field("send_3", &self.send_3())
                    .field("send_4", &self.send_4())
                    .field("send_5", &self.send_5())
                    .field("send_6", &self.send_6())
                    .field("send_7", &self.send_7())
                    .field("send_8", &self.send_8())
                    .field("send_9", &self.send_9())
                    .field("send_10", &self.send_10())
                    .field("send_11", &self.send_11())
                    .field("send_12", &self.send_12())
                    .field("send_13", &self.send_13())
                    .field("send_14", &self.send_14())
                    .field("send_15", &self.send_15())
                    .field("send_16", &self.send_16())
                    .field("send_17", &self.send_17())
                    .field("send_18", &self.send_18())
                    .field("send_19", &self.send_19())
                    .field("send_20", &self.send_20())
                    .field("send_21", &self.send_21())
                    .field("send_22", &self.send_22())
                    .field("send_23", &self.send_23())
                    .field("send_24", &self.send_24())
                    .field("send_25", &self.send_25())
                    .field("send_26", &self.send_26())
                    .field("send_27", &self.send_27())
                    .field("send_28", &self.send_28())
                    .field("send_29", &self.send_29())
                    .field("send_30", &self.send_30())
                    .field("send_31", &self.send_31())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Send {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Send {
                    send_0: bool,
                    send_1: bool,
                    send_2: bool,
                    send_3: bool,
                    send_4: bool,
                    send_5: bool,
                    send_6: bool,
                    send_7: bool,
                    send_8: bool,
                    send_9: bool,
                    send_10: bool,
                    send_11: bool,
                    send_12: bool,
                    send_13: bool,
                    send_14: bool,
                    send_15: bool,
                    send_16: bool,
                    send_17: bool,
                    send_18: bool,
                    send_19: bool,
                    send_20: bool,
                    send_21: bool,
                    send_22: bool,
                    send_23: bool,
                    send_24: bool,
                    send_25: bool,
                    send_26: bool,
                    send_27: bool,
                    send_28: bool,
                    send_29: bool,
                    send_30: bool,
                    send_31: bool,
                }
                let proxy = Send {
                    send_0: self.send_0(),
                    send_1: self.send_1(),
                    send_2: self.send_2(),
                    send_3: self.send_3(),
                    send_4: self.send_4(),
                    send_5: self.send_5(),
                    send_6: self.send_6(),
                    send_7: self.send_7(),
                    send_8: self.send_8(),
                    send_9: self.send_9(),
                    send_10: self.send_10(),
                    send_11: self.send_11(),
                    send_12: self.send_12(),
                    send_13: self.send_13(),
                    send_14: self.send_14(),
                    send_15: self.send_15(),
                    send_16: self.send_16(),
                    send_17: self.send_17(),
                    send_18: self.send_18(),
                    send_19: self.send_19(),
                    send_20: self.send_20(),
                    send_21: self.send_21(),
                    send_22: self.send_22(),
                    send_23: self.send_23(),
                    send_24: self.send_24(),
                    send_25: self.send_25(),
                    send_26: self.send_26(),
                    send_27: self.send_27(),
                    send_28: self.send_28(),
                    send_29: self.send_29(),
                    send_30: self.send_30(),
                    send_31: self.send_31(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod pwm {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> DmaSeq {
            assert!(n < 2usize);
            unsafe { DmaSeq::from_ptr(self.ptr.add(0x0usize + n * 36usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaSeq {}
    unsafe impl Sync for DmaSeq {}
    impl DmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Number of bytes transferred in the last transaction, updated after the END event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Description cluster: Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::Terminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Description cluster: Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> EventsDmaSeq {
            assert!(n < 2usize);
            unsafe { EventsDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 12usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaSeq {}
    unsafe impl Sync for EventsDmaSeq {}
    impl EventsDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Output pin select for PWM channel n"]
        #[inline(always)]
        pub const fn out(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> PublishDmaSeq {
            assert!(n < 2usize);
            unsafe { PublishDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 12usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaSeq {}
    unsafe impl Sync for PublishDmaSeq {}
    impl PublishDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Pulse width modulation unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pwm {
        ptr: *mut u8,
    }
    unsafe impl Send for Pwm {}
    unsafe impl Sync for Pwm {}
    impl Pwm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stops PWM pulse generation on all channels at the end of current PWM period, and stops sequence playback"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Steps by one value in the current sequence on all enabled channels if DECODER.MODE=NextStep. Does not cause PWM generation to start if not running."]
        #[inline(always)]
        pub const fn tasks_nextstep(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task NEXTSTEP"]
        #[inline(always)]
        pub const fn subscribe_nextstep(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Response to STOP task, emitted when PWM pulses are no longer generated"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Description collection: First PWM period started on sequence n"]
        #[inline(always)]
        pub const fn events_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Emitted at end of every sequence n, when last value from RAM has been applied to wave counter"]
        #[inline(always)]
        pub const fn events_seqend(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize + n * 4usize) as _) }
        }
        #[doc = "Emitted at the end of each PWM period"]
        #[inline(always)]
        pub const fn events_pwmperiodend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Concatenated sequences have been played the amount of times defined in LOOP.CNT"]
        #[inline(always)]
        pub const fn events_loopsdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Emitted when retrieving from RAM does not complete in time for the PWM module"]
        #[inline(always)]
        pub const fn events_ramunderflow(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Description collection: This event is generated when the compare matches for the compare channel \\[n\\]."]
        #[inline(always)]
        pub const fn events_comparematch(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event SEQSTARTED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqstarted(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event SEQEND\\[n\\]"]
        #[inline(always)]
        pub const fn publish_seqend(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for event PWMPERIODEND"]
        #[inline(always)]
        pub const fn publish_pwmperiodend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for event LOOPSDONE"]
        #[inline(always)]
        pub const fn publish_loopsdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x019cusize) as _) }
        }
        #[doc = "Publish configuration for event RAMUNDERFLOW"]
        #[inline(always)]
        pub const fn publish_ramunderflow(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPAREMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn publish_comparematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01bcusize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "PWM module enable register"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[inline(always)]
        pub const fn countertop(self) -> crate::common::Reg<regs::Countertop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Configuration of the decoder"]
        #[inline(always)]
        pub const fn decoder(self) -> crate::common::Reg<regs::Decoder, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Number of playbacks of a loop"]
        #[inline(always)]
        pub const fn loop_(self) -> crate::common::Reg<regs::Loop, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0514usize) as _) }
        }
        #[doc = "Configure the output value on the PWM channel during idle"]
        #[inline(always)]
        pub const fn idleout(self) -> crate::common::Reg<regs::Idleout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> PwmSeq {
            assert!(n < 2usize);
            unsafe { PwmSeq::from_ptr(self.ptr.add(0x0520usize + n * 32usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0560usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PwmSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for PwmSeq {}
    unsafe impl Sync for PwmSeq {}
    impl PwmSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[inline(always)]
        pub const fn refresh(self) -> crate::common::Reg<regs::Refresh, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[inline(always)]
        pub const fn enddelay(self) -> crate::common::Reg<regs::Enddelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> SubscribeDmaSeq {
            assert!(n < 2usize);
            unsafe { SubscribeDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaSeq {}
    unsafe impl Sync for SubscribeDmaSeq {}
    impl SubscribeDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn seq(self, n: usize) -> TasksDmaSeq {
            assert!(n < 2usize);
            unsafe { TasksDmaSeq::from_ptr(self.ptr.add(0x0usize + n * 8usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaSeq {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaSeq {}
    unsafe impl Sync for TasksDmaSeq {}
    impl TasksDmaSeq {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Number of bytes transferred in the last transaction, updated after the END event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Amount {
                    amount: u16,
                }
                let proxy = Amount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Value up to which the pulse generator counter counts"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Countertop(pub u32);
        impl Countertop {
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Value up to which the pulse generator counter counts. This register is ignored when DECODER.MODE=WaveForm and only values from RAM are used."]
            #[inline(always)]
            pub fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Countertop {
            #[inline(always)]
            fn default() -> Countertop {
                Countertop(0)
            }
        }
        impl core::fmt::Debug for Countertop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Countertop")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Countertop {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Countertop {
                    countertop: u16,
                }
                let proxy = Countertop {
                    countertop: self.countertop(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Currentamount {
                    amount: u16,
                }
                let proxy = Currentamount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of the decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Decoder(pub u32);
        impl Decoder {
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[inline(always)]
            pub const fn load(&self) -> super::vals::Load {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Load::from_bits(val as u8)
            }
            #[doc = "How a sequence is read from RAM and spread to the compare register"]
            #[inline(always)]
            pub fn set_load(&mut self, val: super::vals::Load) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Selects source for advancing the active sequence"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Decoder {
            #[inline(always)]
            fn default() -> Decoder {
                Decoder(0)
            }
        }
        impl core::fmt::Debug for Decoder {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Decoder")
                    .field("load", &self.load())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Decoder {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Decoder {
                    load: super::vals::Load,
                    mode: super::vals::Mode,
                }
                let proxy = Decoder {
                    load: self.load(),
                    mode: self.mode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "PWM module enable register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable PWM module"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable PWM module"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Time added after the sequence"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enddelay(pub u32);
        impl Enddelay {
            #[doc = "Time added after the sequence in PWM periods"]
            #[inline(always)]
            pub const fn cnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Time added after the sequence in PWM periods"]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Enddelay {
            #[inline(always)]
            fn default() -> Enddelay {
                Enddelay(0)
            }
        }
        impl core::fmt::Debug for Enddelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enddelay")
                    .field("cnt", &self.cnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enddelay {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enddelay {
                    cnt: u32,
                }
                let proxy = Enddelay { cnt: self.cnt() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure the output value on the PWM channel during idle"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Idleout(pub u32);
        impl Idleout {
            #[doc = "Idle output value for PWM channel \\[0\\]"]
            #[inline(always)]
            pub const fn val_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[0\\]"]
            #[inline(always)]
            pub fn set_val_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Idle output value for PWM channel \\[1\\]"]
            #[inline(always)]
            pub const fn val_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[1\\]"]
            #[inline(always)]
            pub fn set_val_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Idle output value for PWM channel \\[2\\]"]
            #[inline(always)]
            pub const fn val_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[2\\]"]
            #[inline(always)]
            pub fn set_val_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Idle output value for PWM channel \\[3\\]"]
            #[inline(always)]
            pub const fn val_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Idle output value for PWM channel \\[3\\]"]
            #[inline(always)]
            pub fn set_val_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Idleout {
            #[inline(always)]
            fn default() -> Idleout {
                Idleout(0)
            }
        }
        impl core::fmt::Debug for Idleout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Idleout")
                    .field("val_0", &self.val_0())
                    .field("val_1", &self.val_1())
                    .field("val_2", &self.val_2())
                    .field("val_3", &self.val_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Idleout {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Idleout {
                    val_0: bool,
                    val_1: bool,
                    val_2: bool,
                    val_3: bool,
                }
                let proxy = Idleout {
                    val_0: self.val_0(),
                    val_1: self.val_1(),
                    val_2: self.val_2(),
                    val_3: self.val_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[inline(always)]
            pub const fn seqstarted0(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[0\\]"]
            #[inline(always)]
            pub fn set_seqstarted0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[inline(always)]
            pub const fn seqstarted1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQSTARTED\\[1\\]"]
            #[inline(always)]
            pub fn set_seqstarted1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[inline(always)]
            pub const fn seqend0(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[0\\]"]
            #[inline(always)]
            pub fn set_seqend0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[inline(always)]
            pub const fn seqend1(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SEQEND\\[1\\]"]
            #[inline(always)]
            pub fn set_seqend1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub const fn pwmperiodend(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PWMPERIODEND"]
            #[inline(always)]
            pub fn set_pwmperiodend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[inline(always)]
            pub const fn loopsdone(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LOOPSDONE"]
            #[inline(always)]
            pub fn set_loopsdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Enable or disable interrupt for event RAMUNDERFLOW"]
            #[inline(always)]
            pub const fn ramunderflow(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RAMUNDERFLOW"]
            #[inline(always)]
            pub fn set_ramunderflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0END"]
            #[inline(always)]
            pub const fn dmaseq0end(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0END"]
            #[inline(always)]
            pub fn set_dmaseq0end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0READY"]
            #[inline(always)]
            pub const fn dmaseq0ready(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0READY"]
            #[inline(always)]
            pub fn set_dmaseq0ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0BUSERROR"]
            #[inline(always)]
            pub const fn dmaseq0buserror(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ0BUSERROR"]
            #[inline(always)]
            pub fn set_dmaseq0buserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1END"]
            #[inline(always)]
            pub const fn dmaseq1end(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1END"]
            #[inline(always)]
            pub fn set_dmaseq1end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1READY"]
            #[inline(always)]
            pub const fn dmaseq1ready(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1READY"]
            #[inline(always)]
            pub fn set_dmaseq1ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1BUSERROR"]
            #[inline(always)]
            pub const fn dmaseq1buserror(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMASEQ1BUSERROR"]
            #[inline(always)]
            pub fn set_dmaseq1buserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event COMPAREMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn comparematch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 15usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPAREMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_comparematch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 15usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("seqstarted0", &self.seqstarted0())
                    .field("seqstarted1", &self.seqstarted1())
                    .field("seqend0", &self.seqend0())
                    .field("seqend1", &self.seqend1())
                    .field("pwmperiodend", &self.pwmperiodend())
                    .field("loopsdone", &self.loopsdone())
                    .field("ramunderflow", &self.ramunderflow())
                    .field("dmaseq0end", &self.dmaseq0end())
                    .field("dmaseq0ready", &self.dmaseq0ready())
                    .field("dmaseq0buserror", &self.dmaseq0buserror())
                    .field("dmaseq1end", &self.dmaseq1end())
                    .field("dmaseq1ready", &self.dmaseq1ready())
                    .field("dmaseq1buserror", &self.dmaseq1buserror())
                    .field(
                        "comparematch",
                        &[
                            self.comparematch(0usize),
                            self.comparematch(1usize),
                            self.comparematch(2usize),
                            self.comparematch(3usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    stopped: bool,
                    seqstarted0: bool,
                    seqstarted1: bool,
                    seqend0: bool,
                    seqend1: bool,
                    pwmperiodend: bool,
                    loopsdone: bool,
                    ramunderflow: bool,
                    dmaseq0end: bool,
                    dmaseq0ready: bool,
                    dmaseq0buserror: bool,
                    dmaseq1end: bool,
                    dmaseq1ready: bool,
                    dmaseq1buserror: bool,
                    comparematch: [bool; 4usize],
                }
                let proxy = Int {
                    stopped: self.stopped(),
                    seqstarted0: self.seqstarted0(),
                    seqstarted1: self.seqstarted1(),
                    seqend0: self.seqend0(),
                    seqend1: self.seqend1(),
                    pwmperiodend: self.pwmperiodend(),
                    loopsdone: self.loopsdone(),
                    ramunderflow: self.ramunderflow(),
                    dmaseq0end: self.dmaseq0end(),
                    dmaseq0ready: self.dmaseq0ready(),
                    dmaseq0buserror: self.dmaseq0buserror(),
                    dmaseq1end: self.dmaseq1end(),
                    dmaseq1ready: self.dmaseq1ready(),
                    dmaseq1buserror: self.dmaseq1buserror(),
                    comparematch: [
                        self.comparematch(0usize),
                        self.comparematch(1usize),
                        self.comparematch(2usize),
                        self.comparematch(3usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of playbacks of a loop"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Loop(pub u32);
        impl Loop {
            #[doc = "Number of playbacks of pattern cycles"]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::LoopCnt {
                let val = (self.0 >> 0usize) & 0xffff;
                super::vals::LoopCnt::from_bits(val as u16)
            }
            #[doc = "Number of playbacks of pattern cycles"]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: super::vals::LoopCnt) {
                self.0 =
                    (self.0 & !(0xffff << 0usize)) | (((val.to_bits() as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Loop {
            #[inline(always)]
            fn default() -> Loop {
                Loop(0)
            }
        }
        impl core::fmt::Debug for Loop {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Loop").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Loop {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Loop {
                    cnt: super::vals::LoopCnt,
                }
                let proxy = Loop { cnt: self.cnt() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxcnt {
                    maxcnt: u16,
                }
                let proxy = Maxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Selects operating mode of the wave counter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[inline(always)]
            pub const fn updown(&self) -> super::vals::Updown {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Updown::from_bits(val as u8)
            }
            #[doc = "Selects up mode or up-and-down mode for the counter"]
            #[inline(always)]
            pub fn set_updown(&mut self, val: super::vals::Updown) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode")
                    .field("updown", &self.updown())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    updown: super::vals::Updown,
                }
                let proxy = Mode {
                    updown: self.updown(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration for PWM_CLK"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler of PWM_CLK"]
            #[inline(always)]
            pub const fn prescaler(&self) -> super::vals::Prescaler {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Prescaler::from_bits(val as u8)
            }
            #[doc = "Prescaler of PWM_CLK"]
            #[inline(always)]
            pub fn set_prescaler(&mut self, val: super::vals::Prescaler) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Prescaler {
                    prescaler: super::vals::Prescaler,
                }
                let proxy = Prescaler {
                    prescaler: self.prescaler(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Number of additional PWM periods between samples loaded into compare register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Refresh(pub u32);
        impl Refresh {
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[inline(always)]
            pub const fn cnt(&self) -> super::vals::RefreshCnt {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                super::vals::RefreshCnt::from_bits(val as u32)
            }
            #[doc = "Number of additional PWM periods between samples loaded into compare register (load every REFRESH.CNT+1 PWM periods)"]
            #[inline(always)]
            pub fn set_cnt(&mut self, val: super::vals::RefreshCnt) {
                self.0 = (self.0 & !(0x00ff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Refresh {
            #[inline(always)]
            fn default() -> Refresh {
                Refresh(0)
            }
        }
        impl core::fmt::Debug for Refresh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Refresh").field("cnt", &self.cnt()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Refresh {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Refresh {
                    cnt: super::vals::RefreshCnt,
                }
                let proxy = Refresh { cnt: self.cnt() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub const fn seqend0_stop(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub fn set_seqend0_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub const fn seqend1_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SEQEND\\[n\\] and task STOP"]
            #[inline(always)]
            pub fn set_seqend1_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub const fn loopsdone_dma_seq0_start(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub fn set_loopsdone_dma_seq0_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub const fn loopsdone_dma_seq1_start(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task DMA.SEQ\\[n\\].START"]
            #[inline(always)]
            pub fn set_loopsdone_dma_seq1_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[inline(always)]
            pub const fn loopsdone_stop(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LOOPSDONE and task STOP"]
            #[inline(always)]
            pub fn set_loopsdone_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event RAMUNDERFLOW and task STOP"]
            #[inline(always)]
            pub const fn ramunderflow_stop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RAMUNDERFLOW and task STOP"]
            #[inline(always)]
            pub fn set_ramunderflow_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub const fn dma_seq0_buserror_stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub fn set_dma_seq0_buserror_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub const fn dma_seq1_buserror_stop(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.SEQ\\[n\\].BUSERROR and task STOP"]
            #[inline(always)]
            pub fn set_dma_seq1_buserror_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("seqend0_stop", &self.seqend0_stop())
                    .field("seqend1_stop", &self.seqend1_stop())
                    .field("loopsdone_dma_seq0_start", &self.loopsdone_dma_seq0_start())
                    .field("loopsdone_dma_seq1_start", &self.loopsdone_dma_seq1_start())
                    .field("loopsdone_stop", &self.loopsdone_stop())
                    .field("ramunderflow_stop", &self.ramunderflow_stop())
                    .field("dma_seq0_buserror_stop", &self.dma_seq0_buserror_stop())
                    .field("dma_seq1_buserror_stop", &self.dma_seq1_buserror_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    seqend0_stop: bool,
                    seqend1_stop: bool,
                    loopsdone_dma_seq0_start: bool,
                    loopsdone_dma_seq1_start: bool,
                    loopsdone_stop: bool,
                    ramunderflow_stop: bool,
                    dma_seq0_buserror_stop: bool,
                    dma_seq1_buserror_stop: bool,
                }
                let proxy = Shorts {
                    seqend0_stop: self.seqend0_stop(),
                    seqend1_stop: self.seqend1_stop(),
                    loopsdone_dma_seq0_start: self.loopsdone_dma_seq0_start(),
                    loopsdone_dma_seq1_start: self.loopsdone_dma_seq1_start(),
                    loopsdone_stop: self.loopsdone_stop(),
                    ramunderflow_stop: self.ramunderflow_stop(),
                    dma_seq0_buserror_stop: self.dma_seq0_buserror_stop(),
                    dma_seq1_buserror_stop: self.dma_seq1_buserror_stop(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Terminateonbuserror(pub u32);
        impl Terminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Terminateonbuserror {
            #[inline(always)]
            fn default() -> Terminateonbuserror {
                Terminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for Terminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Terminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Terminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Terminateonbuserror {
                    enable: bool,
                }
                let proxy = Terminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Load {
            #[doc = "1st half word (16-bit) used in all PWM channels 0..3"]
            COMMON = 0x0,
            #[doc = "1st half word (16-bit) used in channel 0..1; 2nd word in channel 2..3"]
            GROUPED = 0x01,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in ch.3"]
            INDIVIDUAL = 0x02,
            #[doc = "1st half word (16-bit) in ch.0; 2nd in ch.1; ...; 4th in COUNTERTOP"]
            WAVE_FORM = 0x03,
        }
        impl Load {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Load {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Load {
            #[inline(always)]
            fn from(val: u8) -> Load {
                Load::from_bits(val)
            }
        }
        impl From<Load> for u8 {
            #[inline(always)]
            fn from(val: Load) -> u8 {
                Load::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct LoopCnt(pub u16);
        impl LoopCnt {
            #[doc = "Looping disabled (stop at the end of the sequence)"]
            pub const DISABLED: Self = Self(0x0);
        }
        impl LoopCnt {
            pub const fn from_bits(val: u16) -> LoopCnt {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for LoopCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("DISABLED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for LoopCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "DISABLED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for LoopCnt {
            #[inline(always)]
            fn from(val: u16) -> LoopCnt {
                LoopCnt::from_bits(val)
            }
        }
        impl From<LoopCnt> for u16 {
            #[inline(always)]
            fn from(val: LoopCnt) -> u16 {
                LoopCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "SEQ\\[n\\].REFRESH is used to determine loading internal compare registers"]
            REFRESH_COUNT = 0x0,
            #[doc = "NEXTSTEP task causes a new value to be loaded to internal compare registers"]
            NEXT_STEP = 0x01,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Prescaler {
            #[doc = "Divide by 1 (16 MHz)"]
            DIV_1 = 0x0,
            #[doc = "Divide by 2 (8 MHz)"]
            DIV_2 = 0x01,
            #[doc = "Divide by 4 (4 MHz)"]
            DIV_4 = 0x02,
            #[doc = "Divide by 8 (2 MHz)"]
            DIV_8 = 0x03,
            #[doc = "Divide by 16 (1 MHz)"]
            DIV_16 = 0x04,
            #[doc = "Divide by 32 (500 kHz)"]
            DIV_32 = 0x05,
            #[doc = "Divide by 64 (250 kHz)"]
            DIV_64 = 0x06,
            #[doc = "Divide by 128 (125 kHz)"]
            DIV_128 = 0x07,
        }
        impl Prescaler {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Prescaler {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Prescaler {
            #[inline(always)]
            fn from(val: u8) -> Prescaler {
                Prescaler::from_bits(val)
            }
        }
        impl From<Prescaler> for u8 {
            #[inline(always)]
            fn from(val: Prescaler) -> u8 {
                Prescaler::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct RefreshCnt(pub u32);
        impl RefreshCnt {
            #[doc = "Update every PWM period"]
            pub const CONTINUOUS: Self = Self(0x0);
        }
        impl RefreshCnt {
            pub const fn from_bits(val: u32) -> RefreshCnt {
                Self(val & 0x00ff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for RefreshCnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("CONTINUOUS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RefreshCnt {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "CONTINUOUS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for RefreshCnt {
            #[inline(always)]
            fn from(val: u32) -> RefreshCnt {
                RefreshCnt::from_bits(val)
            }
        }
        impl From<RefreshCnt> for u32 {
            #[inline(always)]
            fn from(val: RefreshCnt) -> u32 {
                RefreshCnt::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Updown {
            #[doc = "Up counter, edge-aligned PWM duty cycle"]
            UP = 0x0,
            #[doc = "Up and down counter, center-aligned PWM duty cycle"]
            UP_AND_DOWN = 0x01,
        }
        impl Updown {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Updown {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Updown {
            #[inline(always)]
            fn from(val: u8) -> Updown {
                Updown::from_bits(val)
            }
        }
        impl From<Updown> for u8 {
            #[inline(always)]
            fn from(val: Updown) -> u8 {
                Updown::to_bits(val)
            }
        }
    }
}
pub mod qdec {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for LED signal"]
        #[inline(always)]
        pub const fn led(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for A signal"]
        #[inline(always)]
        pub const fn a(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for B signal"]
        #[inline(always)]
        pub const fn b(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Quadrature Decoder 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Qdec {
        ptr: *mut u8,
    }
    unsafe impl Send for Qdec {}
    unsafe impl Sync for Qdec {}
    impl Qdec {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Task starting the quadrature decoder"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Task stopping the quadrature decoder"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Read and clear ACC and ACCDBL"]
        #[inline(always)]
        pub const fn tasks_readclracc(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Read and clear ACC"]
        #[inline(always)]
        pub const fn tasks_rdclracc(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Read and clear ACCDBL"]
        #[inline(always)]
        pub const fn tasks_rdclrdbl(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task READCLRACC"]
        #[inline(always)]
        pub const fn subscribe_readclracc(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task RDCLRACC"]
        #[inline(always)]
        pub const fn subscribe_rdclracc(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RDCLRDBL"]
        #[inline(always)]
        pub const fn subscribe_rdclrdbl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Event being generated for every new sample value written to the SAMPLE register"]
        #[inline(always)]
        pub const fn events_samplerdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Non-null report ready"]
        #[inline(always)]
        pub const fn events_reportrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "ACC or ACCDBL register overflow"]
        #[inline(always)]
        pub const fn events_accof(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Double displacement(s) detected"]
        #[inline(always)]
        pub const fn events_dblrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "QDEC has been stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event SAMPLERDY"]
        #[inline(always)]
        pub const fn publish_samplerdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event REPORTRDY"]
        #[inline(always)]
        pub const fn publish_reportrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ACCOF"]
        #[inline(always)]
        pub const fn publish_accof(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event DBLRDY"]
        #[inline(always)]
        pub const fn publish_dblrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable the quadrature decoder"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "LED output pin polarity"]
        #[inline(always)]
        pub const fn ledpol(self) -> crate::common::Reg<regs::Ledpol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Sample period"]
        #[inline(always)]
        pub const fn sampleper(self) -> crate::common::Reg<regs::Sampleper, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Motion sample value"]
        #[inline(always)]
        pub const fn sample(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"]
        #[inline(always)]
        pub const fn reportper(self) -> crate::common::Reg<regs::Reportper, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Register accumulating the valid transitions"]
        #[inline(always)]
        pub const fn acc(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0514usize) as _) }
        }
        #[doc = "Snapshot of the ACC register, updated by the READCLRACC or RDCLRACC task"]
        #[inline(always)]
        pub const fn accread(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x051cusize) as _) }
        }
        #[doc = "Enable input debounce filters"]
        #[inline(always)]
        pub const fn dbfen(self) -> crate::common::Reg<regs::Dbfen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0528usize) as _) }
        }
        #[doc = "Time period the LED is switched ON prior to sampling"]
        #[inline(always)]
        pub const fn ledpre(self) -> crate::common::Reg<regs::Ledpre, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Register accumulating the number of detected double transitions"]
        #[inline(always)]
        pub const fn accdbl(self) -> crate::common::Reg<regs::Accdbl, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0544usize) as _) }
        }
        #[doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"]
        #[inline(always)]
        pub const fn accdblread(self) -> crate::common::Reg<regs::Accdblread, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0548usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Register accumulating the number of detected double transitions"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Accdbl(pub u32);
        impl Accdbl {
            #[doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."]
            #[inline(always)]
            pub const fn accdbl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Register accumulating the number of detected double or illegal transitions. ( SAMPLE = 2 )."]
            #[inline(always)]
            pub fn set_accdbl(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Accdbl {
            #[inline(always)]
            fn default() -> Accdbl {
                Accdbl(0)
            }
        }
        impl core::fmt::Debug for Accdbl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Accdbl")
                    .field("accdbl", &self.accdbl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Accdbl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Accdbl {
                    accdbl: u8,
                }
                let proxy = Accdbl {
                    accdbl: self.accdbl(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Snapshot of the ACCDBL, updated by the READCLRACC or RDCLRDBL task"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Accdblread(pub u32);
        impl Accdblread {
            #[doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."]
            #[inline(always)]
            pub const fn accdblread(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Snapshot of the ACCDBL register. This field is updated when the READCLRACC or RDCLRDBL task is triggered."]
            #[inline(always)]
            pub fn set_accdblread(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Accdblread {
            #[inline(always)]
            fn default() -> Accdblread {
                Accdblread(0)
            }
        }
        impl core::fmt::Debug for Accdblread {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Accdblread")
                    .field("accdblread", &self.accdblread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Accdblread {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Accdblread {
                    accdblread: u8,
                }
                let proxy = Accdblread {
                    accdblread: self.accdblread(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable input debounce filters"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbfen(pub u32);
        impl Dbfen {
            #[doc = "Enable input debounce filters"]
            #[inline(always)]
            pub const fn dbfen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable input debounce filters"]
            #[inline(always)]
            pub fn set_dbfen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dbfen {
            #[inline(always)]
            fn default() -> Dbfen {
                Dbfen(0)
            }
        }
        impl core::fmt::Debug for Dbfen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbfen")
                    .field("dbfen", &self.dbfen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbfen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dbfen {
                    dbfen: bool,
                }
                let proxy = Dbfen {
                    dbfen: self.dbfen(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable the quadrature decoder"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable the quadrature decoder"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable the quadrature decoder"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event SAMPLERDY"]
            #[inline(always)]
            pub const fn samplerdy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event SAMPLERDY"]
            #[inline(always)]
            pub fn set_samplerdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event REPORTRDY"]
            #[inline(always)]
            pub const fn reportrdy(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event REPORTRDY"]
            #[inline(always)]
            pub fn set_reportrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACCOF"]
            #[inline(always)]
            pub const fn accof(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACCOF"]
            #[inline(always)]
            pub fn set_accof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event DBLRDY"]
            #[inline(always)]
            pub const fn dblrdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DBLRDY"]
            #[inline(always)]
            pub fn set_dblrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("samplerdy", &self.samplerdy())
                    .field("reportrdy", &self.reportrdy())
                    .field("accof", &self.accof())
                    .field("dblrdy", &self.dblrdy())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    samplerdy: bool,
                    reportrdy: bool,
                    accof: bool,
                    dblrdy: bool,
                    stopped: bool,
                }
                let proxy = Int {
                    samplerdy: self.samplerdy(),
                    reportrdy: self.reportrdy(),
                    accof: self.accof(),
                    dblrdy: self.dblrdy(),
                    stopped: self.stopped(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "LED output pin polarity"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ledpol(pub u32);
        impl Ledpol {
            #[doc = "LED output pin polarity"]
            #[inline(always)]
            pub const fn ledpol(&self) -> super::vals::Ledpol {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ledpol::from_bits(val as u8)
            }
            #[doc = "LED output pin polarity"]
            #[inline(always)]
            pub fn set_ledpol(&mut self, val: super::vals::Ledpol) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ledpol {
            #[inline(always)]
            fn default() -> Ledpol {
                Ledpol(0)
            }
        }
        impl core::fmt::Debug for Ledpol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ledpol")
                    .field("ledpol", &self.ledpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ledpol {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ledpol {
                    ledpol: super::vals::Ledpol,
                }
                let proxy = Ledpol {
                    ledpol: self.ledpol(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Time period the LED is switched ON prior to sampling"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ledpre(pub u32);
        impl Ledpre {
            #[doc = "Period in us the LED is switched on prior to sampling"]
            #[inline(always)]
            pub const fn ledpre(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Period in us the LED is switched on prior to sampling"]
            #[inline(always)]
            pub fn set_ledpre(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
        }
        impl Default for Ledpre {
            #[inline(always)]
            fn default() -> Ledpre {
                Ledpre(0)
            }
        }
        impl core::fmt::Debug for Ledpre {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ledpre")
                    .field("ledpre", &self.ledpre())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ledpre {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ledpre {
                    ledpre: u16,
                }
                let proxy = Ledpre {
                    ledpre: self.ledpre(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of samples to be taken before REPORTRDY and DBLRDY events can be generated"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reportper(pub u32);
        impl Reportper {
            #[doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated."]
            #[inline(always)]
            pub const fn reportper(&self) -> super::vals::Reportper {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Reportper::from_bits(val as u8)
            }
            #[doc = "Specifies the number of samples to be accumulated in the ACC register before the REPORTRDY and DBLRDY events can be generated."]
            #[inline(always)]
            pub fn set_reportper(&mut self, val: super::vals::Reportper) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Reportper {
            #[inline(always)]
            fn default() -> Reportper {
                Reportper(0)
            }
        }
        impl core::fmt::Debug for Reportper {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reportper")
                    .field("reportper", &self.reportper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reportper {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Reportper {
                    reportper: super::vals::Reportper,
                }
                let proxy = Reportper {
                    reportper: self.reportper(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sample period"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sampleper(pub u32);
        impl Sampleper {
            #[doc = "Sample period. The SAMPLE register will be updated for every new sample"]
            #[inline(always)]
            pub const fn sampleper(&self) -> super::vals::Sampleper {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Sampleper::from_bits(val as u8)
            }
            #[doc = "Sample period. The SAMPLE register will be updated for every new sample"]
            #[inline(always)]
            pub fn set_sampleper(&mut self, val: super::vals::Sampleper) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Sampleper {
            #[inline(always)]
            fn default() -> Sampleper {
                Sampleper(0)
            }
        }
        impl core::fmt::Debug for Sampleper {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sampleper")
                    .field("sampleper", &self.sampleper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sampleper {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Sampleper {
                    sampleper: super::vals::Sampleper,
                }
                let proxy = Sampleper {
                    sampleper: self.sampleper(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event REPORTRDY and task READCLRACC"]
            #[inline(always)]
            pub const fn reportrdy_readclracc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task READCLRACC"]
            #[inline(always)]
            pub fn set_reportrdy_readclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event SAMPLERDY and task STOP"]
            #[inline(always)]
            pub const fn samplerdy_stop(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SAMPLERDY and task STOP"]
            #[inline(always)]
            pub fn set_samplerdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Shortcut between event REPORTRDY and task RDCLRACC"]
            #[inline(always)]
            pub const fn reportrdy_rdclracc(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task RDCLRACC"]
            #[inline(always)]
            pub fn set_reportrdy_rdclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event REPORTRDY and task STOP"]
            #[inline(always)]
            pub const fn reportrdy_stop(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event REPORTRDY and task STOP"]
            #[inline(always)]
            pub fn set_reportrdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event DBLRDY and task RDCLRDBL"]
            #[inline(always)]
            pub const fn dblrdy_rdclrdbl(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DBLRDY and task RDCLRDBL"]
            #[inline(always)]
            pub fn set_dblrdy_rdclrdbl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event DBLRDY and task STOP"]
            #[inline(always)]
            pub const fn dblrdy_stop(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DBLRDY and task STOP"]
            #[inline(always)]
            pub fn set_dblrdy_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event SAMPLERDY and task READCLRACC"]
            #[inline(always)]
            pub const fn samplerdy_readclracc(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event SAMPLERDY and task READCLRACC"]
            #[inline(always)]
            pub fn set_samplerdy_readclracc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("reportrdy_readclracc", &self.reportrdy_readclracc())
                    .field("samplerdy_stop", &self.samplerdy_stop())
                    .field("reportrdy_rdclracc", &self.reportrdy_rdclracc())
                    .field("reportrdy_stop", &self.reportrdy_stop())
                    .field("dblrdy_rdclrdbl", &self.dblrdy_rdclrdbl())
                    .field("dblrdy_stop", &self.dblrdy_stop())
                    .field("samplerdy_readclracc", &self.samplerdy_readclracc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    reportrdy_readclracc: bool,
                    samplerdy_stop: bool,
                    reportrdy_rdclracc: bool,
                    reportrdy_stop: bool,
                    dblrdy_rdclrdbl: bool,
                    dblrdy_stop: bool,
                    samplerdy_readclracc: bool,
                }
                let proxy = Shorts {
                    reportrdy_readclracc: self.reportrdy_readclracc(),
                    samplerdy_stop: self.samplerdy_stop(),
                    reportrdy_rdclracc: self.reportrdy_rdclracc(),
                    reportrdy_stop: self.reportrdy_stop(),
                    dblrdy_rdclrdbl: self.dblrdy_rdclrdbl(),
                    dblrdy_stop: self.dblrdy_stop(),
                    samplerdy_readclracc: self.samplerdy_readclracc(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ledpol {
            #[doc = "Led active on output pin low"]
            ACTIVE_LOW = 0x0,
            #[doc = "Led active on output pin high"]
            ACTIVE_HIGH = 0x01,
        }
        impl Ledpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ledpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ledpol {
            #[inline(always)]
            fn from(val: u8) -> Ledpol {
                Ledpol::from_bits(val)
            }
        }
        impl From<Ledpol> for u8 {
            #[inline(always)]
            fn from(val: Ledpol) -> u8 {
                Ledpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Reportper {
            #[doc = "10 samples/report"]
            _10SMPL = 0x0,
            #[doc = "40 samples/report"]
            _40SMPL = 0x01,
            #[doc = "80 samples/report"]
            _80SMPL = 0x02,
            #[doc = "120 samples/report"]
            _120SMPL = 0x03,
            #[doc = "160 samples/report"]
            _160SMPL = 0x04,
            #[doc = "200 samples/report"]
            _200SMPL = 0x05,
            #[doc = "240 samples/report"]
            _240SMPL = 0x06,
            #[doc = "280 samples/report"]
            _280SMPL = 0x07,
            #[doc = "1 sample/report"]
            _1SMPL = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Reportper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Reportper {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Reportper {
            #[inline(always)]
            fn from(val: u8) -> Reportper {
                Reportper::from_bits(val)
            }
        }
        impl From<Reportper> for u8 {
            #[inline(always)]
            fn from(val: Reportper) -> u8 {
                Reportper::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sampleper {
            #[doc = "128 us"]
            _128US = 0x0,
            #[doc = "256 us"]
            _256US = 0x01,
            #[doc = "512 us"]
            _512US = 0x02,
            #[doc = "1024 us"]
            _1024US = 0x03,
            #[doc = "2048 us"]
            _2048US = 0x04,
            #[doc = "4096 us"]
            _4096US = 0x05,
            #[doc = "8192 us"]
            _8192US = 0x06,
            #[doc = "16384 us"]
            _16384US = 0x07,
            #[doc = "32768 us"]
            _32MS = 0x08,
            #[doc = "65536 us"]
            _65MS = 0x09,
            #[doc = "131072 us"]
            _131MS = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sampleper {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sampleper {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sampleper {
            #[inline(always)]
            fn from(val: u8) -> Sampleper {
                Sampleper::from_bits(val)
            }
        }
        impl From<Sampleper> for u8 {
            #[inline(always)]
            fn from(val: Sampleper) -> u8 {
                Sampleper::to_bits(val)
            }
        }
    }
}
pub mod radio {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cstones {
        ptr: *mut u8,
    }
    unsafe impl Send for Cstones {}
    unsafe impl Sync for Cstones {}
    impl Cstones {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Selects the mode(s) that are activated on the start signal"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::CstonesMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Number of input samples at 2MHz sample rate"]
        #[inline(always)]
        pub const fn numsamples(self) -> crate::common::Reg<regs::Numsamples, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The value of FREQUENCY that will be used in the next step"]
        #[inline(always)]
        pub const fn nextfrequency(
            self,
        ) -> crate::common::Reg<regs::Nextfrequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Override value of FFO (Fractional Frequency Offset) if not to be based on the frequency estimate derived from CnAcc (autocorrelation of the scaled input signal) value"]
        #[inline(always)]
        pub const fn ffoin(self) -> crate::common::Reg<regs::Ffoin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Source of FFO"]
        #[inline(always)]
        pub const fn ffosource(self) -> crate::common::Reg<regs::Ffosource, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "FAEPEER (Frequency Actuation Error) of peer if known. Used during Mode 0 steps."]
        #[inline(always)]
        pub const fn faepeer(self) -> crate::common::Reg<regs::Faepeer, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[inline(always)]
        pub const fn phaseshift(self) -> crate::common::Reg<regs::Phaseshift, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[inline(always)]
        pub const fn numsamplescoeff(
            self,
        ) -> crate::common::Reg<regs::Numsamplescoeff, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ"]
        #[inline(always)]
        pub const fn pct16(self) -> crate::common::Reg<regs::Pct16, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Mean magnitude and phase of the signal before it is converted to PCT16"]
        #[inline(always)]
        pub const fn magphasemean(
            self,
        ) -> crate::common::Reg<regs::Magphasemean, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Mean of IQ values"]
        #[inline(always)]
        pub const fn iqrawmean(self) -> crate::common::Reg<regs::Iqrawmean, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Magnitude standard deviation approximation"]
        #[inline(always)]
        pub const fn magstd(self) -> crate::common::Reg<regs::Magstd, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Output of the autocorrelation of the accumulated IQ signal"]
        #[inline(always)]
        pub const fn cnacc(self) -> crate::common::Reg<regs::Cnacc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "FFO estimate"]
        #[inline(always)]
        pub const fn ffoest(self) -> crate::common::Reg<regs::Ffoest, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x34usize) as _) }
        }
        #[doc = "Turn on/off down sample of input IQ-signals"]
        #[inline(always)]
        pub const fn downsample(self) -> crate::common::Reg<regs::Downsample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x38usize) as _) }
        }
        #[doc = "Number of full ADPLL finetune steps"]
        #[inline(always)]
        pub const fn finetunenext(
            self,
        ) -> crate::common::Reg<regs::Finetunenext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x3cusize) as _) }
        }
        #[doc = "Cordic output of CnAcc"]
        #[inline(always)]
        pub const fn cfophase(self) -> crate::common::Reg<regs::Cfophase, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Frequency offset estimate"]
        #[inline(always)]
        pub const fn freqoffset(self) -> crate::common::Reg<regs::Freqoffset, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ. IQ values limited to \\[-1024,1023\\]."]
        #[inline(always)]
        pub const fn pct11(self) -> crate::common::Reg<regs::Pct11, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "Quantization error between ADPLL frequency and the desired value of FFO * RF Frequency. Values limited to \\[-64,63\\] with units 7.6294 Hz."]
        #[inline(always)]
        pub const fn lfaenext(self) -> crate::common::Reg<regs::Lfaenext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
    }
    #[doc = "DFE packet EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dfepacket {
        ptr: *mut u8,
    }
    unsafe impl Send for Dfepacket {}
    unsafe impl Sync for Dfepacket {}
    impl Dfepacket {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Maximum number of bytes to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Pin select for DFE pin n"]
        #[inline(always)]
        pub const fn dfegpio(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "2.4 GHz radio 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Radio {
        ptr: *mut u8,
    }
    unsafe impl Send for Radio {}
    unsafe impl Sync for Radio {}
    impl Radio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable RADIO in TX mode"]
        #[inline(always)]
        pub const fn tasks_txen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Enable RADIO in RX mode"]
        #[inline(always)]
        pub const fn tasks_rxen(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Start RADIO"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Stop RADIO"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Disable RADIO"]
        #[inline(always)]
        pub const fn tasks_disable(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Start the RSSI and take one single sample of the receive signal strength"]
        #[inline(always)]
        pub const fn tasks_rssistart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Start the bit counter"]
        #[inline(always)]
        pub const fn tasks_bcstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Stop the bit counter"]
        #[inline(always)]
        pub const fn tasks_bcstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Start the energy detect measurement used in IEEE 802.15.4 mode"]
        #[inline(always)]
        pub const fn tasks_edstart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Stop the energy detect measurement"]
        #[inline(always)]
        pub const fn tasks_edstop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Start the clear channel assessment used in IEEE 802.15.4 mode"]
        #[inline(always)]
        pub const fn tasks_ccastart(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Stop the clear channel assessment"]
        #[inline(always)]
        pub const fn tasks_ccastop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x2cusize) as _) }
        }
        #[doc = "Reset all public registers, but with these exceptions: DMA registers and EVENT/INTEN/SUBSCRIBE/PUBLISH registers. Only to be used in DISABLED state."]
        #[inline(always)]
        pub const fn tasks_softreset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for task TXEN"]
        #[inline(always)]
        pub const fn subscribe_txen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Subscribe configuration for task RXEN"]
        #[inline(always)]
        pub const fn subscribe_rxen(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Subscribe configuration for task DISABLE"]
        #[inline(always)]
        pub const fn subscribe_disable(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Subscribe configuration for task RSSISTART"]
        #[inline(always)]
        pub const fn subscribe_rssistart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Subscribe configuration for task BCSTART"]
        #[inline(always)]
        pub const fn subscribe_bcstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Subscribe configuration for task BCSTOP"]
        #[inline(always)]
        pub const fn subscribe_bcstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x011cusize) as _) }
        }
        #[doc = "Subscribe configuration for task EDSTART"]
        #[inline(always)]
        pub const fn subscribe_edstart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0120usize) as _) }
        }
        #[doc = "Subscribe configuration for task EDSTOP"]
        #[inline(always)]
        pub const fn subscribe_edstop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Subscribe configuration for task CCASTART"]
        #[inline(always)]
        pub const fn subscribe_ccastart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Subscribe configuration for task CCASTOP"]
        #[inline(always)]
        pub const fn subscribe_ccastop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x012cusize) as _) }
        }
        #[doc = "Subscribe configuration for task SOFTRESET"]
        #[inline(always)]
        pub const fn subscribe_softreset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started TX path"]
        #[inline(always)]
        pub const fn events_txready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "RADIO has ramped up and is ready to be started RX path"]
        #[inline(always)]
        pub const fn events_rxready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
        #[doc = "Address sent or received"]
        #[inline(always)]
        pub const fn events_address(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x020cusize) as _) }
        }
        #[doc = "IEEE 802.15.4 length field received"]
        #[inline(always)]
        pub const fn events_framestart(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0210usize) as _) }
        }
        #[doc = "Packet payload sent or received"]
        #[inline(always)]
        pub const fn events_payload(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0214usize) as _) }
        }
        #[doc = "Memory access for packet data has been completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0218usize) as _) }
        }
        #[doc = "The last bit is sent on air or last bit is received"]
        #[inline(always)]
        pub const fn events_phyend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x021cusize) as _) }
        }
        #[doc = "RADIO has been disabled"]
        #[inline(always)]
        pub const fn events_disabled(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0220usize) as _) }
        }
        #[doc = "A device address match occurred on the last received packet"]
        #[inline(always)]
        pub const fn events_devmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0224usize) as _) }
        }
        #[doc = "No device address match occurred on the last received packet"]
        #[inline(always)]
        pub const fn events_devmiss(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0228usize) as _) }
        }
        #[doc = "Packet received with CRC ok"]
        #[inline(always)]
        pub const fn events_crcok(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x022cusize) as _) }
        }
        #[doc = "Packet received with CRC error"]
        #[inline(always)]
        pub const fn events_crcerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0230usize) as _) }
        }
        #[doc = "Bit counter reached bit count value"]
        #[inline(always)]
        pub const fn events_bcmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0238usize) as _) }
        }
        #[doc = "Sampling of energy detection complete (a new ED sample is ready for readout from the RADIO.EDSAMPLE register)"]
        #[inline(always)]
        pub const fn events_edend(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x023cusize) as _) }
        }
        #[doc = "The sampling of energy detection has stopped"]
        #[inline(always)]
        pub const fn events_edstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0240usize) as _) }
        }
        #[doc = "Wireless medium in idle - clear to send"]
        #[inline(always)]
        pub const fn events_ccaidle(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0244usize) as _) }
        }
        #[doc = "Wireless medium busy - do not send"]
        #[inline(always)]
        pub const fn events_ccabusy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0248usize) as _) }
        }
        #[doc = "The CCA has stopped"]
        #[inline(always)]
        pub const fn events_ccastopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x024cusize) as _) }
        }
        #[doc = "Ble_LR CI field received, receive mode is changed from Ble_LR125Kbit to Ble_LR500Kbit"]
        #[inline(always)]
        pub const fn events_rateboost(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0250usize) as _) }
        }
        #[doc = "MAC header match found"]
        #[inline(always)]
        pub const fn events_mhrmatch(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0254usize) as _) }
        }
        #[doc = "Initial sync detected"]
        #[inline(always)]
        pub const fn events_sync(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0258usize) as _) }
        }
        #[doc = "CTEInfo byte is received"]
        #[inline(always)]
        pub const fn events_ctepresent(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x025cusize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn publish_ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Publish configuration for event TXREADY"]
        #[inline(always)]
        pub const fn publish_txready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Publish configuration for event RXREADY"]
        #[inline(always)]
        pub const fn publish_rxready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Publish configuration for event ADDRESS"]
        #[inline(always)]
        pub const fn publish_address(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Publish configuration for event FRAMESTART"]
        #[inline(always)]
        pub const fn publish_framestart(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0310usize) as _) }
        }
        #[doc = "Publish configuration for event PAYLOAD"]
        #[inline(always)]
        pub const fn publish_payload(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0314usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0318usize) as _) }
        }
        #[doc = "Publish configuration for event PHYEND"]
        #[inline(always)]
        pub const fn publish_phyend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x031cusize) as _) }
        }
        #[doc = "Publish configuration for event DISABLED"]
        #[inline(always)]
        pub const fn publish_disabled(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0320usize) as _) }
        }
        #[doc = "Publish configuration for event DEVMATCH"]
        #[inline(always)]
        pub const fn publish_devmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0324usize) as _) }
        }
        #[doc = "Publish configuration for event DEVMISS"]
        #[inline(always)]
        pub const fn publish_devmiss(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0328usize) as _) }
        }
        #[doc = "Publish configuration for event CRCOK"]
        #[inline(always)]
        pub const fn publish_crcok(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x032cusize) as _) }
        }
        #[doc = "Publish configuration for event CRCERROR"]
        #[inline(always)]
        pub const fn publish_crcerror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0330usize) as _) }
        }
        #[doc = "Publish configuration for event BCMATCH"]
        #[inline(always)]
        pub const fn publish_bcmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0338usize) as _) }
        }
        #[doc = "Publish configuration for event EDEND"]
        #[inline(always)]
        pub const fn publish_edend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x033cusize) as _) }
        }
        #[doc = "Publish configuration for event EDSTOPPED"]
        #[inline(always)]
        pub const fn publish_edstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "Publish configuration for event CCAIDLE"]
        #[inline(always)]
        pub const fn publish_ccaidle(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
        #[doc = "Publish configuration for event CCABUSY"]
        #[inline(always)]
        pub const fn publish_ccabusy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0348usize) as _) }
        }
        #[doc = "Publish configuration for event CCASTOPPED"]
        #[inline(always)]
        pub const fn publish_ccastopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x034cusize) as _) }
        }
        #[doc = "Publish configuration for event RATEBOOST"]
        #[inline(always)]
        pub const fn publish_rateboost(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0350usize) as _) }
        }
        #[doc = "Publish configuration for event MHRMATCH"]
        #[inline(always)]
        pub const fn publish_mhrmatch(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0354usize) as _) }
        }
        #[doc = "Publish configuration for event SYNC"]
        #[inline(always)]
        pub const fn publish_sync(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0358usize) as _) }
        }
        #[doc = "Publish configuration for event CTEPRESENT"]
        #[inline(always)]
        pub const fn publish_ctepresent(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x035cusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0488usize + n * 32usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self, n: usize) -> crate::common::Reg<regs::Int, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0490usize + n * 32usize) as _) }
        }
        #[doc = "Data rate and modulation"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::RadioMode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Current radio state"]
        #[inline(always)]
        pub const fn state(self) -> crate::common::Reg<regs::State, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "IEEE 802.15.4 energy detect control"]
        #[inline(always)]
        pub const fn edctrl(self) -> crate::common::Reg<regs::Edctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "IEEE 802.15.4 energy detect level"]
        #[inline(always)]
        pub const fn edsample(self) -> crate::common::Reg<regs::Edsample, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0534usize) as _) }
        }
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        #[inline(always)]
        pub const fn ccactrl(self) -> crate::common::Reg<regs::Ccactrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0538usize) as _) }
        }
        #[doc = "Data whitening configuration"]
        #[inline(always)]
        pub const fn datawhite(self) -> crate::common::Reg<regs::Datawhite, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Timing"]
        #[inline(always)]
        pub const fn timing(self) -> crate::common::Reg<regs::Timing, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0704usize) as _) }
        }
        #[doc = "Frequency"]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0708usize) as _) }
        }
        #[doc = "Output power"]
        #[inline(always)]
        pub const fn txpower(self) -> crate::common::Reg<regs::Txpower, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0710usize) as _) }
        }
        #[doc = "Interframe spacing in us"]
        #[inline(always)]
        pub const fn tifs(self) -> crate::common::Reg<regs::Tifs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0714usize) as _) }
        }
        #[doc = "RSSI sample"]
        #[inline(always)]
        pub const fn rssisample(self) -> crate::common::Reg<regs::Rssisample, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0718usize) as _) }
        }
        #[doc = "Config register"]
        #[inline(always)]
        pub const fn feconfig(self) -> crate::common::Reg<regs::Feconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0908usize) as _) }
        }
        #[doc = "Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)"]
        #[inline(always)]
        pub const fn dfemode(self) -> crate::common::Reg<regs::Dfemode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d00usize) as _) }
        }
        #[doc = "DFE status information"]
        #[inline(always)]
        pub const fn dfestatus(self) -> crate::common::Reg<regs::Dfestatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d04usize) as _) }
        }
        #[doc = "Various configuration for Direction finding"]
        #[inline(always)]
        pub const fn dfectrl1(self) -> crate::common::Reg<regs::Dfectrl1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d10usize) as _) }
        }
        #[doc = "Start offset for Direction finding"]
        #[inline(always)]
        pub const fn dfectrl2(self) -> crate::common::Reg<regs::Dfectrl2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d14usize) as _) }
        }
        #[doc = "GPIO patterns to be used for each antenna"]
        #[inline(always)]
        pub const fn switchpattern(
            self,
        ) -> crate::common::Reg<regs::Switchpattern, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d28usize) as _) }
        }
        #[doc = "Clear the GPIO pattern array for antenna control"]
        #[inline(always)]
        pub const fn clearpattern(
            self,
        ) -> crate::common::Reg<regs::Clearpattern, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0d2cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0d30usize) as _) }
        }
        #[doc = "DFE packet EasyDMA channel"]
        #[inline(always)]
        pub const fn dfepacket(self) -> Dfepacket {
            unsafe { Dfepacket::from_ptr(self.ptr.add(0x0d50usize) as _) }
        }
        #[doc = "CRC status"]
        #[inline(always)]
        pub const fn crcstatus(self) -> crate::common::Reg<regs::Crcstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e0cusize) as _) }
        }
        #[doc = "Received address"]
        #[inline(always)]
        pub const fn rxmatch(self) -> crate::common::Reg<regs::Rxmatch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e10usize) as _) }
        }
        #[doc = "CRC field of previously received packet"]
        #[inline(always)]
        pub const fn rxcrc(self) -> crate::common::Reg<regs::Rxcrc, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e14usize) as _) }
        }
        #[doc = "Device address match index"]
        #[inline(always)]
        pub const fn dai(self) -> crate::common::Reg<regs::Dai, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e18usize) as _) }
        }
        #[doc = "Payload status"]
        #[inline(always)]
        pub const fn pdustat(self) -> crate::common::Reg<regs::Pdustat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e1cusize) as _) }
        }
        #[doc = "Packet configuration register 0"]
        #[inline(always)]
        pub const fn pcnf0(self) -> crate::common::Reg<regs::Pcnf0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e20usize) as _) }
        }
        #[doc = "Packet configuration register 1"]
        #[inline(always)]
        pub const fn pcnf1(self) -> crate::common::Reg<regs::Pcnf1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e28usize) as _) }
        }
        #[doc = "Base address 0"]
        #[inline(always)]
        pub const fn base0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e2cusize) as _) }
        }
        #[doc = "Base address 1"]
        #[inline(always)]
        pub const fn base1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e30usize) as _) }
        }
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        #[inline(always)]
        pub const fn prefix0(self) -> crate::common::Reg<regs::Prefix0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e34usize) as _) }
        }
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        #[inline(always)]
        pub const fn prefix1(self) -> crate::common::Reg<regs::Prefix1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e38usize) as _) }
        }
        #[doc = "Transmit address select"]
        #[inline(always)]
        pub const fn txaddress(self) -> crate::common::Reg<regs::Txaddress, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e3cusize) as _) }
        }
        #[doc = "Receive address select"]
        #[inline(always)]
        pub const fn rxaddresses(self) -> crate::common::Reg<regs::Rxaddresses, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e40usize) as _) }
        }
        #[doc = "CRC configuration"]
        #[inline(always)]
        pub const fn crccnf(self) -> crate::common::Reg<regs::Crccnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e44usize) as _) }
        }
        #[doc = "CRC polynomial"]
        #[inline(always)]
        pub const fn crcpoly(self) -> crate::common::Reg<regs::Crcpoly, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e48usize) as _) }
        }
        #[doc = "CRC initial value"]
        #[inline(always)]
        pub const fn crcinit(self) -> crate::common::Reg<regs::Crcinit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e4cusize) as _) }
        }
        #[doc = "Description collection: Device address base segment n"]
        #[inline(always)]
        pub const fn dab(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e50usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Device address prefix n"]
        #[inline(always)]
        pub const fn dap(self, n: usize) -> crate::common::Reg<regs::Dap, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e70usize + n * 4usize) as _) }
        }
        #[doc = "Device address match configuration"]
        #[inline(always)]
        pub const fn dacnf(self) -> crate::common::Reg<regs::Dacnf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e90usize) as _) }
        }
        #[doc = "Bit counter compare"]
        #[inline(always)]
        pub const fn bcc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0e94usize) as _) }
        }
        #[doc = "CTEInfo parsed from received packet"]
        #[inline(always)]
        pub const fn ctestatus(self) -> crate::common::Reg<regs::Ctestatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ea4usize) as _) }
        }
        #[doc = "Search pattern configuration"]
        #[inline(always)]
        pub const fn mhrmatchconf(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eb4usize) as _) }
        }
        #[doc = "Pattern mask"]
        #[inline(always)]
        pub const fn mhrmatchmask(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eb8usize) as _) }
        }
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        #[inline(always)]
        pub const fn sfd(self) -> crate::common::Reg<regs::Sfd, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ebcusize) as _) }
        }
        #[doc = "Configuration for CTE inline mode"]
        #[inline(always)]
        pub const fn cteinlineconf(
            self,
        ) -> crate::common::Reg<regs::Cteinlineconf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ec0usize) as _) }
        }
        #[doc = "Packet pointer"]
        #[inline(always)]
        pub const fn packetptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ed0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cstones(self) -> Cstones {
            unsafe { Cstones::from_ptr(self.ptr.add(0x1000usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rtt(self) -> Rtt {
            unsafe { Rtt::from_ptr(self.ptr.add(0x1050usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtt {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtt {}
    unsafe impl Sync for Rtt {}
    impl Rtt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RTT Config."]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "RTT segments 0 and 1"]
        #[inline(always)]
        pub const fn segment01(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "RTT segments 2 and 3"]
        #[inline(always)]
        pub const fn segment23(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "RTT segments 4 and 5"]
        #[inline(always)]
        pub const fn segment45(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "RTT segments 6 and 7"]
        #[inline(always)]
        pub const fn segment67(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of bytes transferred in the last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction"]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Amount {
                    amount: u16,
                }
                let proxy = Amount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "IEEE 802.15.4 clear channel assessment control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ccactrl(pub u32);
        impl Ccactrl {
            #[doc = "CCA mode of operation"]
            #[inline(always)]
            pub const fn ccamode(&self) -> super::vals::Ccamode {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Ccamode::from_bits(val as u8)
            }
            #[doc = "CCA mode of operation"]
            #[inline(always)]
            pub fn set_ccamode(&mut self, val: super::vals::Ccamode) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[inline(always)]
            pub const fn ccaedthres(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "CCA energy busy threshold. Used in all the CCA modes except CarrierMode."]
            #[inline(always)]
            pub fn set_ccaedthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode."]
            #[inline(always)]
            pub const fn ccacorrthres(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "CCA correlator busy threshold. Only relevant to CarrierMode, CarrierAndEdMode, and CarrierOrEdMode."]
            #[inline(always)]
            pub fn set_ccacorrthres(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[inline(always)]
            pub const fn ccacorrcnt(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Limit for occurances above CCACORRTHRES. When not equal to zero the corrolator based signal detect is enabled."]
            #[inline(always)]
            pub fn set_ccacorrcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Ccactrl {
            #[inline(always)]
            fn default() -> Ccactrl {
                Ccactrl(0)
            }
        }
        impl core::fmt::Debug for Ccactrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ccactrl")
                    .field("ccamode", &self.ccamode())
                    .field("ccaedthres", &self.ccaedthres())
                    .field("ccacorrthres", &self.ccacorrthres())
                    .field("ccacorrcnt", &self.ccacorrcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ccactrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ccactrl {
                    ccamode: super::vals::Ccamode,
                    ccaedthres: u8,
                    ccacorrthres: u8,
                    ccacorrcnt: u8,
                }
                let proxy = Ccactrl {
                    ccamode: self.ccamode(),
                    ccaedthres: self.ccaedthres(),
                    ccacorrthres: self.ccacorrthres(),
                    ccacorrcnt: self.ccacorrcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Cordic output of CnAcc"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cfophase(pub u32);
        impl Cfophase {
            #[inline(always)]
            pub const fn cfophase(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub fn set_cfophase(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Cfophase {
            #[inline(always)]
            fn default() -> Cfophase {
                Cfophase(0)
            }
        }
        impl core::fmt::Debug for Cfophase {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cfophase")
                    .field("cfophase", &self.cfophase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cfophase {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cfophase {
                    cfophase: u16,
                }
                let proxy = Cfophase {
                    cfophase: self.cfophase(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Clear the GPIO pattern array for antenna control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clearpattern(pub u32);
        impl Clearpattern {
            #[doc = "Clear the GPIO pattern array for antenna control Behaves as a task register, but does not have PPI nor IRQ"]
            #[inline(always)]
            pub const fn clearpattern(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Clear the GPIO pattern array for antenna control Behaves as a task register, but does not have PPI nor IRQ"]
            #[inline(always)]
            pub fn set_clearpattern(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Clearpattern {
            #[inline(always)]
            fn default() -> Clearpattern {
                Clearpattern(0)
            }
        }
        impl core::fmt::Debug for Clearpattern {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clearpattern")
                    .field("clearpattern", &self.clearpattern())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clearpattern {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Clearpattern {
                    clearpattern: bool,
                }
                let proxy = Clearpattern {
                    clearpattern: self.clearpattern(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Output of the autocorrelation of the accumulated IQ signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cnacc(pub u32);
        impl Cnacc {
            #[inline(always)]
            pub const fn cnacci(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub fn set_cnacci(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[inline(always)]
            pub const fn cnaccq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[inline(always)]
            pub fn set_cnaccq(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Cnacc {
            #[inline(always)]
            fn default() -> Cnacc {
                Cnacc(0)
            }
        }
        impl core::fmt::Debug for Cnacc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cnacc")
                    .field("cnacci", &self.cnacci())
                    .field("cnaccq", &self.cnaccq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cnacc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cnacc {
                    cnacci: u16,
                    cnaccq: u16,
                }
                let proxy = Cnacc {
                    cnacci: self.cnacci(),
                    cnaccq: self.cnaccq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RTT Config."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable RTT Functionality. Only valid for BLE 1MBPS and 2MBPS mode"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable RTT Functionality. Only valid for BLE 1MBPS and 2MBPS mode"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enabling/Disable ping over the entire access address."]
            #[inline(always)]
            pub const fn enfullaa(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enabling/Disable ping over the entire access address."]
            #[inline(always)]
            pub fn set_enfullaa(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Role as a Initiator or Reflector."]
            #[inline(always)]
            pub const fn role(&self) -> super::vals::Role {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Role::from_bits(val as u8)
            }
            #[doc = "Role as a Initiator or Reflector."]
            #[inline(always)]
            pub fn set_role(&mut self, val: super::vals::Role) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Number of 16bit payload segments available for ToA detection. Allowed values are 0, 2, 4, 6 and 8."]
            #[inline(always)]
            pub const fn numsegments(&self) -> u8 {
                let val = (self.0 >> 3usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of 16bit payload segments available for ToA detection. Allowed values are 0, 2, 4, 6 and 8."]
            #[inline(always)]
            pub fn set_numsegments(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 3usize)) | (((val as u32) & 0x0f) << 3usize);
            }
            #[doc = "Early Frame Sync Delay, i.e., number of cycles to wait for access address to anchor correctly. For 2MBPSBLE mode, the EFSDELAY value is 64 (2us) and for 1MBPSBLE mode, it can be 256 (8us)."]
            #[inline(always)]
            pub const fn efsdelay(&self) -> u16 {
                let val = (self.0 >> 8usize) & 0x01ff;
                val as u16
            }
            #[doc = "Early Frame Sync Delay, i.e., number of cycles to wait for access address to anchor correctly. For 2MBPSBLE mode, the EFSDELAY value is 64 (2us) and for 1MBPSBLE mode, it can be 256 (8us)."]
            #[inline(always)]
            pub fn set_efsdelay(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 8usize)) | (((val as u32) & 0x01ff) << 8usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("en", &self.en())
                    .field("enfullaa", &self.enfullaa())
                    .field("role", &self.role())
                    .field("numsegments", &self.numsegments())
                    .field("efsdelay", &self.efsdelay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    en: bool,
                    enfullaa: bool,
                    role: super::vals::Role,
                    numsegments: u8,
                    efsdelay: u16,
                }
                let proxy = Config {
                    en: self.en(),
                    enfullaa: self.enfullaa(),
                    role: self.role(),
                    numsegments: self.numsegments(),
                    efsdelay: self.efsdelay(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "CRC configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crccnf(pub u32);
        impl Crccnf {
            #[doc = "CRC length in number of bytes."]
            #[inline(always)]
            pub const fn len(&self) -> super::vals::Len {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Len::from_bits(val as u8)
            }
            #[doc = "CRC length in number of bytes."]
            #[inline(always)]
            pub fn set_len(&mut self, val: super::vals::Len) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Control whether CRC calculation skips the address field. Other fields can also be skipped."]
            #[inline(always)]
            pub const fn skipaddr(&self) -> super::vals::Skipaddr {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Skipaddr::from_bits(val as u8)
            }
            #[doc = "Control whether CRC calculation skips the address field. Other fields can also be skipped."]
            #[inline(always)]
            pub fn set_skipaddr(&mut self, val: super::vals::Skipaddr) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
        }
        impl Default for Crccnf {
            #[inline(always)]
            fn default() -> Crccnf {
                Crccnf(0)
            }
        }
        impl core::fmt::Debug for Crccnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crccnf")
                    .field("len", &self.len())
                    .field("skipaddr", &self.skipaddr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crccnf {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Crccnf {
                    len: super::vals::Len,
                    skipaddr: super::vals::Skipaddr,
                }
                let proxy = Crccnf {
                    len: self.len(),
                    skipaddr: self.skipaddr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "CRC initial value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcinit(pub u32);
        impl Crcinit {
            #[doc = "CRC initial value"]
            #[inline(always)]
            pub const fn crcinit(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC initial value"]
            #[inline(always)]
            pub fn set_crcinit(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Crcinit {
            #[inline(always)]
            fn default() -> Crcinit {
                Crcinit(0)
            }
        }
        impl core::fmt::Debug for Crcinit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcinit")
                    .field("crcinit", &self.crcinit())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcinit {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Crcinit {
                    crcinit: u32,
                }
                let proxy = Crcinit {
                    crcinit: self.crcinit(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "CRC polynomial"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcpoly(pub u32);
        impl Crcpoly {
            #[doc = "CRC polynomial"]
            #[inline(always)]
            pub const fn crcpoly(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC polynomial"]
            #[inline(always)]
            pub fn set_crcpoly(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Crcpoly {
            #[inline(always)]
            fn default() -> Crcpoly {
                Crcpoly(0)
            }
        }
        impl core::fmt::Debug for Crcpoly {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcpoly")
                    .field("crcpoly", &self.crcpoly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcpoly {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Crcpoly {
                    crcpoly: u32,
                }
                let proxy = Crcpoly {
                    crcpoly: self.crcpoly(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "CRC status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Crcstatus(pub u32);
        impl Crcstatus {
            #[doc = "CRC status of packet received"]
            #[inline(always)]
            pub const fn crcstatus(&self) -> super::vals::Crcstatus {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Crcstatus::from_bits(val as u8)
            }
            #[doc = "CRC status of packet received"]
            #[inline(always)]
            pub fn set_crcstatus(&mut self, val: super::vals::Crcstatus) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Crcstatus {
            #[inline(always)]
            fn default() -> Crcstatus {
                Crcstatus(0)
            }
        }
        impl core::fmt::Debug for Crcstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Crcstatus")
                    .field("crcstatus", &self.crcstatus())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Crcstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Crcstatus {
                    crcstatus: super::vals::Crcstatus,
                }
                let proxy = Crcstatus {
                    crcstatus: self.crcstatus(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Selects the mode(s) that are activated on the start signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CstonesMode(pub u32);
        impl CstonesMode {
            #[doc = "Enable or disable TPM"]
            #[inline(always)]
            pub const fn tpm(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable TPM"]
            #[inline(always)]
            pub fn set_tpm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable TFM"]
            #[inline(always)]
            pub const fn tfm(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable TFM"]
            #[inline(always)]
            pub fn set_tfm(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for CstonesMode {
            #[inline(always)]
            fn default() -> CstonesMode {
                CstonesMode(0)
            }
        }
        impl core::fmt::Debug for CstonesMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CstonesMode")
                    .field("tpm", &self.tpm())
                    .field("tfm", &self.tfm())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CstonesMode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct CstonesMode {
                    tpm: bool,
                    tfm: bool,
                }
                let proxy = CstonesMode {
                    tpm: self.tpm(),
                    tfm: self.tfm(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration for CTE inline mode"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cteinlineconf(pub u32);
        impl Cteinlineconf {
            #[doc = "Enable parsing of CTEInfo from received packet in BLE modes"]
            #[inline(always)]
            pub const fn cteinlinectrlen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable parsing of CTEInfo from received packet in BLE modes"]
            #[inline(always)]
            pub fn set_cteinlinectrlen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "CTEInfo is S1 byte or not"]
            #[inline(always)]
            pub const fn cteinfoins1(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "CTEInfo is S1 byte or not"]
            #[inline(always)]
            pub fn set_cteinfoins1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Sampling/switching if CRC is not OK"]
            #[inline(always)]
            pub const fn cteerrorhandling(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Sampling/switching if CRC is not OK"]
            #[inline(always)]
            pub fn set_cteerrorhandling(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Max range of CTETime"]
            #[inline(always)]
            pub const fn ctetimevalidrange(&self) -> super::vals::Ctetimevalidrange {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Ctetimevalidrange::from_bits(val as u8)
            }
            #[doc = "Max range of CTETime"]
            #[inline(always)]
            pub fn set_ctetimevalidrange(&mut self, val: super::vals::Ctetimevalidrange) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub const fn cteinlinerxmode1us(&self) -> super::vals::Cteinlinerxmode1us {
                let val = (self.0 >> 10usize) & 0x07;
                super::vals::Cteinlinerxmode1us::from_bits(val as u8)
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub fn set_cteinlinerxmode1us(&mut self, val: super::vals::Cteinlinerxmode1us) {
                self.0 =
                    (self.0 & !(0x07 << 10usize)) | (((val.to_bits() as u32) & 0x07) << 10usize);
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub const fn cteinlinerxmode2us(&self) -> super::vals::Cteinlinerxmode2us {
                let val = (self.0 >> 13usize) & 0x07;
                super::vals::Cteinlinerxmode2us::from_bits(val as u8)
            }
            #[doc = "Spacing between samples for the samples in the SWITCHING period when CTEINLINEMODE is set"]
            #[inline(always)]
            pub fn set_cteinlinerxmode2us(&mut self, val: super::vals::Cteinlinerxmode2us) {
                self.0 =
                    (self.0 & !(0x07 << 13usize)) | (((val.to_bits() as u32) & 0x07) << 13usize);
            }
            #[doc = "S0 bit pattern to match"]
            #[inline(always)]
            pub const fn s0conf(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "S0 bit pattern to match"]
            #[inline(always)]
            pub fn set_s0conf(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "S0 bit mask to set which bit to match"]
            #[inline(always)]
            pub const fn s0mask(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "S0 bit mask to set which bit to match"]
            #[inline(always)]
            pub fn set_s0mask(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Cteinlineconf {
            #[inline(always)]
            fn default() -> Cteinlineconf {
                Cteinlineconf(0)
            }
        }
        impl core::fmt::Debug for Cteinlineconf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cteinlineconf")
                    .field("cteinlinectrlen", &self.cteinlinectrlen())
                    .field("cteinfoins1", &self.cteinfoins1())
                    .field("cteerrorhandling", &self.cteerrorhandling())
                    .field("ctetimevalidrange", &self.ctetimevalidrange())
                    .field("cteinlinerxmode1us", &self.cteinlinerxmode1us())
                    .field("cteinlinerxmode2us", &self.cteinlinerxmode2us())
                    .field("s0conf", &self.s0conf())
                    .field("s0mask", &self.s0mask())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cteinlineconf {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cteinlineconf {
                    cteinlinectrlen: bool,
                    cteinfoins1: bool,
                    cteerrorhandling: bool,
                    ctetimevalidrange: super::vals::Ctetimevalidrange,
                    cteinlinerxmode1us: super::vals::Cteinlinerxmode1us,
                    cteinlinerxmode2us: super::vals::Cteinlinerxmode2us,
                    s0conf: u8,
                    s0mask: u8,
                }
                let proxy = Cteinlineconf {
                    cteinlinectrlen: self.cteinlinectrlen(),
                    cteinfoins1: self.cteinfoins1(),
                    cteerrorhandling: self.cteerrorhandling(),
                    ctetimevalidrange: self.ctetimevalidrange(),
                    cteinlinerxmode1us: self.cteinlinerxmode1us(),
                    cteinlinerxmode2us: self.cteinlinerxmode2us(),
                    s0conf: self.s0conf(),
                    s0mask: self.s0mask(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "CTEInfo parsed from received packet"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ctestatus(pub u32);
        impl Ctestatus {
            #[doc = "CTETime parsed from packet"]
            #[inline(always)]
            pub const fn ctetime(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "CTETime parsed from packet"]
            #[inline(always)]
            pub fn set_ctetime(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "RFU parsed from packet"]
            #[inline(always)]
            pub const fn rfu(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "RFU parsed from packet"]
            #[inline(always)]
            pub fn set_rfu(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "CTEType parsed from packet"]
            #[inline(always)]
            pub const fn ctetype(&self) -> u8 {
                let val = (self.0 >> 6usize) & 0x03;
                val as u8
            }
            #[doc = "CTEType parsed from packet"]
            #[inline(always)]
            pub fn set_ctetype(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Ctestatus {
            #[inline(always)]
            fn default() -> Ctestatus {
                Ctestatus(0)
            }
        }
        impl core::fmt::Debug for Ctestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ctestatus")
                    .field("ctetime", &self.ctetime())
                    .field("rfu", &self.rfu())
                    .field("ctetype", &self.ctetype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ctestatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ctestatus {
                    ctetime: u8,
                    rfu: bool,
                    ctetype: u8,
                }
                let proxy = Ctestatus {
                    ctetime: self.ctetime(),
                    rfu: self.rfu(),
                    ctetype: self.ctetype(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the current transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the current transaction. Continuously updated."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Currentamount {
                    amount: u16,
                }
                let proxy = Currentamount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Device address match configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dacnf(pub u32);
        impl Dacnf {
            #[doc = "Enable or disable device address matching using device address 0"]
            #[inline(always)]
            pub const fn ena0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 0"]
            #[inline(always)]
            pub fn set_ena0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable device address matching using device address 1"]
            #[inline(always)]
            pub const fn ena1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 1"]
            #[inline(always)]
            pub fn set_ena1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable device address matching using device address 2"]
            #[inline(always)]
            pub const fn ena2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 2"]
            #[inline(always)]
            pub fn set_ena2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable device address matching using device address 3"]
            #[inline(always)]
            pub const fn ena3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 3"]
            #[inline(always)]
            pub fn set_ena3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable device address matching using device address 4"]
            #[inline(always)]
            pub const fn ena4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 4"]
            #[inline(always)]
            pub fn set_ena4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable device address matching using device address 5"]
            #[inline(always)]
            pub const fn ena5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 5"]
            #[inline(always)]
            pub fn set_ena5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable device address matching using device address 6"]
            #[inline(always)]
            pub const fn ena6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 6"]
            #[inline(always)]
            pub fn set_ena6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable device address matching using device address 7"]
            #[inline(always)]
            pub const fn ena7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable device address matching using device address 7"]
            #[inline(always)]
            pub fn set_ena7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "TxAdd for device address 0"]
            #[inline(always)]
            pub const fn txadd0(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 0"]
            #[inline(always)]
            pub fn set_txadd0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "TxAdd for device address 1"]
            #[inline(always)]
            pub const fn txadd1(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 1"]
            #[inline(always)]
            pub fn set_txadd1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "TxAdd for device address 2"]
            #[inline(always)]
            pub const fn txadd2(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 2"]
            #[inline(always)]
            pub fn set_txadd2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "TxAdd for device address 3"]
            #[inline(always)]
            pub const fn txadd3(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 3"]
            #[inline(always)]
            pub fn set_txadd3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "TxAdd for device address 4"]
            #[inline(always)]
            pub const fn txadd4(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 4"]
            #[inline(always)]
            pub fn set_txadd4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "TxAdd for device address 5"]
            #[inline(always)]
            pub const fn txadd5(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 5"]
            #[inline(always)]
            pub fn set_txadd5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "TxAdd for device address 6"]
            #[inline(always)]
            pub const fn txadd6(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 6"]
            #[inline(always)]
            pub fn set_txadd6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "TxAdd for device address 7"]
            #[inline(always)]
            pub const fn txadd7(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "TxAdd for device address 7"]
            #[inline(always)]
            pub fn set_txadd7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
        }
        impl Default for Dacnf {
            #[inline(always)]
            fn default() -> Dacnf {
                Dacnf(0)
            }
        }
        impl core::fmt::Debug for Dacnf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dacnf")
                    .field("ena0", &self.ena0())
                    .field("ena1", &self.ena1())
                    .field("ena2", &self.ena2())
                    .field("ena3", &self.ena3())
                    .field("ena4", &self.ena4())
                    .field("ena5", &self.ena5())
                    .field("ena6", &self.ena6())
                    .field("ena7", &self.ena7())
                    .field("txadd0", &self.txadd0())
                    .field("txadd1", &self.txadd1())
                    .field("txadd2", &self.txadd2())
                    .field("txadd3", &self.txadd3())
                    .field("txadd4", &self.txadd4())
                    .field("txadd5", &self.txadd5())
                    .field("txadd6", &self.txadd6())
                    .field("txadd7", &self.txadd7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dacnf {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dacnf {
                    ena0: bool,
                    ena1: bool,
                    ena2: bool,
                    ena3: bool,
                    ena4: bool,
                    ena5: bool,
                    ena6: bool,
                    ena7: bool,
                    txadd0: bool,
                    txadd1: bool,
                    txadd2: bool,
                    txadd3: bool,
                    txadd4: bool,
                    txadd5: bool,
                    txadd6: bool,
                    txadd7: bool,
                }
                let proxy = Dacnf {
                    ena0: self.ena0(),
                    ena1: self.ena1(),
                    ena2: self.ena2(),
                    ena3: self.ena3(),
                    ena4: self.ena4(),
                    ena5: self.ena5(),
                    ena6: self.ena6(),
                    ena7: self.ena7(),
                    txadd0: self.txadd0(),
                    txadd1: self.txadd1(),
                    txadd2: self.txadd2(),
                    txadd3: self.txadd3(),
                    txadd4: self.txadd4(),
                    txadd5: self.txadd5(),
                    txadd6: self.txadd6(),
                    txadd7: self.txadd7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Device address match index"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dai(pub u32);
        impl Dai {
            #[doc = "Device address match index"]
            #[inline(always)]
            pub const fn dai(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Device address match index"]
            #[inline(always)]
            pub fn set_dai(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Dai {
            #[inline(always)]
            fn default() -> Dai {
                Dai(0)
            }
        }
        impl core::fmt::Debug for Dai {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dai").field("dai", &self.dai()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dai {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dai {
                    dai: u8,
                }
                let proxy = Dai { dai: self.dai() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Device address prefix n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dap(pub u32);
        impl Dap {
            #[doc = "Device address prefix n"]
            #[inline(always)]
            pub const fn dap(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Device address prefix n"]
            #[inline(always)]
            pub fn set_dap(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Dap {
            #[inline(always)]
            fn default() -> Dap {
                Dap(0)
            }
        }
        impl core::fmt::Debug for Dap {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dap").field("dap", &self.dap()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dap {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dap {
                    dap: u16,
                }
                let proxy = Dap { dap: self.dap() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Data whitening configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Datawhite(pub u32);
        impl Datawhite {
            #[doc = "Whitening initial value"]
            #[inline(always)]
            pub const fn iv(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x01ff;
                val as u16
            }
            #[doc = "Whitening initial value"]
            #[inline(always)]
            pub fn set_iv(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 0usize)) | (((val as u32) & 0x01ff) << 0usize);
            }
            #[doc = "Whitening polynomial"]
            #[inline(always)]
            pub const fn poly(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "Whitening polynomial"]
            #[inline(always)]
            pub fn set_poly(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
        }
        impl Default for Datawhite {
            #[inline(always)]
            fn default() -> Datawhite {
                Datawhite(0)
            }
        }
        impl core::fmt::Debug for Datawhite {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Datawhite")
                    .field("iv", &self.iv())
                    .field("poly", &self.poly())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Datawhite {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Datawhite {
                    iv: u16,
                    poly: u16,
                }
                let proxy = Datawhite {
                    iv: self.iv(),
                    poly: self.poly(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Various configuration for Direction finding"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfectrl1(pub u32);
        impl Dfectrl1 {
            #[doc = "Length of the AoA/AoD procedure in number of 8 us units"]
            #[inline(always)]
            pub const fn numberof8us(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x3f;
                val as u8
            }
            #[doc = "Length of the AoA/AoD procedure in number of 8 us units"]
            #[inline(always)]
            pub fn set_numberof8us(&mut self, val: u8) {
                self.0 = (self.0 & !(0x3f << 0usize)) | (((val as u32) & 0x3f) << 0usize);
            }
            #[doc = "Add CTE extension and do antenna switching/sampling in this extension"]
            #[inline(always)]
            pub const fn dfeinextension(&self) -> super::vals::Dfeinextension {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Dfeinextension::from_bits(val as u8)
            }
            #[doc = "Add CTE extension and do antenna switching/sampling in this extension"]
            #[inline(always)]
            pub fn set_dfeinextension(&mut self, val: super::vals::Dfeinextension) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
            #[doc = "Interval between every time the antenna is changed in the SWITCHING state"]
            #[inline(always)]
            pub const fn tswitchspacing(&self) -> super::vals::Tswitchspacing {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Tswitchspacing::from_bits(val as u8)
            }
            #[doc = "Interval between every time the antenna is changed in the SWITCHING state"]
            #[inline(always)]
            pub fn set_tswitchspacing(&mut self, val: super::vals::Tswitchspacing) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Interval between samples in the REFERENCE period"]
            #[inline(always)]
            pub const fn tsamplespacingref(&self) -> super::vals::Tsamplespacingref {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Tsamplespacingref::from_bits(val as u8)
            }
            #[doc = "Interval between samples in the REFERENCE period"]
            #[inline(always)]
            pub fn set_tsamplespacingref(&mut self, val: super::vals::Tsamplespacingref) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[doc = "Whether to sample I/Q or magnitude/phase"]
            #[inline(always)]
            pub const fn sampletype(&self) -> super::vals::Sampletype {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::Sampletype::from_bits(val as u8)
            }
            #[doc = "Whether to sample I/Q or magnitude/phase"]
            #[inline(always)]
            pub fn set_sampletype(&mut self, val: super::vals::Sampletype) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0"]
            #[inline(always)]
            pub const fn tsamplespacing(&self) -> super::vals::Tsamplespacing {
                let val = (self.0 >> 16usize) & 0x07;
                super::vals::Tsamplespacing::from_bits(val as u8)
            }
            #[doc = "Interval between samples in the SWITCHING period when CTEINLINECTRLEN is 0"]
            #[inline(always)]
            pub fn set_tsamplespacing(&mut self, val: super::vals::Tsamplespacing) {
                self.0 =
                    (self.0 & !(0x07 << 16usize)) | (((val.to_bits() as u32) & 0x07) << 16usize);
            }
            #[doc = "Repeat every antenna pattern N times."]
            #[inline(always)]
            pub const fn repeatpattern(&self) -> super::vals::Repeatpattern {
                let val = (self.0 >> 20usize) & 0x0f;
                super::vals::Repeatpattern::from_bits(val as u8)
            }
            #[doc = "Repeat every antenna pattern N times."]
            #[inline(always)]
            pub fn set_repeatpattern(&mut self, val: super::vals::Repeatpattern) {
                self.0 =
                    (self.0 & !(0x0f << 20usize)) | (((val.to_bits() as u32) & 0x0f) << 20usize);
            }
            #[doc = "Gain will be lowered by the specified number of gain steps at the start of CTE"]
            #[inline(always)]
            pub const fn agcbackoffgain(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x0f;
                val as u8
            }
            #[doc = "Gain will be lowered by the specified number of gain steps at the start of CTE"]
            #[inline(always)]
            pub fn set_agcbackoffgain(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 24usize)) | (((val as u32) & 0x0f) << 24usize);
            }
        }
        impl Default for Dfectrl1 {
            #[inline(always)]
            fn default() -> Dfectrl1 {
                Dfectrl1(0)
            }
        }
        impl core::fmt::Debug for Dfectrl1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfectrl1")
                    .field("numberof8us", &self.numberof8us())
                    .field("dfeinextension", &self.dfeinextension())
                    .field("tswitchspacing", &self.tswitchspacing())
                    .field("tsamplespacingref", &self.tsamplespacingref())
                    .field("sampletype", &self.sampletype())
                    .field("tsamplespacing", &self.tsamplespacing())
                    .field("repeatpattern", &self.repeatpattern())
                    .field("agcbackoffgain", &self.agcbackoffgain())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfectrl1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dfectrl1 {
                    numberof8us: u8,
                    dfeinextension: super::vals::Dfeinextension,
                    tswitchspacing: super::vals::Tswitchspacing,
                    tsamplespacingref: super::vals::Tsamplespacingref,
                    sampletype: super::vals::Sampletype,
                    tsamplespacing: super::vals::Tsamplespacing,
                    repeatpattern: super::vals::Repeatpattern,
                    agcbackoffgain: u8,
                }
                let proxy = Dfectrl1 {
                    numberof8us: self.numberof8us(),
                    dfeinextension: self.dfeinextension(),
                    tswitchspacing: self.tswitchspacing(),
                    tsamplespacingref: self.tsamplespacingref(),
                    sampletype: self.sampletype(),
                    tsamplespacing: self.tsamplespacing(),
                    repeatpattern: self.repeatpattern(),
                    agcbackoffgain: self.agcbackoffgain(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Start offset for Direction finding"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfectrl2(pub u32);
        impl Dfectrl2 {
            #[doc = "Signed value offset after the end of the CRC before starting switching in number of 16M cycles"]
            #[inline(always)]
            pub const fn tswitchoffset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Signed value offset after the end of the CRC before starting switching in number of 16M cycles"]
            #[inline(always)]
            pub fn set_tswitchoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
            #[doc = "Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start"]
            #[inline(always)]
            pub const fn tsampleoffset(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x0fff;
                val as u16
            }
            #[doc = "Signed value offset before starting sampling in number of 16M cycles relative to the beginning of the REFERENCE state - 12 us after switching start"]
            #[inline(always)]
            pub fn set_tsampleoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 16usize)) | (((val as u32) & 0x0fff) << 16usize);
            }
        }
        impl Default for Dfectrl2 {
            #[inline(always)]
            fn default() -> Dfectrl2 {
                Dfectrl2(0)
            }
        }
        impl core::fmt::Debug for Dfectrl2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfectrl2")
                    .field("tswitchoffset", &self.tswitchoffset())
                    .field("tsampleoffset", &self.tsampleoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfectrl2 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dfectrl2 {
                    tswitchoffset: u16,
                    tsampleoffset: u16,
                }
                let proxy = Dfectrl2 {
                    tswitchoffset: self.tswitchoffset(),
                    tsampleoffset: self.tsampleoffset(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Whether to use Angle-of-Arrival (AOA) or Angle-of-Departure (AOD)"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfemode(pub u32);
        impl Dfemode {
            #[doc = "Direction finding operation mode"]
            #[inline(always)]
            pub const fn dfeopmode(&self) -> super::vals::Dfeopmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Dfeopmode::from_bits(val as u8)
            }
            #[doc = "Direction finding operation mode"]
            #[inline(always)]
            pub fn set_dfeopmode(&mut self, val: super::vals::Dfeopmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Dfemode {
            #[inline(always)]
            fn default() -> Dfemode {
                Dfemode(0)
            }
        }
        impl core::fmt::Debug for Dfemode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfemode")
                    .field("dfeopmode", &self.dfeopmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfemode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dfemode {
                    dfeopmode: super::vals::Dfeopmode,
                }
                let proxy = Dfemode {
                    dfeopmode: self.dfeopmode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "DFE status information"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dfestatus(pub u32);
        impl Dfestatus {
            #[doc = "Internal state of switching state machine"]
            #[inline(always)]
            pub const fn switchingstate(&self) -> super::vals::Switchingstate {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Switchingstate::from_bits(val as u8)
            }
            #[doc = "Internal state of switching state machine"]
            #[inline(always)]
            pub fn set_switchingstate(&mut self, val: super::vals::Switchingstate) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
            #[doc = "Internal state of sampling state machine"]
            #[inline(always)]
            pub const fn samplingstate(&self) -> super::vals::Samplingstate {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Samplingstate::from_bits(val as u8)
            }
            #[doc = "Internal state of sampling state machine"]
            #[inline(always)]
            pub fn set_samplingstate(&mut self, val: super::vals::Samplingstate) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Dfestatus {
            #[inline(always)]
            fn default() -> Dfestatus {
                Dfestatus(0)
            }
        }
        impl core::fmt::Debug for Dfestatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dfestatus")
                    .field("switchingstate", &self.switchingstate())
                    .field("samplingstate", &self.samplingstate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dfestatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dfestatus {
                    switchingstate: super::vals::Switchingstate,
                    samplingstate: super::vals::Samplingstate,
                }
                let proxy = Dfestatus {
                    switchingstate: self.switchingstate(),
                    samplingstate: self.samplingstate(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Turn on/off down sample of input IQ-signals"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Downsample(pub u32);
        impl Downsample {
            #[doc = "Turn on/off down sample of input IQ-signals"]
            #[inline(always)]
            pub const fn enablefilter(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Turn on/off down sample of input IQ-signals"]
            #[inline(always)]
            pub fn set_enablefilter(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicating if BLE1M or BLE2M is used"]
            #[inline(always)]
            pub const fn rate(&self) -> super::vals::Rate {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Rate::from_bits(val as u8)
            }
            #[doc = "Indicating if BLE1M or BLE2M is used"]
            #[inline(always)]
            pub fn set_rate(&mut self, val: super::vals::Rate) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Downsample {
            #[inline(always)]
            fn default() -> Downsample {
                Downsample(0)
            }
        }
        impl core::fmt::Debug for Downsample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Downsample")
                    .field("enablefilter", &self.enablefilter())
                    .field("rate", &self.rate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Downsample {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Downsample {
                    enablefilter: bool,
                    rate: super::vals::Rate,
                }
                let proxy = Downsample {
                    enablefilter: self.enablefilter(),
                    rate: self.rate(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "IEEE 802.15.4 energy detect control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Edctrl(pub u32);
        impl Edctrl {
            #[doc = "IEEE 802.15.4 energy detect loop count"]
            #[inline(always)]
            pub const fn edcnt(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x001f_ffff;
                val as u32
            }
            #[doc = "IEEE 802.15.4 energy detect loop count"]
            #[inline(always)]
            pub fn set_edcnt(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x001f_ffff << 0usize)) | (((val as u32) & 0x001f_ffff) << 0usize);
            }
        }
        impl Default for Edctrl {
            #[inline(always)]
            fn default() -> Edctrl {
                Edctrl(0)
            }
        }
        impl core::fmt::Debug for Edctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Edctrl")
                    .field("edcnt", &self.edcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Edctrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Edctrl {
                    edcnt: u32,
                }
                let proxy = Edctrl {
                    edcnt: self.edcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "IEEE 802.15.4 energy detect level"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Edsample(pub u32);
        impl Edsample {
            #[doc = "IEEE 802.15.4 energy detect level"]
            #[inline(always)]
            pub const fn edlvl(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "IEEE 802.15.4 energy detect level"]
            #[inline(always)]
            pub fn set_edlvl(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Edsample {
            #[inline(always)]
            fn default() -> Edsample {
                Edsample(0)
            }
        }
        impl core::fmt::Debug for Edsample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Edsample")
                    .field("edlvl", &self.edlvl())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Edsample {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Edsample {
                    edlvl: u8,
                }
                let proxy = Edsample {
                    edlvl: self.edlvl(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "FAEPEER (Frequency Actuation Error) of peer if known. Used during Mode 0 steps."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Faepeer(pub u32);
        impl Faepeer {
            #[doc = "Units 31.25 ppb."]
            #[inline(always)]
            pub const fn faepeer(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Units 31.25 ppb."]
            #[inline(always)]
            pub fn set_faepeer(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Faepeer {
            #[inline(always)]
            fn default() -> Faepeer {
                Faepeer(0)
            }
        }
        impl core::fmt::Debug for Faepeer {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Faepeer")
                    .field("faepeer", &self.faepeer())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Faepeer {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Faepeer {
                    faepeer: u8,
                }
                let proxy = Faepeer {
                    faepeer: self.faepeer(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Config register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Feconfig(pub u32);
        impl Feconfig {
            #[doc = "Mode for narrow scaling output."]
            #[inline(always)]
            pub const fn scalermode(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Mode for narrow scaling output."]
            #[inline(always)]
            pub fn set_scalermode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Feconfig {
            #[inline(always)]
            fn default() -> Feconfig {
                Feconfig(0)
            }
        }
        impl core::fmt::Debug for Feconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Feconfig")
                    .field("scalermode", &self.scalermode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Feconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Feconfig {
                    scalermode: bool,
                }
                let proxy = Feconfig {
                    scalermode: self.scalermode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "FFO estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffoest(pub u32);
        impl Ffoest {
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub const fn ffoest(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub fn set_ffoest(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Ffoest {
            #[inline(always)]
            fn default() -> Ffoest {
                Ffoest(0)
            }
        }
        impl core::fmt::Debug for Ffoest {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffoest")
                    .field("ffoest", &self.ffoest())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffoest {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ffoest {
                    ffoest: u16,
                }
                let proxy = Ffoest {
                    ffoest: self.ffoest(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Override value of FFO (Fractional Frequency Offset) if not to be based on the frequency estimate derived from CnAcc (autocorrelation of the scaled input signal) value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffoin(pub u32);
        impl Ffoin {
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub const fn fffin(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Units 62.5 ppb. Max range +/-100 ppm plus margin."]
            #[inline(always)]
            pub fn set_fffin(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Ffoin {
            #[inline(always)]
            fn default() -> Ffoin {
                Ffoin(0)
            }
        }
        impl core::fmt::Debug for Ffoin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffoin")
                    .field("fffin", &self.fffin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffoin {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ffoin {
                    fffin: u16,
                }
                let proxy = Ffoin {
                    fffin: self.fffin(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Source of FFO"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffosource(pub u32);
        impl Ffosource {
            #[doc = "Use external or internal FFOSOURCE"]
            #[inline(always)]
            pub const fn ffosource(&self) -> super::vals::Ffosource {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ffosource::from_bits(val as u8)
            }
            #[doc = "Use external or internal FFOSOURCE"]
            #[inline(always)]
            pub fn set_ffosource(&mut self, val: super::vals::Ffosource) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ffosource {
            #[inline(always)]
            fn default() -> Ffosource {
                Ffosource(0)
            }
        }
        impl core::fmt::Debug for Ffosource {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffosource")
                    .field("ffosource", &self.ffosource())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffosource {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ffosource {
                    ffosource: super::vals::Ffosource,
                }
                let proxy = Ffosource {
                    ffosource: self.ffosource(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of full ADPLL finetune steps"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Finetunenext(pub u32);
        impl Finetunenext {
            #[doc = "Units of 488.28125 Hz"]
            #[inline(always)]
            pub const fn finetunenext(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x1fff;
                val as u16
            }
            #[doc = "Units of 488.28125 Hz"]
            #[inline(always)]
            pub fn set_finetunenext(&mut self, val: u16) {
                self.0 = (self.0 & !(0x1fff << 0usize)) | (((val as u32) & 0x1fff) << 0usize);
            }
        }
        impl Default for Finetunenext {
            #[inline(always)]
            fn default() -> Finetunenext {
                Finetunenext(0)
            }
        }
        impl core::fmt::Debug for Finetunenext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Finetunenext")
                    .field("finetunenext", &self.finetunenext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Finetunenext {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Finetunenext {
                    finetunenext: u16,
                }
                let proxy = Finetunenext {
                    finetunenext: self.finetunenext(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Frequency offset estimate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Freqoffset(pub u32);
        impl Freqoffset {
            #[inline(always)]
            pub const fn freqoffset(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x3fff;
                val as u16
            }
            #[inline(always)]
            pub fn set_freqoffset(&mut self, val: u16) {
                self.0 = (self.0 & !(0x3fff << 0usize)) | (((val as u32) & 0x3fff) << 0usize);
            }
        }
        impl Default for Freqoffset {
            #[inline(always)]
            fn default() -> Freqoffset {
                Freqoffset(0)
            }
        }
        impl core::fmt::Debug for Freqoffset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Freqoffset")
                    .field("freqoffset", &self.freqoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Freqoffset {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Freqoffset {
                    freqoffset: u16,
                }
                let proxy = Freqoffset {
                    freqoffset: self.freqoffset(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "Radio channel frequency. Frequency = 2400 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub const fn frequency(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Radio channel frequency. Frequency = 2400 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub fn set_frequency(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
            #[doc = "Channel map selection. 0: Channel map between 2400 MHZ to 2500 MHz, Frequency = 2400 + FREQUENCY (MHz). 1: Channel map between 2360 MHZ to 2460 MHz, Frequency = 2360 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub const fn map(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Channel map selection. 0: Channel map between 2400 MHZ to 2500 MHz, Frequency = 2400 + FREQUENCY (MHz). 1: Channel map between 2360 MHZ to 2460 MHz, Frequency = 2360 + FREQUENCY (MHz)."]
            #[inline(always)]
            pub fn set_map(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .field("map", &self.map())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Frequency {
                    frequency: u8,
                    map: bool,
                }
                let proxy = Frequency {
                    frequency: self.frequency(),
                    map: self.map(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event READY"]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event READY"]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event TXREADY"]
            #[inline(always)]
            pub const fn txready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TXREADY"]
            #[inline(always)]
            pub fn set_txready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event RXREADY"]
            #[inline(always)]
            pub const fn rxready(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RXREADY"]
            #[inline(always)]
            pub fn set_rxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event ADDRESS"]
            #[inline(always)]
            pub const fn address(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ADDRESS"]
            #[inline(always)]
            pub fn set_address(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write '1' to disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub const fn framestart(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event FRAMESTART"]
            #[inline(always)]
            pub fn set_framestart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Write '1' to disable interrupt for event PAYLOAD"]
            #[inline(always)]
            pub const fn payload(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PAYLOAD"]
            #[inline(always)]
            pub fn set_payload(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event PHYEND"]
            #[inline(always)]
            pub const fn phyend(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event PHYEND"]
            #[inline(always)]
            pub fn set_phyend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Write '1' to disable interrupt for event DISABLED"]
            #[inline(always)]
            pub const fn disabled(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DISABLED"]
            #[inline(always)]
            pub fn set_disabled(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Write '1' to disable interrupt for event DEVMATCH"]
            #[inline(always)]
            pub const fn devmatch(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DEVMATCH"]
            #[inline(always)]
            pub fn set_devmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Write '1' to disable interrupt for event DEVMISS"]
            #[inline(always)]
            pub const fn devmiss(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DEVMISS"]
            #[inline(always)]
            pub fn set_devmiss(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Write '1' to disable interrupt for event CRCOK"]
            #[inline(always)]
            pub const fn crcok(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CRCOK"]
            #[inline(always)]
            pub fn set_crcok(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Write '1' to disable interrupt for event CRCERROR"]
            #[inline(always)]
            pub const fn crcerror(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CRCERROR"]
            #[inline(always)]
            pub fn set_crcerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Write '1' to disable interrupt for event BCMATCH"]
            #[inline(always)]
            pub const fn bcmatch(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event BCMATCH"]
            #[inline(always)]
            pub fn set_bcmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Write '1' to disable interrupt for event EDEND"]
            #[inline(always)]
            pub const fn edend(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event EDEND"]
            #[inline(always)]
            pub fn set_edend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Write '1' to disable interrupt for event EDSTOPPED"]
            #[inline(always)]
            pub const fn edstopped(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event EDSTOPPED"]
            #[inline(always)]
            pub fn set_edstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCAIDLE"]
            #[inline(always)]
            pub const fn ccaidle(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCAIDLE"]
            #[inline(always)]
            pub fn set_ccaidle(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCABUSY"]
            #[inline(always)]
            pub const fn ccabusy(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCABUSY"]
            #[inline(always)]
            pub fn set_ccabusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Write '1' to disable interrupt for event CCASTOPPED"]
            #[inline(always)]
            pub const fn ccastopped(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CCASTOPPED"]
            #[inline(always)]
            pub fn set_ccastopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event RATEBOOST"]
            #[inline(always)]
            pub const fn rateboost(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event RATEBOOST"]
            #[inline(always)]
            pub fn set_rateboost(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event MHRMATCH"]
            #[inline(always)]
            pub const fn mhrmatch(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event MHRMATCH"]
            #[inline(always)]
            pub fn set_mhrmatch(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event SYNC"]
            #[inline(always)]
            pub const fn sync(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event SYNC"]
            #[inline(always)]
            pub fn set_sync(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Write '1' to disable interrupt for event CTEPRESENT"]
            #[inline(always)]
            pub const fn ctepresent(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event CTEPRESENT"]
            #[inline(always)]
            pub fn set_ctepresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("ready", &self.ready())
                    .field("txready", &self.txready())
                    .field("rxready", &self.rxready())
                    .field("address", &self.address())
                    .field("framestart", &self.framestart())
                    .field("payload", &self.payload())
                    .field("end", &self.end())
                    .field("phyend", &self.phyend())
                    .field("disabled", &self.disabled())
                    .field("devmatch", &self.devmatch())
                    .field("devmiss", &self.devmiss())
                    .field("crcok", &self.crcok())
                    .field("crcerror", &self.crcerror())
                    .field("bcmatch", &self.bcmatch())
                    .field("edend", &self.edend())
                    .field("edstopped", &self.edstopped())
                    .field("ccaidle", &self.ccaidle())
                    .field("ccabusy", &self.ccabusy())
                    .field("ccastopped", &self.ccastopped())
                    .field("rateboost", &self.rateboost())
                    .field("mhrmatch", &self.mhrmatch())
                    .field("sync", &self.sync())
                    .field("ctepresent", &self.ctepresent())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    ready: bool,
                    txready: bool,
                    rxready: bool,
                    address: bool,
                    framestart: bool,
                    payload: bool,
                    end: bool,
                    phyend: bool,
                    disabled: bool,
                    devmatch: bool,
                    devmiss: bool,
                    crcok: bool,
                    crcerror: bool,
                    bcmatch: bool,
                    edend: bool,
                    edstopped: bool,
                    ccaidle: bool,
                    ccabusy: bool,
                    ccastopped: bool,
                    rateboost: bool,
                    mhrmatch: bool,
                    sync: bool,
                    ctepresent: bool,
                }
                let proxy = Int {
                    ready: self.ready(),
                    txready: self.txready(),
                    rxready: self.rxready(),
                    address: self.address(),
                    framestart: self.framestart(),
                    payload: self.payload(),
                    end: self.end(),
                    phyend: self.phyend(),
                    disabled: self.disabled(),
                    devmatch: self.devmatch(),
                    devmiss: self.devmiss(),
                    crcok: self.crcok(),
                    crcerror: self.crcerror(),
                    bcmatch: self.bcmatch(),
                    edend: self.edend(),
                    edstopped: self.edstopped(),
                    ccaidle: self.ccaidle(),
                    ccabusy: self.ccabusy(),
                    ccastopped: self.ccastopped(),
                    rateboost: self.rateboost(),
                    mhrmatch: self.mhrmatch(),
                    sync: self.sync(),
                    ctepresent: self.ctepresent(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Mean of IQ values"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Iqrawmean(pub u32);
        impl Iqrawmean {
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn iqrawmeani(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub fn set_iqrawmeani(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn iqrawmeanq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub fn set_iqrawmeanq(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Iqrawmean {
            #[inline(always)]
            fn default() -> Iqrawmean {
                Iqrawmean(0)
            }
        }
        impl core::fmt::Debug for Iqrawmean {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Iqrawmean")
                    .field("iqrawmeani", &self.iqrawmeani())
                    .field("iqrawmeanq", &self.iqrawmeanq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Iqrawmean {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Iqrawmean {
                    iqrawmeani: u16,
                    iqrawmeanq: u16,
                }
                let proxy = Iqrawmean {
                    iqrawmeani: self.iqrawmeani(),
                    iqrawmeanq: self.iqrawmeanq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Quantization error between ADPLL frequency and the desired value of FFO * RF Frequency. Values limited to \\[-64,63\\] with units 7.6294 Hz."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lfaenext(pub u32);
        impl Lfaenext {
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn lfaenext(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub fn set_lfaenext(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Lfaenext {
            #[inline(always)]
            fn default() -> Lfaenext {
                Lfaenext(0)
            }
        }
        impl core::fmt::Debug for Lfaenext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lfaenext")
                    .field("lfaenext", &self.lfaenext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lfaenext {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lfaenext {
                    lfaenext: u8,
                }
                let proxy = Lfaenext {
                    lfaenext: self.lfaenext(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Mean magnitude and phase of the signal before it is converted to PCT16"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Magphasemean(pub u32);
        impl Magphasemean {
            #[doc = "Mean phase"]
            #[inline(always)]
            pub const fn phase(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Mean phase"]
            #[inline(always)]
            pub fn set_phase(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Mean magnitude"]
            #[inline(always)]
            pub const fn mag(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Mean magnitude"]
            #[inline(always)]
            pub fn set_mag(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Magphasemean {
            #[inline(always)]
            fn default() -> Magphasemean {
                Magphasemean(0)
            }
        }
        impl core::fmt::Debug for Magphasemean {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Magphasemean")
                    .field("phase", &self.phase())
                    .field("mag", &self.mag())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Magphasemean {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Magphasemean {
                    phase: u16,
                    mag: u16,
                }
                let proxy = Magphasemean {
                    phase: self.phase(),
                    mag: self.mag(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Magnitude standard deviation approximation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Magstd(pub u32);
        impl Magstd {
            #[doc = "Magnitude standard deviation approximation"]
            #[inline(always)]
            pub const fn magstd(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Magnitude standard deviation approximation"]
            #[inline(always)]
            pub fn set_magstd(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Magstd {
            #[inline(always)]
            fn default() -> Magstd {
                Magstd(0)
            }
        }
        impl core::fmt::Debug for Magstd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Magstd")
                    .field("magstd", &self.magstd())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Magstd {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Magstd {
                    magstd: u16,
                }
                let proxy = Magstd {
                    magstd: self.magstd(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of bytes to transfer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes to transfer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxcnt {
                    maxcnt: u16,
                }
                let proxy = Maxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The value of FREQUENCY that will be used in the next step"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nextfrequency(pub u32);
        impl Nextfrequency {
            #[doc = "Frequency = 2400 + FREQUENCY (MHz)"]
            #[inline(always)]
            pub const fn nextfrequency(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Frequency = 2400 + FREQUENCY (MHz)"]
            #[inline(always)]
            pub fn set_nextfrequency(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Nextfrequency {
            #[inline(always)]
            fn default() -> Nextfrequency {
                Nextfrequency(0)
            }
        }
        impl core::fmt::Debug for Nextfrequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nextfrequency")
                    .field("nextfrequency", &self.nextfrequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nextfrequency {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Nextfrequency {
                    nextfrequency: u8,
                }
                let proxy = Nextfrequency {
                    nextfrequency: self.nextfrequency(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of input samples at 2MHz sample rate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Numsamples(pub u32);
        impl Numsamples {
            #[doc = "Maximum value supported is 160"]
            #[inline(always)]
            pub const fn numsamples(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Maximum value supported is 160"]
            #[inline(always)]
            pub fn set_numsamples(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Numsamples {
            #[inline(always)]
            fn default() -> Numsamples {
                Numsamples(0)
            }
        }
        impl core::fmt::Debug for Numsamples {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Numsamples")
                    .field("numsamples", &self.numsamples())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Numsamples {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Numsamples {
                    numsamples: u8,
                }
                let proxy = Numsamples {
                    numsamples: self.numsamples(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Numsamplescoeff(pub u32);
        impl Numsamplescoeff {
            #[doc = "Coefficient 2**16/(numSamples/16) in Q1.15 format (Default numsamples value is 160)"]
            #[inline(always)]
            pub const fn numsamplescoeff(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Coefficient 2**16/(numSamples/16) in Q1.15 format (Default numsamples value is 160)"]
            #[inline(always)]
            pub fn set_numsamplescoeff(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Numsamplescoeff {
            #[inline(always)]
            fn default() -> Numsamplescoeff {
                Numsamplescoeff(0)
            }
        }
        impl core::fmt::Debug for Numsamplescoeff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Numsamplescoeff")
                    .field("numsamplescoeff", &self.numsamplescoeff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Numsamplescoeff {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Numsamplescoeff {
                    numsamplescoeff: u16,
                }
                let proxy = Numsamplescoeff {
                    numsamplescoeff: self.numsamplescoeff(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Packet configuration register 0"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcnf0(pub u32);
        impl Pcnf0 {
            #[doc = "Length on air of LENGTH field in number of bits."]
            #[inline(always)]
            pub const fn lflen(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Length on air of LENGTH field in number of bits."]
            #[inline(always)]
            pub fn set_lflen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Length on air of S0 field in number of bytes."]
            #[inline(always)]
            pub const fn s0len(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Length on air of S0 field in number of bytes."]
            #[inline(always)]
            pub fn set_s0len(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Length on air of S1 field in number of bits."]
            #[inline(always)]
            pub const fn s1len(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x0f;
                val as u8
            }
            #[doc = "Length on air of S1 field in number of bits."]
            #[inline(always)]
            pub fn set_s1len(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 16usize)) | (((val as u32) & 0x0f) << 16usize);
            }
            #[doc = "Include or exclude S1 field in RAM"]
            #[inline(always)]
            pub const fn s1incl(&self) -> super::vals::S1incl {
                let val = (self.0 >> 20usize) & 0x03;
                super::vals::S1incl::from_bits(val as u8)
            }
            #[doc = "Include or exclude S1 field in RAM"]
            #[inline(always)]
            pub fn set_s1incl(&mut self, val: super::vals::S1incl) {
                self.0 =
                    (self.0 & !(0x03 << 20usize)) | (((val.to_bits() as u32) & 0x03) << 20usize);
            }
            #[doc = "Length of code indicator - long range"]
            #[inline(always)]
            pub const fn cilen(&self) -> u8 {
                let val = (self.0 >> 22usize) & 0x03;
                val as u8
            }
            #[doc = "Length of code indicator - long range"]
            #[inline(always)]
            pub fn set_cilen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 22usize)) | (((val as u32) & 0x03) << 22usize);
            }
            #[doc = "Length of preamble on air. Decision point: TASKS_START task"]
            #[inline(always)]
            pub const fn plen(&self) -> super::vals::Plen {
                let val = (self.0 >> 24usize) & 0x03;
                super::vals::Plen::from_bits(val as u8)
            }
            #[doc = "Length of preamble on air. Decision point: TASKS_START task"]
            #[inline(always)]
            pub fn set_plen(&mut self, val: super::vals::Plen) {
                self.0 =
                    (self.0 & !(0x03 << 24usize)) | (((val.to_bits() as u32) & 0x03) << 24usize);
            }
            #[doc = "Indicates if LENGTH field contains CRC or not"]
            #[inline(always)]
            pub const fn crcinc(&self) -> super::vals::Crcinc {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Crcinc::from_bits(val as u8)
            }
            #[doc = "Indicates if LENGTH field contains CRC or not"]
            #[inline(always)]
            pub fn set_crcinc(&mut self, val: super::vals::Crcinc) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Length of TERM field in Long Range operation"]
            #[inline(always)]
            pub const fn termlen(&self) -> u8 {
                let val = (self.0 >> 29usize) & 0x03;
                val as u8
            }
            #[doc = "Length of TERM field in Long Range operation"]
            #[inline(always)]
            pub fn set_termlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x03 << 29usize)) | (((val as u32) & 0x03) << 29usize);
            }
        }
        impl Default for Pcnf0 {
            #[inline(always)]
            fn default() -> Pcnf0 {
                Pcnf0(0)
            }
        }
        impl core::fmt::Debug for Pcnf0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcnf0")
                    .field("lflen", &self.lflen())
                    .field("s0len", &self.s0len())
                    .field("s1len", &self.s1len())
                    .field("s1incl", &self.s1incl())
                    .field("cilen", &self.cilen())
                    .field("plen", &self.plen())
                    .field("crcinc", &self.crcinc())
                    .field("termlen", &self.termlen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcnf0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pcnf0 {
                    lflen: u8,
                    s0len: bool,
                    s1len: u8,
                    s1incl: super::vals::S1incl,
                    cilen: u8,
                    plen: super::vals::Plen,
                    crcinc: super::vals::Crcinc,
                    termlen: u8,
                }
                let proxy = Pcnf0 {
                    lflen: self.lflen(),
                    s0len: self.s0len(),
                    s1len: self.s1len(),
                    s1incl: self.s1incl(),
                    cilen: self.cilen(),
                    plen: self.plen(),
                    crcinc: self.crcinc(),
                    termlen: self.termlen(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Packet configuration register 1"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pcnf1(pub u32);
        impl Pcnf1 {
            #[doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[inline(always)]
            pub const fn maxlen(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Maximum length of packet payload. If the packet payload is larger than MAXLEN, the radio will truncate the payload to MAXLEN."]
            #[inline(always)]
            pub fn set_maxlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Static length in number of bytes"]
            #[inline(always)]
            pub const fn statlen(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Static length in number of bytes"]
            #[inline(always)]
            pub fn set_statlen(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Base address length in number of bytes"]
            #[inline(always)]
            pub const fn balen(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x07;
                val as u8
            }
            #[doc = "Base address length in number of bytes"]
            #[inline(always)]
            pub fn set_balen(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 16usize)) | (((val as u32) & 0x07) << 16usize);
            }
            #[doc = "On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields."]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 24usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "On-air endianness of packet, this applies to the S0, LENGTH, S1, and the PAYLOAD fields."]
            #[inline(always)]
            pub fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 =
                    (self.0 & !(0x01 << 24usize)) | (((val.to_bits() as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable packet whitening"]
            #[inline(always)]
            pub const fn whiteen(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable packet whitening"]
            #[inline(always)]
            pub fn set_whiteen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "If whitening is enabled S0 can be configured to be excluded from whitening"]
            #[inline(always)]
            pub const fn whiteoffset(&self) -> super::vals::Whiteoffset {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Whiteoffset::from_bits(val as u8)
            }
            #[doc = "If whitening is enabled S0 can be configured to be excluded from whitening"]
            #[inline(always)]
            pub fn set_whiteoffset(&mut self, val: super::vals::Whiteoffset) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
        }
        impl Default for Pcnf1 {
            #[inline(always)]
            fn default() -> Pcnf1 {
                Pcnf1(0)
            }
        }
        impl core::fmt::Debug for Pcnf1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pcnf1")
                    .field("maxlen", &self.maxlen())
                    .field("statlen", &self.statlen())
                    .field("balen", &self.balen())
                    .field("endian", &self.endian())
                    .field("whiteen", &self.whiteen())
                    .field("whiteoffset", &self.whiteoffset())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pcnf1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pcnf1 {
                    maxlen: u8,
                    statlen: u8,
                    balen: u8,
                    endian: super::vals::Endian,
                    whiteen: bool,
                    whiteoffset: super::vals::Whiteoffset,
                }
                let proxy = Pcnf1 {
                    maxlen: self.maxlen(),
                    statlen: self.statlen(),
                    balen: self.balen(),
                    endian: self.endian(),
                    whiteen: self.whiteen(),
                    whiteoffset: self.whiteoffset(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ. IQ values limited to \\[-1024,1023\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pct11(pub u32);
        impl Pct11 {
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn pct11i(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub fn set_pct11i(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn pct11q(&self) -> u16 {
                let val = (self.0 >> 11usize) & 0x07ff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub fn set_pct11q(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 11usize)) | (((val as u32) & 0x07ff) << 11usize);
            }
        }
        impl Default for Pct11 {
            #[inline(always)]
            fn default() -> Pct11 {
                Pct11(0)
            }
        }
        impl core::fmt::Debug for Pct11 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pct11")
                    .field("pct11i", &self.pct11i())
                    .field("pct11q", &self.pct11q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pct11 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pct11 {
                    pct11i: u16,
                    pct11q: u16,
                }
                let proxy = Pct11 {
                    pct11i: self.pct11i(),
                    pct11q: self.pct11q(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Mean magnitude and mean phase converted to IQ"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pct16(pub u32);
        impl Pct16 {
            #[doc = "Inphase"]
            #[inline(always)]
            pub const fn pct16i(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Inphase"]
            #[inline(always)]
            pub fn set_pct16i(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub const fn pct16q(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "Quadrature"]
            #[inline(always)]
            pub fn set_pct16q(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Pct16 {
            #[inline(always)]
            fn default() -> Pct16 {
                Pct16(0)
            }
        }
        impl core::fmt::Debug for Pct16 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pct16")
                    .field("pct16i", &self.pct16i())
                    .field("pct16q", &self.pct16q())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pct16 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pct16 {
                    pct16i: u16,
                    pct16q: u16,
                }
                let proxy = Pct16 {
                    pct16i: self.pct16i(),
                    pct16q: self.pct16q(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Payload status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pdustat(pub u32);
        impl Pdustat {
            #[doc = "Status on payload length vs. PCNF1.MAXLEN"]
            #[inline(always)]
            pub const fn pdustat(&self) -> super::vals::Pdustat {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Pdustat::from_bits(val as u8)
            }
            #[doc = "Status on payload length vs. PCNF1.MAXLEN"]
            #[inline(always)]
            pub fn set_pdustat(&mut self, val: super::vals::Pdustat) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Status on what rate packet is received with in Long Range"]
            #[inline(always)]
            pub const fn cistat(&self) -> super::vals::Cistat {
                let val = (self.0 >> 1usize) & 0x03;
                super::vals::Cistat::from_bits(val as u8)
            }
            #[doc = "Status on what rate packet is received with in Long Range"]
            #[inline(always)]
            pub fn set_cistat(&mut self, val: super::vals::Cistat) {
                self.0 = (self.0 & !(0x03 << 1usize)) | (((val.to_bits() as u32) & 0x03) << 1usize);
            }
        }
        impl Default for Pdustat {
            #[inline(always)]
            fn default() -> Pdustat {
                Pdustat(0)
            }
        }
        impl core::fmt::Debug for Pdustat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pdustat")
                    .field("pdustat", &self.pdustat())
                    .field("cistat", &self.cistat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pdustat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pdustat {
                    pdustat: super::vals::Pdustat,
                    cistat: super::vals::Cistat,
                }
                let proxy = Pdustat {
                    pdustat: self.pdustat(),
                    cistat: self.cistat(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Parameter used in TPM, provided by software"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Phaseshift(pub u32);
        impl Phaseshift {
            #[doc = "Phase shift used in TPM calculation"]
            #[inline(always)]
            pub const fn phaseshift(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Phase shift used in TPM calculation"]
            #[inline(always)]
            pub fn set_phaseshift(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Phaseshift {
            #[inline(always)]
            fn default() -> Phaseshift {
                Phaseshift(0)
            }
        }
        impl core::fmt::Debug for Phaseshift {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Phaseshift")
                    .field("phaseshift", &self.phaseshift())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Phaseshift {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Phaseshift {
                    phaseshift: u16,
                }
                let proxy = Phaseshift {
                    phaseshift: self.phaseshift(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Prefixes bytes for logical addresses 0-3"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prefix0(pub u32);
        impl Prefix0 {
            #[doc = "Address prefix 0"]
            #[inline(always)]
            pub const fn ap0(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 0"]
            #[inline(always)]
            pub fn set_ap0(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Address prefix 1"]
            #[inline(always)]
            pub const fn ap1(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 1"]
            #[inline(always)]
            pub fn set_ap1(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Address prefix 2"]
            #[inline(always)]
            pub const fn ap2(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 2"]
            #[inline(always)]
            pub fn set_ap2(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Address prefix 3"]
            #[inline(always)]
            pub const fn ap3(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 3"]
            #[inline(always)]
            pub fn set_ap3(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Prefix0 {
            #[inline(always)]
            fn default() -> Prefix0 {
                Prefix0(0)
            }
        }
        impl core::fmt::Debug for Prefix0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prefix0")
                    .field("ap0", &self.ap0())
                    .field("ap1", &self.ap1())
                    .field("ap2", &self.ap2())
                    .field("ap3", &self.ap3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prefix0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Prefix0 {
                    ap0: u8,
                    ap1: u8,
                    ap2: u8,
                    ap3: u8,
                }
                let proxy = Prefix0 {
                    ap0: self.ap0(),
                    ap1: self.ap1(),
                    ap2: self.ap2(),
                    ap3: self.ap3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Prefixes bytes for logical addresses 4-7"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prefix1(pub u32);
        impl Prefix1 {
            #[doc = "Address prefix 4"]
            #[inline(always)]
            pub const fn ap4(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 4"]
            #[inline(always)]
            pub fn set_ap4(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[doc = "Address prefix 5"]
            #[inline(always)]
            pub const fn ap5(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 5"]
            #[inline(always)]
            pub fn set_ap5(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 8usize)) | (((val as u32) & 0xff) << 8usize);
            }
            #[doc = "Address prefix 6"]
            #[inline(always)]
            pub const fn ap6(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 6"]
            #[inline(always)]
            pub fn set_ap6(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 16usize)) | (((val as u32) & 0xff) << 16usize);
            }
            #[doc = "Address prefix 7"]
            #[inline(always)]
            pub const fn ap7(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0xff;
                val as u8
            }
            #[doc = "Address prefix 7"]
            #[inline(always)]
            pub fn set_ap7(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 24usize)) | (((val as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Prefix1 {
            #[inline(always)]
            fn default() -> Prefix1 {
                Prefix1(0)
            }
        }
        impl core::fmt::Debug for Prefix1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prefix1")
                    .field("ap4", &self.ap4())
                    .field("ap5", &self.ap5())
                    .field("ap6", &self.ap6())
                    .field("ap7", &self.ap7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prefix1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Prefix1 {
                    ap4: u8,
                    ap5: u8,
                    ap6: u8,
                    ap7: u8,
                }
                let proxy = Prefix1 {
                    ap4: self.ap4(),
                    ap5: self.ap5(),
                    ap6: self.ap6(),
                    ap7: self.ap7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Data rate and modulation"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RadioMode(pub u32);
        impl RadioMode {
            #[doc = "Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Radio data rate and modulation setting. The radio supports frequency-shift keying (FSK) modulation."]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for RadioMode {
            #[inline(always)]
            fn default() -> RadioMode {
                RadioMode(0)
            }
        }
        impl core::fmt::Debug for RadioMode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RadioMode")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RadioMode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RadioMode {
                    mode: super::vals::Mode,
                }
                let proxy = RadioMode { mode: self.mode() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RSSI sample"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rssisample(pub u32);
        impl Rssisample {
            #[doc = "RSSI sample result. The value of this register is read as a positive value while the actual received signal strength is a negative value. Actual received signal strength is therefore as follows: received signal strength = -A dBm."]
            #[inline(always)]
            pub const fn rssisample(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "RSSI sample result. The value of this register is read as a positive value while the actual received signal strength is a negative value. Actual received signal strength is therefore as follows: received signal strength = -A dBm."]
            #[inline(always)]
            pub fn set_rssisample(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Rssisample {
            #[inline(always)]
            fn default() -> Rssisample {
                Rssisample(0)
            }
        }
        impl core::fmt::Debug for Rssisample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rssisample")
                    .field("rssisample", &self.rssisample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rssisample {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rssisample {
                    rssisample: u8,
                }
                let proxy = Rssisample {
                    rssisample: self.rssisample(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Receive address select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxaddresses(pub u32);
        impl Rxaddresses {
            #[doc = "Enable or disable reception on logical address 0"]
            #[inline(always)]
            pub const fn addr0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 0"]
            #[inline(always)]
            pub fn set_addr0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable reception on logical address 1"]
            #[inline(always)]
            pub const fn addr1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 1"]
            #[inline(always)]
            pub fn set_addr1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable reception on logical address 2"]
            #[inline(always)]
            pub const fn addr2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 2"]
            #[inline(always)]
            pub fn set_addr2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable reception on logical address 3"]
            #[inline(always)]
            pub const fn addr3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 3"]
            #[inline(always)]
            pub fn set_addr3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable reception on logical address 4"]
            #[inline(always)]
            pub const fn addr4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 4"]
            #[inline(always)]
            pub fn set_addr4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable reception on logical address 5"]
            #[inline(always)]
            pub const fn addr5(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 5"]
            #[inline(always)]
            pub fn set_addr5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable reception on logical address 6"]
            #[inline(always)]
            pub const fn addr6(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 6"]
            #[inline(always)]
            pub fn set_addr6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Enable or disable reception on logical address 7"]
            #[inline(always)]
            pub const fn addr7(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable reception on logical address 7"]
            #[inline(always)]
            pub fn set_addr7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Rxaddresses {
            #[inline(always)]
            fn default() -> Rxaddresses {
                Rxaddresses(0)
            }
        }
        impl core::fmt::Debug for Rxaddresses {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxaddresses")
                    .field("addr0", &self.addr0())
                    .field("addr1", &self.addr1())
                    .field("addr2", &self.addr2())
                    .field("addr3", &self.addr3())
                    .field("addr4", &self.addr4())
                    .field("addr5", &self.addr5())
                    .field("addr6", &self.addr6())
                    .field("addr7", &self.addr7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxaddresses {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rxaddresses {
                    addr0: bool,
                    addr1: bool,
                    addr2: bool,
                    addr3: bool,
                    addr4: bool,
                    addr5: bool,
                    addr6: bool,
                    addr7: bool,
                }
                let proxy = Rxaddresses {
                    addr0: self.addr0(),
                    addr1: self.addr1(),
                    addr2: self.addr2(),
                    addr3: self.addr3(),
                    addr4: self.addr4(),
                    addr5: self.addr5(),
                    addr6: self.addr6(),
                    addr7: self.addr7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "CRC field of previously received packet"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxcrc(pub u32);
        impl Rxcrc {
            #[doc = "CRC field of previously received packet"]
            #[inline(always)]
            pub const fn rxcrc(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "CRC field of previously received packet"]
            #[inline(always)]
            pub fn set_rxcrc(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Rxcrc {
            #[inline(always)]
            fn default() -> Rxcrc {
                Rxcrc(0)
            }
        }
        impl core::fmt::Debug for Rxcrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxcrc")
                    .field("rxcrc", &self.rxcrc())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxcrc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rxcrc {
                    rxcrc: u32,
                }
                let proxy = Rxcrc {
                    rxcrc: self.rxcrc(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Received address"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxmatch(pub u32);
        impl Rxmatch {
            #[doc = "Received address"]
            #[inline(always)]
            pub const fn rxmatch(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Received address"]
            #[inline(always)]
            pub fn set_rxmatch(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rxmatch {
            #[inline(always)]
            fn default() -> Rxmatch {
                Rxmatch(0)
            }
        }
        impl core::fmt::Debug for Rxmatch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxmatch")
                    .field("rxmatch", &self.rxmatch())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxmatch {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rxmatch {
                    rxmatch: u8,
                }
                let proxy = Rxmatch {
                    rxmatch: self.rxmatch(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "IEEE 802.15.4 start of frame delimiter"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sfd(pub u32);
        impl Sfd {
            #[doc = "IEEE 802.15.4 start of frame delimiter. Note: the least significant 4 bits of the SFD cannot all be zeros."]
            #[inline(always)]
            pub const fn sfd(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "IEEE 802.15.4 start of frame delimiter. Note: the least significant 4 bits of the SFD cannot all be zeros."]
            #[inline(always)]
            pub fn set_sfd(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Sfd {
            #[inline(always)]
            fn default() -> Sfd {
                Sfd(0)
            }
        }
        impl core::fmt::Debug for Sfd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sfd").field("sfd", &self.sfd()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sfd {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Sfd {
                    sfd: u8,
                }
                let proxy = Sfd { sfd: self.sfd() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event READY and task START"]
            #[inline(always)]
            pub const fn ready_start(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task START"]
            #[inline(always)]
            pub fn set_ready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Shortcut between event DISABLED and task TXEN"]
            #[inline(always)]
            pub const fn disabled_txen(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DISABLED and task TXEN"]
            #[inline(always)]
            pub fn set_disabled_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event DISABLED and task RXEN"]
            #[inline(always)]
            pub const fn disabled_rxen(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DISABLED and task RXEN"]
            #[inline(always)]
            pub fn set_disabled_rxen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Shortcut between event ADDRESS and task RSSISTART"]
            #[inline(always)]
            pub const fn address_rssistart(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ADDRESS and task RSSISTART"]
            #[inline(always)]
            pub fn set_address_rssistart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event ADDRESS and task BCSTART"]
            #[inline(always)]
            pub const fn address_bcstart(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event ADDRESS and task BCSTART"]
            #[inline(always)]
            pub fn set_address_bcstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event RXREADY and task CCASTART"]
            #[inline(always)]
            pub const fn rxready_ccastart(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RXREADY and task CCASTART"]
            #[inline(always)]
            pub fn set_rxready_ccastart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event CCAIDLE and task TXEN"]
            #[inline(always)]
            pub const fn ccaidle_txen(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCAIDLE and task TXEN"]
            #[inline(always)]
            pub fn set_ccaidle_txen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Shortcut between event CCABUSY and task DISABLE"]
            #[inline(always)]
            pub const fn ccabusy_disable(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCABUSY and task DISABLE"]
            #[inline(always)]
            pub fn set_ccabusy_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Shortcut between event FRAMESTART and task BCSTART"]
            #[inline(always)]
            pub const fn framestart_bcstart(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FRAMESTART and task BCSTART"]
            #[inline(always)]
            pub fn set_framestart_bcstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READY and task EDSTART"]
            #[inline(always)]
            pub const fn ready_edstart(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READY and task EDSTART"]
            #[inline(always)]
            pub fn set_ready_edstart(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Shortcut between event EDEND and task DISABLE"]
            #[inline(always)]
            pub const fn edend_disable(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event EDEND and task DISABLE"]
            #[inline(always)]
            pub fn set_edend_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Shortcut between event CCAIDLE and task STOP"]
            #[inline(always)]
            pub const fn ccaidle_stop(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event CCAIDLE and task STOP"]
            #[inline(always)]
            pub fn set_ccaidle_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Shortcut between event TXREADY and task START"]
            #[inline(always)]
            pub const fn txready_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event TXREADY and task START"]
            #[inline(always)]
            pub fn set_txready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shortcut between event RXREADY and task START"]
            #[inline(always)]
            pub const fn rxready_start(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event RXREADY and task START"]
            #[inline(always)]
            pub fn set_rxready_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Shortcut between event PHYEND and task DISABLE"]
            #[inline(always)]
            pub const fn phyend_disable(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event PHYEND and task DISABLE"]
            #[inline(always)]
            pub fn set_phyend_disable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Shortcut between event PHYEND and task START"]
            #[inline(always)]
            pub const fn phyend_start(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event PHYEND and task START"]
            #[inline(always)]
            pub fn set_phyend_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("ready_start", &self.ready_start())
                    .field("disabled_txen", &self.disabled_txen())
                    .field("disabled_rxen", &self.disabled_rxen())
                    .field("address_rssistart", &self.address_rssistart())
                    .field("end_start", &self.end_start())
                    .field("address_bcstart", &self.address_bcstart())
                    .field("rxready_ccastart", &self.rxready_ccastart())
                    .field("ccaidle_txen", &self.ccaidle_txen())
                    .field("ccabusy_disable", &self.ccabusy_disable())
                    .field("framestart_bcstart", &self.framestart_bcstart())
                    .field("ready_edstart", &self.ready_edstart())
                    .field("edend_disable", &self.edend_disable())
                    .field("ccaidle_stop", &self.ccaidle_stop())
                    .field("txready_start", &self.txready_start())
                    .field("rxready_start", &self.rxready_start())
                    .field("phyend_disable", &self.phyend_disable())
                    .field("phyend_start", &self.phyend_start())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    ready_start: bool,
                    disabled_txen: bool,
                    disabled_rxen: bool,
                    address_rssistart: bool,
                    end_start: bool,
                    address_bcstart: bool,
                    rxready_ccastart: bool,
                    ccaidle_txen: bool,
                    ccabusy_disable: bool,
                    framestart_bcstart: bool,
                    ready_edstart: bool,
                    edend_disable: bool,
                    ccaidle_stop: bool,
                    txready_start: bool,
                    rxready_start: bool,
                    phyend_disable: bool,
                    phyend_start: bool,
                }
                let proxy = Shorts {
                    ready_start: self.ready_start(),
                    disabled_txen: self.disabled_txen(),
                    disabled_rxen: self.disabled_rxen(),
                    address_rssistart: self.address_rssistart(),
                    end_start: self.end_start(),
                    address_bcstart: self.address_bcstart(),
                    rxready_ccastart: self.rxready_ccastart(),
                    ccaidle_txen: self.ccaidle_txen(),
                    ccabusy_disable: self.ccabusy_disable(),
                    framestart_bcstart: self.framestart_bcstart(),
                    ready_edstart: self.ready_edstart(),
                    edend_disable: self.edend_disable(),
                    ccaidle_stop: self.ccaidle_stop(),
                    txready_start: self.txready_start(),
                    rxready_start: self.rxready_start(),
                    phyend_disable: self.phyend_disable(),
                    phyend_start: self.phyend_start(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Current radio state"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct State(pub u32);
        impl State {
            #[doc = "Current radio state"]
            #[inline(always)]
            pub const fn state(&self) -> super::vals::State {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::State::from_bits(val as u8)
            }
            #[doc = "Current radio state"]
            #[inline(always)]
            pub fn set_state(&mut self, val: super::vals::State) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for State {
            #[inline(always)]
            fn default() -> State {
                State(0)
            }
        }
        impl core::fmt::Debug for State {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("State")
                    .field("state", &self.state())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for State {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct State {
                    state: super::vals::State,
                }
                let proxy = State {
                    state: self.state(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "GPIO patterns to be used for each antenna"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Switchpattern(pub u32);
        impl Switchpattern {
            #[doc = "Fill array of GPIO patterns for antenna control"]
            #[inline(always)]
            pub const fn switchpattern(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Fill array of GPIO patterns for antenna control"]
            #[inline(always)]
            pub fn set_switchpattern(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Switchpattern {
            #[inline(always)]
            fn default() -> Switchpattern {
                Switchpattern(0)
            }
        }
        impl core::fmt::Debug for Switchpattern {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Switchpattern")
                    .field("switchpattern", &self.switchpattern())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Switchpattern {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Switchpattern {
                    switchpattern: u8,
                }
                let proxy = Switchpattern {
                    switchpattern: self.switchpattern(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Interframe spacing in us"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tifs(pub u32);
        impl Tifs {
            #[doc = "Interframe spacing in us. Interframe space is the time interval between two consecutive packets. It is defined as the time, in microseconds, from the end of the last bit of the previous packet to the start of the first bit of the subsequent packet."]
            #[inline(always)]
            pub const fn tifs(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Interframe spacing in us. Interframe space is the time interval between two consecutive packets. It is defined as the time, in microseconds, from the end of the last bit of the previous packet to the start of the first bit of the subsequent packet."]
            #[inline(always)]
            pub fn set_tifs(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Tifs {
            #[inline(always)]
            fn default() -> Tifs {
                Tifs(0)
            }
        }
        impl core::fmt::Debug for Tifs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tifs").field("tifs", &self.tifs()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tifs {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tifs {
                    tifs: u16,
                }
                let proxy = Tifs { tifs: self.tifs() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Timing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Timing(pub u32);
        impl Timing {
            #[doc = "Ramp-up time"]
            #[inline(always)]
            pub const fn ru(&self) -> super::vals::Ru {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Ru::from_bits(val as u8)
            }
            #[doc = "Ramp-up time"]
            #[inline(always)]
            pub fn set_ru(&mut self, val: super::vals::Ru) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Timing {
            #[inline(always)]
            fn default() -> Timing {
                Timing(0)
            }
        }
        impl core::fmt::Debug for Timing {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Timing").field("ru", &self.ru()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Timing {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Timing {
                    ru: super::vals::Ru,
                }
                let proxy = Timing { ru: self.ru() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Transmit address select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txaddress(pub u32);
        impl Txaddress {
            #[doc = "Transmit address select"]
            #[inline(always)]
            pub const fn txaddress(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Transmit address select"]
            #[inline(always)]
            pub fn set_txaddress(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Txaddress {
            #[inline(always)]
            fn default() -> Txaddress {
                Txaddress(0)
            }
        }
        impl core::fmt::Debug for Txaddress {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txaddress")
                    .field("txaddress", &self.txaddress())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txaddress {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Txaddress {
                    txaddress: u8,
                }
                let proxy = Txaddress {
                    txaddress: self.txaddress(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Output power"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Txpower(pub u32);
        impl Txpower {
            #[doc = "RADIO output power"]
            #[inline(always)]
            pub const fn txpower(&self) -> super::vals::Txpower {
                let val = (self.0 >> 0usize) & 0x07ff;
                super::vals::Txpower::from_bits(val as u16)
            }
            #[doc = "RADIO output power"]
            #[inline(always)]
            pub fn set_txpower(&mut self, val: super::vals::Txpower) {
                self.0 =
                    (self.0 & !(0x07ff << 0usize)) | (((val.to_bits() as u32) & 0x07ff) << 0usize);
            }
        }
        impl Default for Txpower {
            #[inline(always)]
            fn default() -> Txpower {
                Txpower(0)
            }
        }
        impl core::fmt::Debug for Txpower {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Txpower")
                    .field("txpower", &self.txpower())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txpower {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Txpower {
                    txpower: super::vals::Txpower,
                }
                let proxy = Txpower {
                    txpower: self.txpower(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ccamode {
            #[doc = "Energy above threshold"]
            ED_MODE = 0x0,
            #[doc = "Carrier seen"]
            CARRIER_MODE = 0x01,
            #[doc = "Energy above threshold AND carrier seen"]
            CARRIER_AND_ED_MODE = 0x02,
            #[doc = "Energy above threshold OR carrier seen"]
            CARRIER_OR_ED_MODE = 0x03,
            #[doc = "Energy above threshold test mode that will abort when first ED measurement over threshold is seen. No averaging."]
            ED_MODE_TEST1 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Ccamode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ccamode {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ccamode {
            #[inline(always)]
            fn from(val: u8) -> Ccamode {
                Ccamode::from_bits(val)
            }
        }
        impl From<Ccamode> for u8 {
            #[inline(always)]
            fn from(val: Ccamode) -> u8 {
                Ccamode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cistat {
            #[doc = "Frame is received at 125 kbps"]
            LR125KBIT = 0x0,
            #[doc = "Frame is received at 500 kbps"]
            LR500KBIT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Cistat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cistat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cistat {
            #[inline(always)]
            fn from(val: u8) -> Cistat {
                Cistat::from_bits(val)
            }
        }
        impl From<Cistat> for u8 {
            #[inline(always)]
            fn from(val: Cistat) -> u8 {
                Cistat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcinc {
            #[doc = "LENGTH does not contain CRC"]
            EXCLUDE = 0x0,
            #[doc = "LENGTH includes CRC"]
            INCLUDE = 0x01,
        }
        impl Crcinc {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcinc {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcinc {
            #[inline(always)]
            fn from(val: u8) -> Crcinc {
                Crcinc::from_bits(val)
            }
        }
        impl From<Crcinc> for u8 {
            #[inline(always)]
            fn from(val: Crcinc) -> u8 {
                Crcinc::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Crcstatus {
            #[doc = "Packet received with CRC error"]
            CRCERROR = 0x0,
            #[doc = "Packet received with CRC ok"]
            CRCOK = 0x01,
        }
        impl Crcstatus {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Crcstatus {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Crcstatus {
            #[inline(always)]
            fn from(val: u8) -> Crcstatus {
                Crcstatus::from_bits(val)
            }
        }
        impl From<Crcstatus> for u8 {
            #[inline(always)]
            fn from(val: Crcstatus) -> u8 {
                Crcstatus::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cteinlinerxmode1us {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cteinlinerxmode1us {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cteinlinerxmode1us {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cteinlinerxmode1us {
            #[inline(always)]
            fn from(val: u8) -> Cteinlinerxmode1us {
                Cteinlinerxmode1us::from_bits(val)
            }
        }
        impl From<Cteinlinerxmode1us> for u8 {
            #[inline(always)]
            fn from(val: Cteinlinerxmode1us) -> u8 {
                Cteinlinerxmode1us::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cteinlinerxmode2us {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Cteinlinerxmode2us {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cteinlinerxmode2us {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cteinlinerxmode2us {
            #[inline(always)]
            fn from(val: u8) -> Cteinlinerxmode2us {
                Cteinlinerxmode2us::from_bits(val)
            }
        }
        impl From<Cteinlinerxmode2us> for u8 {
            #[inline(always)]
            fn from(val: Cteinlinerxmode2us) -> u8 {
                Cteinlinerxmode2us::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ctetimevalidrange {
            #[doc = "20 in 8us unit (default) Set to 20 if parsed CTETime is larger han 20"]
            _20 = 0x0,
            #[doc = "31 in 8us unit"]
            _31 = 0x01,
            #[doc = "63 in 8us unit"]
            _63 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Ctetimevalidrange {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ctetimevalidrange {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ctetimevalidrange {
            #[inline(always)]
            fn from(val: u8) -> Ctetimevalidrange {
                Ctetimevalidrange::from_bits(val)
            }
        }
        impl From<Ctetimevalidrange> for u8 {
            #[inline(always)]
            fn from(val: Ctetimevalidrange) -> u8 {
                Ctetimevalidrange::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfeinextension {
            #[doc = "Antenna switching/sampling is done in the packet payload"]
            PAYLOAD = 0x0,
            #[doc = "AoA/AoD procedure triggered at end of CRC"]
            CRC = 0x01,
        }
        impl Dfeinextension {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfeinextension {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfeinextension {
            #[inline(always)]
            fn from(val: u8) -> Dfeinextension {
                Dfeinextension::from_bits(val)
            }
        }
        impl From<Dfeinextension> for u8 {
            #[inline(always)]
            fn from(val: Dfeinextension) -> u8 {
                Dfeinextension::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dfeopmode {
            #[doc = "Direction finding mode disabled"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Direction finding mode set to AoD"]
            AO_D = 0x02,
            #[doc = "Direction finding mode set to AoA"]
            AO_A = 0x03,
        }
        impl Dfeopmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dfeopmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dfeopmode {
            #[inline(always)]
            fn from(val: u8) -> Dfeopmode {
                Dfeopmode::from_bits(val)
            }
        }
        impl From<Dfeopmode> for u8 {
            #[inline(always)]
            fn from(val: Dfeopmode) -> u8 {
                Dfeopmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Least significant bit on air first"]
            LITTLE = 0x0,
            #[doc = "Most significant bit on air first"]
            BIG = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ffosource {
            #[doc = "Use FFOIN"]
            EXTERNAL = 0x0,
            #[doc = "Calc FFO from CnAcc"]
            INTERNAL = 0x01,
        }
        impl Ffosource {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ffosource {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ffosource {
            #[inline(always)]
            fn from(val: u8) -> Ffosource {
                Ffosource::from_bits(val)
            }
        }
        impl From<Ffosource> for u8 {
            #[inline(always)]
            fn from(val: Ffosource) -> u8 {
                Ffosource::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Len {
            #[doc = "CRC length is zero and CRC calculation is disabled"]
            DISABLED = 0x0,
            #[doc = "CRC length is one byte and CRC calculation is enabled"]
            ONE = 0x01,
            #[doc = "CRC length is two bytes and CRC calculation is enabled"]
            TWO = 0x02,
            #[doc = "CRC length is three bytes and CRC calculation is enabled"]
            THREE = 0x03,
        }
        impl Len {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Len {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Len {
            #[inline(always)]
            fn from(val: u8) -> Len {
                Len::from_bits(val)
            }
        }
        impl From<Len> for u8 {
            #[inline(always)]
            fn from(val: Len) -> u8 {
                Len::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "1 Mbps Nordic proprietary radio mode"]
            NRF_1MBIT = 0x0,
            #[doc = "2 Mbps Nordic proprietary radio mode"]
            NRF_2MBIT = 0x01,
            _RESERVED_2 = 0x02,
            #[doc = "1 Mbps BLE"]
            BLE_1MBIT = 0x03,
            #[doc = "2 Mbps BLE"]
            BLE_2MBIT = 0x04,
            #[doc = "Long range 125 kbps TX, 125 kbps and 500 kbps RX"]
            BLE_LR125KBIT = 0x05,
            #[doc = "Long range 500 kbps TX, 125 kbps and 500 kbps RX"]
            BLE_LR500KBIT = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "4 Mbps Nordic proprietary radio mode (BT=0.6/h=0.5)"]
            NRF_4MBIT_0BT6 = 0x09,
            #[doc = "4 Mbps Nordic proprietary radio mode (BT=0.4/h=0.5)"]
            NRF_4MBIT_0BT4 = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "IEEE 802.15.4-2006 250 kbps"]
            IEEE802154_250KBIT = 0x0f,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pdustat {
            #[doc = "Payload less than PCNF1.MAXLEN"]
            LESS_THAN = 0x0,
            #[doc = "Payload greater than PCNF1.MAXLEN"]
            GREATER_THAN = 0x01,
        }
        impl Pdustat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pdustat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pdustat {
            #[inline(always)]
            fn from(val: u8) -> Pdustat {
                Pdustat::from_bits(val)
            }
        }
        impl From<Pdustat> for u8 {
            #[inline(always)]
            fn from(val: Pdustat) -> u8 {
                Pdustat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Plen {
            #[doc = "8-bit preamble"]
            _8BIT = 0x0,
            #[doc = "16-bit preamble"]
            _16BIT = 0x01,
            #[doc = "32-bit zero preamble - used for IEEE 802.15.4"]
            _32BIT_ZERO = 0x02,
            #[doc = "Preamble - used for BLE long range"]
            LONG_RANGE = 0x03,
        }
        impl Plen {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Plen {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Plen {
            #[inline(always)]
            fn from(val: u8) -> Plen {
                Plen::from_bits(val)
            }
        }
        impl From<Plen> for u8 {
            #[inline(always)]
            fn from(val: Plen) -> u8 {
                Plen::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Rate {
            #[doc = "Radio mode BLE1M is used"]
            BLE1M = 0x0,
            #[doc = "Radio mode BLE2M is used"]
            BLE2M = 0x01,
        }
        impl Rate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Rate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Rate {
            #[inline(always)]
            fn from(val: u8) -> Rate {
                Rate::from_bits(val)
            }
        }
        impl From<Rate> for u8 {
            #[inline(always)]
            fn from(val: Rate) -> u8 {
                Rate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Repeatpattern {
            #[doc = "Do not repeat (1 time in total)"]
            NO_REPEAT = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Repeatpattern {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Repeatpattern {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Repeatpattern {
            #[inline(always)]
            fn from(val: u8) -> Repeatpattern {
                Repeatpattern::from_bits(val)
            }
        }
        impl From<Repeatpattern> for u8 {
            #[inline(always)]
            fn from(val: Repeatpattern) -> u8 {
                Repeatpattern::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Role {
            #[doc = "Initiator"]
            INITIATOR = 0x0,
            #[doc = "Reflector"]
            REFLECTOR = 0x01,
        }
        impl Role {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Role {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Role {
            #[inline(always)]
            fn from(val: u8) -> Role {
                Role::from_bits(val)
            }
        }
        impl From<Role> for u8 {
            #[inline(always)]
            fn from(val: Role) -> u8 {
                Role::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ru {
            #[doc = "Legacy ramp-up time"]
            LEGACY = 0x0,
            #[doc = "Fast ramp-up (default)"]
            FAST = 0x01,
        }
        impl Ru {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ru {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ru {
            #[inline(always)]
            fn from(val: u8) -> Ru {
                Ru::from_bits(val)
            }
        }
        impl From<Ru> for u8 {
            #[inline(always)]
            fn from(val: Ru) -> u8 {
                Ru::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum S1incl {
            #[doc = "Include S1 field in RAM only if S1LEN &gt; 0"]
            AUTOMATIC = 0x0,
            #[doc = "Always include S1 field in RAM independent of S1LEN"]
            INCLUDE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl S1incl {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> S1incl {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for S1incl {
            #[inline(always)]
            fn from(val: u8) -> S1incl {
                S1incl::from_bits(val)
            }
        }
        impl From<S1incl> for u8 {
            #[inline(always)]
            fn from(val: S1incl) -> u8 {
                S1incl::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sampletype {
            #[doc = "Complex samples in I and Q"]
            IQ = 0x0,
            #[doc = "Complex samples as magnitude and phase"]
            MAG_PHASE = 0x01,
        }
        impl Sampletype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sampletype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sampletype {
            #[inline(always)]
            fn from(val: u8) -> Sampletype {
                Sampletype::from_bits(val)
            }
        }
        impl From<Sampletype> for u8 {
            #[inline(always)]
            fn from(val: Sampletype) -> u8 {
                Sampletype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Samplingstate {
            #[doc = "Sampling state Idle"]
            IDLE = 0x0,
            #[doc = "Sampling state Sampling"]
            SAMPLING = 0x01,
        }
        impl Samplingstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Samplingstate {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Samplingstate {
            #[inline(always)]
            fn from(val: u8) -> Samplingstate {
                Samplingstate::from_bits(val)
            }
        }
        impl From<Samplingstate> for u8 {
            #[inline(always)]
            fn from(val: Samplingstate) -> u8 {
                Samplingstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Skipaddr {
            #[doc = "CRC calculation includes address field"]
            INCLUDE = 0x0,
            #[doc = "CRC calculation starting at first byte after address field."]
            SKIP = 0x01,
            #[doc = "CRC calculation starting at first byte after length field (as per 802.15.4 standard)."]
            IEEE802154 = 0x02,
            #[doc = "CRC calculation starting at first byte after S0 field."]
            SKIP_S0 = 0x03,
            #[doc = "CRC calculation starting at first byte after S1 field."]
            SKIP_S1 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Skipaddr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Skipaddr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Skipaddr {
            #[inline(always)]
            fn from(val: u8) -> Skipaddr {
                Skipaddr::from_bits(val)
            }
        }
        impl From<Skipaddr> for u8 {
            #[inline(always)]
            fn from(val: Skipaddr) -> u8 {
                Skipaddr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum State {
            #[doc = "RADIO is in the DISABLED state"]
            DISABLED = 0x0,
            #[doc = "RADIO is in the RXRU state"]
            RX_RU = 0x01,
            #[doc = "RADIO is in the RXIDLE state"]
            RX_IDLE = 0x02,
            #[doc = "RADIO is in the RX state"]
            RX = 0x03,
            #[doc = "RADIO is in the RXDISABLE state"]
            RX_DISABLE = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "RADIO is in the TXRU state"]
            TX_RU = 0x09,
            #[doc = "RADIO is in the TXIDLE state"]
            TX_IDLE = 0x0a,
            #[doc = "RADIO is in the TX state"]
            TX = 0x0b,
            #[doc = "RADIO is in the TXDISABLE state"]
            TX_DISABLE = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl State {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> State {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for State {
            #[inline(always)]
            fn from(val: u8) -> State {
                State::from_bits(val)
            }
        }
        impl From<State> for u8 {
            #[inline(always)]
            fn from(val: State) -> u8 {
                State::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Switchingstate {
            #[doc = "Switching state Idle"]
            IDLE = 0x0,
            #[doc = "Switching state Offset"]
            OFFSET = 0x01,
            #[doc = "Switching state Guard"]
            GUARD = 0x02,
            #[doc = "Switching state Ref"]
            REF = 0x03,
            #[doc = "Switching state Switching"]
            SWITCHING = 0x04,
            #[doc = "Switching state Ending"]
            ENDING = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Switchingstate {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Switchingstate {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Switchingstate {
            #[inline(always)]
            fn from(val: u8) -> Switchingstate {
                Switchingstate::from_bits(val)
            }
        }
        impl From<Switchingstate> for u8 {
            #[inline(always)]
            fn from(val: Switchingstate) -> u8 {
                Switchingstate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsamplespacing {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tsamplespacing {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsamplespacing {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsamplespacing {
            #[inline(always)]
            fn from(val: u8) -> Tsamplespacing {
                Tsamplespacing::from_bits(val)
            }
        }
        impl From<Tsamplespacing> for u8 {
            #[inline(always)]
            fn from(val: Tsamplespacing) -> u8 {
                Tsamplespacing::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tsamplespacingref {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            #[doc = "0.5us"]
            _500NS = 0x04,
            #[doc = "0.25us"]
            _250NS = 0x05,
            #[doc = "0.125us"]
            _125NS = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tsamplespacingref {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tsamplespacingref {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tsamplespacingref {
            #[inline(always)]
            fn from(val: u8) -> Tsamplespacingref {
                Tsamplespacingref::from_bits(val)
            }
        }
        impl From<Tsamplespacingref> for u8 {
            #[inline(always)]
            fn from(val: Tsamplespacingref) -> u8 {
                Tsamplespacingref::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tswitchspacing {
            _RESERVED_0 = 0x0,
            #[doc = "4us"]
            _4US = 0x01,
            #[doc = "2us"]
            _2US = 0x02,
            #[doc = "1us"]
            _1US = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Tswitchspacing {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tswitchspacing {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tswitchspacing {
            #[inline(always)]
            fn from(val: u8) -> Tswitchspacing {
                Tswitchspacing::from_bits(val)
            }
        }
        impl From<Tswitchspacing> for u8 {
            #[inline(always)]
            fn from(val: Tswitchspacing) -> u8 {
                Tswitchspacing::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Txpower(pub u16);
        impl Txpower {
            #[doc = "-28 dBm"]
            pub const NEG28_DBM: Self = Self(0x01);
            #[doc = "-20 dBm"]
            pub const NEG20_DBM: Self = Self(0x02);
            #[doc = "-22 dBm"]
            pub const NEG22_DBM: Self = Self(0x02);
            #[doc = "-18 dBm"]
            pub const NEG18_DBM: Self = Self(0x03);
            #[doc = "-16 dBm"]
            pub const NEG16_DBM: Self = Self(0x04);
            #[doc = "-14 dBm"]
            pub const NEG14_DBM: Self = Self(0x05);
            #[doc = "-12 dBm"]
            pub const NEG12_DBM: Self = Self(0x06);
            #[doc = "-10 dBm"]
            pub const NEG10_DBM: Self = Self(0x07);
            #[doc = "-9 dBm"]
            pub const NEG9_DBM: Self = Self(0x08);
            #[doc = "-8 dBm"]
            pub const NEG8_DBM: Self = Self(0x09);
            #[doc = "-7 dBm"]
            pub const NEG7_DBM: Self = Self(0x0a);
            #[doc = "-6 dBm"]
            pub const NEG6_DBM: Self = Self(0x0b);
            #[doc = "-5 dBm"]
            pub const NEG5_DBM: Self = Self(0x0d);
            #[doc = "-4 dBm"]
            pub const NEG4_DBM: Self = Self(0x0f);
            #[doc = "-3 dBm"]
            pub const NEG3_DBM: Self = Self(0x11);
            #[doc = "-2 dBm"]
            pub const NEG2_DBM: Self = Self(0x13);
            #[doc = "-1 dBm"]
            pub const NEG1_DBM: Self = Self(0x15);
            #[doc = "0 dBm"]
            pub const _0_DBM: Self = Self(0x18);
            #[doc = "+1 dBm"]
            pub const POS1_DBM: Self = Self(0x1b);
            #[doc = "+2 dBm"]
            pub const POS2_DBM: Self = Self(0x1f);
            #[doc = "+3 dBm"]
            pub const POS3_DBM: Self = Self(0x23);
            #[doc = "+4 dBm"]
            pub const POS4_DBM: Self = Self(0x28);
            #[doc = "+5 dBm"]
            pub const POS5_DBM: Self = Self(0x2d);
            #[doc = "+6 dBm"]
            pub const POS6_DBM: Self = Self(0x33);
            #[doc = "+7 dBm"]
            pub const POS7_DBM: Self = Self(0x39);
            #[doc = "+8 dBm"]
            pub const POS8_DBM: Self = Self(0x3f);
            #[doc = "-46 dBm"]
            pub const NEG46_DBM: Self = Self(0x0110);
            #[doc = "-40 dBm"]
            pub const NEG40_DBM: Self = Self(0x0130);
        }
        impl Txpower {
            pub const fn from_bits(val: u16) -> Txpower {
                Self(val & 0x07ff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for Txpower {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x01 => f.write_str("NEG28_DBM"),
                    0x02 => f.write_str("NEG20_DBM"),
                    0x02 => f.write_str("NEG22_DBM"),
                    0x03 => f.write_str("NEG18_DBM"),
                    0x04 => f.write_str("NEG16_DBM"),
                    0x05 => f.write_str("NEG14_DBM"),
                    0x06 => f.write_str("NEG12_DBM"),
                    0x07 => f.write_str("NEG10_DBM"),
                    0x08 => f.write_str("NEG9_DBM"),
                    0x09 => f.write_str("NEG8_DBM"),
                    0x0a => f.write_str("NEG7_DBM"),
                    0x0b => f.write_str("NEG6_DBM"),
                    0x0d => f.write_str("NEG5_DBM"),
                    0x0f => f.write_str("NEG4_DBM"),
                    0x11 => f.write_str("NEG3_DBM"),
                    0x13 => f.write_str("NEG2_DBM"),
                    0x15 => f.write_str("NEG1_DBM"),
                    0x18 => f.write_str("_0_DBM"),
                    0x1b => f.write_str("POS1_DBM"),
                    0x1f => f.write_str("POS2_DBM"),
                    0x23 => f.write_str("POS3_DBM"),
                    0x28 => f.write_str("POS4_DBM"),
                    0x2d => f.write_str("POS5_DBM"),
                    0x33 => f.write_str("POS6_DBM"),
                    0x39 => f.write_str("POS7_DBM"),
                    0x3f => f.write_str("POS8_DBM"),
                    0x0110 => f.write_str("NEG46_DBM"),
                    0x0130 => f.write_str("NEG40_DBM"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Txpower {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x01 => defmt::write!(f, "NEG28_DBM"),
                    0x02 => defmt::write!(f, "NEG20_DBM"),
                    0x02 => defmt::write!(f, "NEG22_DBM"),
                    0x03 => defmt::write!(f, "NEG18_DBM"),
                    0x04 => defmt::write!(f, "NEG16_DBM"),
                    0x05 => defmt::write!(f, "NEG14_DBM"),
                    0x06 => defmt::write!(f, "NEG12_DBM"),
                    0x07 => defmt::write!(f, "NEG10_DBM"),
                    0x08 => defmt::write!(f, "NEG9_DBM"),
                    0x09 => defmt::write!(f, "NEG8_DBM"),
                    0x0a => defmt::write!(f, "NEG7_DBM"),
                    0x0b => defmt::write!(f, "NEG6_DBM"),
                    0x0d => defmt::write!(f, "NEG5_DBM"),
                    0x0f => defmt::write!(f, "NEG4_DBM"),
                    0x11 => defmt::write!(f, "NEG3_DBM"),
                    0x13 => defmt::write!(f, "NEG2_DBM"),
                    0x15 => defmt::write!(f, "NEG1_DBM"),
                    0x18 => defmt::write!(f, "_0_DBM"),
                    0x1b => defmt::write!(f, "POS1_DBM"),
                    0x1f => defmt::write!(f, "POS2_DBM"),
                    0x23 => defmt::write!(f, "POS3_DBM"),
                    0x28 => defmt::write!(f, "POS4_DBM"),
                    0x2d => defmt::write!(f, "POS5_DBM"),
                    0x33 => defmt::write!(f, "POS6_DBM"),
                    0x39 => defmt::write!(f, "POS7_DBM"),
                    0x3f => defmt::write!(f, "POS8_DBM"),
                    0x0110 => defmt::write!(f, "NEG46_DBM"),
                    0x0130 => defmt::write!(f, "NEG40_DBM"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for Txpower {
            #[inline(always)]
            fn from(val: u16) -> Txpower {
                Txpower::from_bits(val)
            }
        }
        impl From<Txpower> for u16 {
            #[inline(always)]
            fn from(val: Txpower) -> u16 {
                Txpower::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Whiteoffset {
            #[doc = "S0 included in whitening"]
            INCLUDE = 0x0,
            #[doc = "S0 excluded from whitening"]
            EXCLUDE = 0x01,
        }
        impl Whiteoffset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Whiteoffset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Whiteoffset {
            #[inline(always)]
            fn from(val: u8) -> Whiteoffset {
                Whiteoffset::from_bits(val)
            }
        }
        impl From<Whiteoffset> for u8 {
            #[inline(always)]
            fn from(val: Whiteoffset) -> u8 {
                Whiteoffset::to_bits(val)
            }
        }
    }
}
pub mod regulators {
    #[doc = "Voltage regulators 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Regulators {
        ptr: *mut u8,
    }
    unsafe impl Send for Regulators {}
    unsafe impl Sync for Regulators {}
    impl Regulators {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Register interface for the medium voltage regulator"]
        #[inline(always)]
        pub const fn vregm(self) -> Vregm {
            unsafe { Vregm::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "System OFF register"]
        #[inline(always)]
        pub const fn systemoff(self) -> crate::common::Reg<regs::Systemoff, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Power-fail comparator configuration"]
        #[inline(always)]
        pub const fn pofcon(self) -> crate::common::Reg<regs::Pofcon, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0530usize) as _) }
        }
        #[doc = "Power-fail comparator status register"]
        #[inline(always)]
        pub const fn pofstat(self) -> crate::common::Reg<regs::Pofstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0534usize) as _) }
        }
        #[doc = "Register interface for main voltage regulator."]
        #[inline(always)]
        pub const fn vregmain(self) -> Vregmain {
            unsafe { Vregmain::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
    }
    #[doc = "Register interface for the medium voltage regulator"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vregm {
        ptr: *mut u8,
    }
    unsafe impl Send for Vregm {}
    unsafe impl Sync for Vregm {}
    impl Vregm {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable register for VREGM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Register interface for main voltage regulator."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vregmain {
        ptr: *mut u8,
    }
    unsafe impl Send for Vregmain {}
    unsafe impl Sync for Vregmain {}
    impl Vregmain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Enable DC/DC converter for better power efficiency"]
        #[inline(always)]
        pub const fn dcdcen(self) -> crate::common::Reg<regs::Dcdcen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "VREGMAIN inductor detection"]
        #[inline(always)]
        pub const fn inductordet(self) -> crate::common::Reg<regs::Inductordet, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Enable DC/DC converter for better power efficiency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcdcen(pub u32);
        impl Dcdcen {
            #[doc = "Enable DC/DC buck converter"]
            #[inline(always)]
            pub const fn val(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable DC/DC buck converter"]
            #[inline(always)]
            pub fn set_val(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dcdcen {
            #[inline(always)]
            fn default() -> Dcdcen {
                Dcdcen(0)
            }
        }
        impl core::fmt::Debug for Dcdcen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcdcen").field("val", &self.val()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcdcen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dcdcen {
                    val: bool,
                }
                let proxy = Dcdcen { val: self.val() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable register for VREGM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable the regulator"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable the regulator"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "VREGMAIN inductor detection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Inductordet(pub u32);
        impl Inductordet {
            #[inline(always)]
            pub const fn detected(&self) -> super::vals::Detected {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Detected::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_detected(&mut self, val: super::vals::Detected) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Inductordet {
            #[inline(always)]
            fn default() -> Inductordet {
                Inductordet(0)
            }
        }
        impl core::fmt::Debug for Inductordet {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Inductordet")
                    .field("detected", &self.detected())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Inductordet {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Inductordet {
                    detected: super::vals::Detected,
                }
                let proxy = Inductordet {
                    detected: self.detected(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Power-fail comparator configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pofcon(pub u32);
        impl Pofcon {
            #[doc = "Enable or disable power-fail comparator"]
            #[inline(always)]
            pub const fn pof(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable power-fail comparator"]
            #[inline(always)]
            pub fn set_pof(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Power-fail comparator threshold setting"]
            #[inline(always)]
            pub const fn threshold(&self) -> super::vals::Threshold {
                let val = (self.0 >> 1usize) & 0x0f;
                super::vals::Threshold::from_bits(val as u8)
            }
            #[doc = "Power-fail comparator threshold setting"]
            #[inline(always)]
            pub fn set_threshold(&mut self, val: super::vals::Threshold) {
                self.0 = (self.0 & !(0x0f << 1usize)) | (((val.to_bits() as u32) & 0x0f) << 1usize);
            }
            #[doc = "Disable the POFWARN power-fail warning event"]
            #[inline(always)]
            pub const fn eventdisable(&self) -> super::vals::Eventdisable {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Eventdisable::from_bits(val as u8)
            }
            #[doc = "Disable the POFWARN power-fail warning event"]
            #[inline(always)]
            pub fn set_eventdisable(&mut self, val: super::vals::Eventdisable) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Pofcon {
            #[inline(always)]
            fn default() -> Pofcon {
                Pofcon(0)
            }
        }
        impl core::fmt::Debug for Pofcon {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pofcon")
                    .field("pof", &self.pof())
                    .field("threshold", &self.threshold())
                    .field("eventdisable", &self.eventdisable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pofcon {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pofcon {
                    pof: bool,
                    threshold: super::vals::Threshold,
                    eventdisable: super::vals::Eventdisable,
                }
                let proxy = Pofcon {
                    pof: self.pof(),
                    threshold: self.threshold(),
                    eventdisable: self.eventdisable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Power-fail comparator status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pofstat(pub u32);
        impl Pofstat {
            #[doc = "Power-fail comparator status"]
            #[inline(always)]
            pub const fn comparator(&self) -> super::vals::Comparator {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Comparator::from_bits(val as u8)
            }
            #[doc = "Power-fail comparator status"]
            #[inline(always)]
            pub fn set_comparator(&mut self, val: super::vals::Comparator) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Pofstat {
            #[inline(always)]
            fn default() -> Pofstat {
                Pofstat(0)
            }
        }
        impl core::fmt::Debug for Pofstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pofstat")
                    .field("comparator", &self.comparator())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pofstat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pofstat {
                    comparator: super::vals::Comparator,
                }
                let proxy = Pofstat {
                    comparator: self.comparator(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "System OFF register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Systemoff(pub u32);
        impl Systemoff {
            #[doc = "Enable System OFF mode"]
            #[inline(always)]
            pub const fn systemoff(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable System OFF mode"]
            #[inline(always)]
            pub fn set_systemoff(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Systemoff {
            #[inline(always)]
            fn default() -> Systemoff {
                Systemoff(0)
            }
        }
        impl core::fmt::Debug for Systemoff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Systemoff")
                    .field("systemoff", &self.systemoff())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Systemoff {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Systemoff {
                    systemoff: bool,
                }
                let proxy = Systemoff {
                    systemoff: self.systemoff(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Comparator {
            #[doc = "Voltage detected above VPOF threshold"]
            ABOVE = 0x0,
            #[doc = "Voltage detected below VPOF threshold"]
            BELOW = 0x01,
        }
        impl Comparator {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Comparator {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Comparator {
            #[inline(always)]
            fn from(val: u8) -> Comparator {
                Comparator::from_bits(val)
            }
        }
        impl From<Comparator> for u8 {
            #[inline(always)]
            fn from(val: Comparator) -> u8 {
                Comparator::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Detected {
            #[doc = "VREGMAIN inductor not detected"]
            INDUCTOR_NOT_DETECTED = 0x0,
            #[doc = "VREGMAIN inductor detected"]
            INDUCTOR_DETECTED = 0x01,
        }
        impl Detected {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Detected {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Detected {
            #[inline(always)]
            fn from(val: u8) -> Detected {
                Detected::from_bits(val)
            }
        }
        impl From<Detected> for u8 {
            #[inline(always)]
            fn from(val: Detected) -> u8 {
                Detected::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Eventdisable {
            #[doc = "POFWARN event is generated"]
            ENABLED = 0x0,
            #[doc = "POFWARN event is not generated"]
            DISABLED = 0x01,
        }
        impl Eventdisable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Eventdisable {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Eventdisable {
            #[inline(always)]
            fn from(val: u8) -> Eventdisable {
                Eventdisable::from_bits(val)
            }
        }
        impl From<Eventdisable> for u8 {
            #[inline(always)]
            fn from(val: Eventdisable) -> u8 {
                Eventdisable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Threshold {
            #[doc = "Set threshold to 1.7 V"]
            V17 = 0x0,
            #[doc = "Set threshold to 1.8 V"]
            V18 = 0x01,
            #[doc = "Set threshold to 1.9 V"]
            V19 = 0x02,
            #[doc = "Set threshold to 2.0 V"]
            V20 = 0x03,
            #[doc = "Set threshold to 2.1 V"]
            V21 = 0x04,
            #[doc = "Set threshold to 2.2 V"]
            V22 = 0x05,
            #[doc = "Set threshold to 2.3 V"]
            V23 = 0x06,
            #[doc = "Set threshold to 2.4 V"]
            V24 = 0x07,
            #[doc = "Set threshold to 2.5 V"]
            V25 = 0x08,
            #[doc = "Set threshold to 2.6 V"]
            V26 = 0x09,
            #[doc = "Set threshold to 2.7 V"]
            V27 = 0x0a,
            #[doc = "Set threshold to 2.8 V"]
            V28 = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Threshold {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Threshold {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Threshold {
            #[inline(always)]
            fn from(val: u8) -> Threshold {
                Threshold::from_bits(val)
            }
        }
        impl From<Threshold> for u8 {
            #[inline(always)]
            fn from(val: Threshold) -> u8 {
                Threshold::to_bits(val)
            }
        }
    }
}
pub mod reset {
    #[doc = "Reset control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Reset {
        ptr: *mut u8,
    }
    unsafe impl Send for Reset {}
    unsafe impl Sync for Reset {}
    impl Reset {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Reset reason"]
        #[inline(always)]
        pub const fn resetreas(self) -> crate::common::Reg<regs::Resetreas, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Reset reason"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resetreas(pub u32);
        impl Resetreas {
            #[doc = "Reset from pin reset detected"]
            #[inline(always)]
            pub const fn resetpin(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from pin reset detected"]
            #[inline(always)]
            pub fn set_resetpin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset from watchdog timer 0 detected"]
            #[inline(always)]
            pub const fn dog0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from watchdog timer 0 detected"]
            #[inline(always)]
            pub fn set_dog0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Reset from watchdog timer 1 detected"]
            #[inline(always)]
            pub const fn dog1(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from watchdog timer 1 detected"]
            #[inline(always)]
            pub fn set_dog1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Soft reset from CTRL-AP detected"]
            #[inline(always)]
            pub const fn ctrlapsoft(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Soft reset from CTRL-AP detected"]
            #[inline(always)]
            pub fn set_ctrlapsoft(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Reset due to CTRL-AP hard reset"]
            #[inline(always)]
            pub const fn ctrlaphard(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to CTRL-AP hard reset"]
            #[inline(always)]
            pub fn set_ctrlaphard(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Reset due to CTRL-AP pin reset"]
            #[inline(always)]
            pub const fn ctrlappin(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to CTRL-AP pin reset"]
            #[inline(always)]
            pub fn set_ctrlappin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Reset from soft reset detected"]
            #[inline(always)]
            pub const fn sreq(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from soft reset detected"]
            #[inline(always)]
            pub fn set_sreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Reset from CPU lockup detected"]
            #[inline(always)]
            pub const fn lockup(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Reset from CPU lockup detected"]
            #[inline(always)]
            pub fn set_lockup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO"]
            #[inline(always)]
            pub const fn off(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by DETECT signal from GPIO"]
            #[inline(always)]
            pub fn set_off(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP"]
            #[inline(always)]
            pub const fn lpcomp(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from System OFF mode when wakeup is triggered by ANADETECT signal from LPCOMP"]
            #[inline(always)]
            pub fn set_lpcomp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Reset triggered by Debug Interface"]
            #[inline(always)]
            pub const fn dif(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Reset triggered by Debug Interface"]
            #[inline(always)]
            pub fn set_dif(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Reset due to wakeup from GRTC"]
            #[inline(always)]
            pub const fn grtc(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to wakeup from GRTC"]
            #[inline(always)]
            pub fn set_grtc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Reset after wakeup from System OFF mode due to NFC field being detected"]
            #[inline(always)]
            pub const fn nfc(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Reset after wakeup from System OFF mode due to NFC field being detected"]
            #[inline(always)]
            pub fn set_nfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Reset due to illegal tampering of the device"]
            #[inline(always)]
            pub const fn sectamper(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Reset due to illegal tampering of the device"]
            #[inline(always)]
            pub fn set_sectamper(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Resetreas {
            #[inline(always)]
            fn default() -> Resetreas {
                Resetreas(0)
            }
        }
        impl core::fmt::Debug for Resetreas {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resetreas")
                    .field("resetpin", &self.resetpin())
                    .field("dog0", &self.dog0())
                    .field("dog1", &self.dog1())
                    .field("ctrlapsoft", &self.ctrlapsoft())
                    .field("ctrlaphard", &self.ctrlaphard())
                    .field("ctrlappin", &self.ctrlappin())
                    .field("sreq", &self.sreq())
                    .field("lockup", &self.lockup())
                    .field("off", &self.off())
                    .field("lpcomp", &self.lpcomp())
                    .field("dif", &self.dif())
                    .field("grtc", &self.grtc())
                    .field("nfc", &self.nfc())
                    .field("sectamper", &self.sectamper())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resetreas {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Resetreas {
                    resetpin: bool,
                    dog0: bool,
                    dog1: bool,
                    ctrlapsoft: bool,
                    ctrlaphard: bool,
                    ctrlappin: bool,
                    sreq: bool,
                    lockup: bool,
                    off: bool,
                    lpcomp: bool,
                    dif: bool,
                    grtc: bool,
                    nfc: bool,
                    sectamper: bool,
                }
                let proxy = Resetreas {
                    resetpin: self.resetpin(),
                    dog0: self.dog0(),
                    dog1: self.dog1(),
                    ctrlapsoft: self.ctrlapsoft(),
                    ctrlaphard: self.ctrlaphard(),
                    ctrlappin: self.ctrlappin(),
                    sreq: self.sreq(),
                    lockup: self.lockup(),
                    off: self.off(),
                    lpcomp: self.lpcomp(),
                    dif: self.dif(),
                    grtc: self.grtc(),
                    nfc: self.nfc(),
                    sectamper: self.sectamper(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod rramc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Bufstatus {
        ptr: *mut u8,
    }
    unsafe impl Send for Bufstatus {}
    unsafe impl Sync for Bufstatus {}
    impl Bufstatus {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Internal write-buffer is empty"]
        #[inline(always)]
        pub const fn writebufempty(
            self,
        ) -> crate::common::Reg<regs::Writebufempty, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ecc {
        ptr: *mut u8,
    }
    unsafe impl Send for Ecc {}
    unsafe impl Sync for Ecc {}
    impl Ecc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Address of the first ECC error that could not be corrected"]
        #[inline(always)]
        pub const fn erroraddr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Erase {
        ptr: *mut u8,
    }
    unsafe impl Send for Erase {}
    unsafe impl Sync for Erase {}
    impl Erase {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Register for erasing whole RRAM main block, that includes the SICR and the UICR"]
        #[inline(always)]
        pub const fn eraseall(self) -> crate::common::Reg<regs::Eraseall, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Power {
        ptr: *mut u8,
    }
    unsafe impl Send for Power {}
    unsafe impl Sync for Power {}
    impl Power {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Power configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::PowerConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Low power mode configuration"]
        #[inline(always)]
        pub const fn lowpowerconfig(
            self,
        ) -> crate::common::Reg<regs::Lowpowerconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Region {
        ptr: *mut u8,
    }
    unsafe impl Send for Region {}
    unsafe impl Sync for Region {}
    impl Region {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Region address"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Region configuration"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RegionConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "RRAM controller GLITCH detector"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rramc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rramc {}
    unsafe impl Sync for Rramc {}
    impl Rramc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Wakeup the RRAM from low power mode"]
        #[inline(always)]
        pub const fn tasks_wakeup(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Commits the data stored in internal write-buffer to RRAM"]
        #[inline(always)]
        pub const fn tasks_commitwritebuf(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Subscribe configuration for task WAKEUP"]
        #[inline(always)]
        pub const fn subscribe_wakeup(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task COMMITWRITEBUF"]
        #[inline(always)]
        pub const fn subscribe_commitwritebuf(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "RRAMC is woken up from low power mode"]
        #[inline(always)]
        pub const fn events_wokenup(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "RRAMC is ready"]
        #[inline(always)]
        pub const fn events_ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Ready to accept a new write operation"]
        #[inline(always)]
        pub const fn events_readynext(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "RRAM access error"]
        #[inline(always)]
        pub const fn events_accesserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Uncorrectable ECC error detected"]
        #[inline(always)]
        pub const fn events_eccerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Publish configuration for event WOKENUP"]
        #[inline(always)]
        pub const fn publish_wokenup(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "RRAMC ready status"]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<regs::Ready, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Ready next flag"]
        #[inline(always)]
        pub const fn readynext(self) -> crate::common::Reg<regs::Readynext, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Address of the first access error"]
        #[inline(always)]
        pub const fn accesserroraddr(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0408usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn bufstatus(self) -> Bufstatus {
            unsafe { Bufstatus::from_ptr(self.ptr.add(0x0410usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ecc(self) -> Ecc {
            unsafe { Ecc::from_ptr(self.ptr.add(0x0420usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::RramcConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Configuration for ready next timeout counter, in units of AXI clock frequency"]
        #[inline(always)]
        pub const fn readynexttimeout(
            self,
        ) -> crate::common::Reg<regs::Readynexttimeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn power(self) -> Power {
            unsafe { Power::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn erase(self) -> Erase {
            unsafe { Erase::from_ptr(self.ptr.add(0x0540usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn region(self, n: usize) -> Region {
            assert!(n < 5usize);
            unsafe { Region::from_ptr(self.ptr.add(0x0550usize + n * 8usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Register for erasing whole RRAM main block, that includes the SICR and the UICR"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Eraseall(pub u32);
        impl Eraseall {
            #[doc = "Erase whole RRAM main block"]
            #[inline(always)]
            pub const fn erase(&self) -> super::vals::Erase {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Erase::from_bits(val as u8)
            }
            #[doc = "Erase whole RRAM main block"]
            #[inline(always)]
            pub fn set_erase(&mut self, val: super::vals::Erase) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Eraseall {
            #[inline(always)]
            fn default() -> Eraseall {
                Eraseall(0)
            }
        }
        impl core::fmt::Debug for Eraseall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Eraseall")
                    .field("erase", &self.erase())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Eraseall {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Eraseall {
                    erase: super::vals::Erase,
                }
                let proxy = Eraseall {
                    erase: self.erase(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event WOKENUP"]
            #[inline(always)]
            pub const fn wokenup(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WOKENUP"]
            #[inline(always)]
            pub fn set_wokenup(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READY"]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event READYNEXT"]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READYNEXT"]
            #[inline(always)]
            pub fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event ACCESSERROR"]
            #[inline(always)]
            pub const fn accesserror(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ACCESSERROR"]
            #[inline(always)]
            pub fn set_accesserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event ECCERROR"]
            #[inline(always)]
            pub const fn eccerror(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ECCERROR"]
            #[inline(always)]
            pub fn set_eccerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("wokenup", &self.wokenup())
                    .field("ready", &self.ready())
                    .field("readynext", &self.readynext())
                    .field("accesserror", &self.accesserror())
                    .field("eccerror", &self.eccerror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    wokenup: bool,
                    ready: bool,
                    readynext: bool,
                    accesserror: bool,
                    eccerror: bool,
                }
                let proxy = Int {
                    wokenup: self.wokenup(),
                    ready: self.ready(),
                    readynext: self.readynext(),
                    accesserror: self.accesserror(),
                    eccerror: self.eccerror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Low power mode configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lowpowerconfig(pub u32);
        impl Lowpowerconfig {
            #[doc = "RRAM low power mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "RRAM low power mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Lowpowerconfig {
            #[inline(always)]
            fn default() -> Lowpowerconfig {
                Lowpowerconfig(0)
            }
        }
        impl core::fmt::Debug for Lowpowerconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lowpowerconfig")
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lowpowerconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lowpowerconfig {
                    mode: super::vals::Mode,
                }
                let proxy = Lowpowerconfig { mode: self.mode() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Power configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PowerConfig(pub u32);
        impl PowerConfig {
            #[doc = "Access timeout, in 31.25 ns units, used for going into standby power mode or remain active on wake up"]
            #[inline(always)]
            pub const fn accesstimeout(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Access timeout, in 31.25 ns units, used for going into standby power mode or remain active on wake up"]
            #[inline(always)]
            pub fn set_accesstimeout(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "Power on failure warning handling configuration"]
            #[inline(always)]
            pub const fn pof(&self) -> super::vals::Pof {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Pof::from_bits(val as u8)
            }
            #[doc = "Power on failure warning handling configuration"]
            #[inline(always)]
            pub fn set_pof(&mut self, val: super::vals::Pof) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
        }
        impl Default for PowerConfig {
            #[inline(always)]
            fn default() -> PowerConfig {
                PowerConfig(0)
            }
        }
        impl core::fmt::Debug for PowerConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PowerConfig")
                    .field("accesstimeout", &self.accesstimeout())
                    .field("pof", &self.pof())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PowerConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PowerConfig {
                    accesstimeout: u16,
                    pof: super::vals::Pof,
                }
                let proxy = PowerConfig {
                    accesstimeout: self.accesstimeout(),
                    pof: self.pof(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "RRAMC ready status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ready(pub u32);
        impl Ready {
            #[doc = "RRAMC is ready or busy"]
            #[inline(always)]
            pub const fn ready(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RRAMC is ready or busy"]
            #[inline(always)]
            pub fn set_ready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Ready {
            #[inline(always)]
            fn default() -> Ready {
                Ready(0)
            }
        }
        impl core::fmt::Debug for Ready {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ready")
                    .field("ready", &self.ready())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ready {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ready {
                    ready: bool,
                }
                let proxy = Ready {
                    ready: self.ready(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Ready next flag"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynext(pub u32);
        impl Readynext {
            #[doc = "RRAMC can accept a new write operation"]
            #[inline(always)]
            pub const fn readynext(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RRAMC can accept a new write operation"]
            #[inline(always)]
            pub fn set_readynext(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Readynext {
            #[inline(always)]
            fn default() -> Readynext {
                Readynext(0)
            }
        }
        impl core::fmt::Debug for Readynext {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynext")
                    .field("readynext", &self.readynext())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynext {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Readynext {
                    readynext: bool,
                }
                let proxy = Readynext {
                    readynext: self.readynext(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration for ready next timeout counter, in units of AXI clock frequency"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Readynexttimeout(pub u32);
        impl Readynexttimeout {
            #[doc = "Preload value for waiting for a next write"]
            #[inline(always)]
            pub const fn value(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Preload value for waiting for a next write"]
            #[inline(always)]
            pub fn set_value(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Enable ready next timeout"]
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Enable ready next timeout"]
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Readynexttimeout {
            #[inline(always)]
            fn default() -> Readynexttimeout {
                Readynexttimeout(0)
            }
        }
        impl core::fmt::Debug for Readynexttimeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Readynexttimeout")
                    .field("value", &self.value())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Readynexttimeout {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Readynexttimeout {
                    value: u16,
                    en: bool,
                }
                let proxy = Readynexttimeout {
                    value: self.value(),
                    en: self.en(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Region configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RegionConfig(pub u32);
        impl RegionConfig {
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Owner ID"]
            #[inline(always)]
            pub const fn owner(&self) -> super::vals::Owner {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Owner::from_bits(val as u8)
            }
            #[doc = "Owner ID"]
            #[inline(always)]
            pub fn set_owner(&mut self, val: super::vals::Owner) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub const fn writeonce(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub fn set_writeonce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable lock"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Size in KBytes of region \\[n\\]"]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Size in KBytes of region \\[n\\]"]
            #[inline(always)]
            pub fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
        }
        impl Default for RegionConfig {
            #[inline(always)]
            fn default() -> RegionConfig {
                RegionConfig(0)
            }
        }
        impl core::fmt::Debug for RegionConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RegionConfig")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("owner", &self.owner())
                    .field("writeonce", &self.writeonce())
                    .field("lock", &self.lock())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RegionConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RegionConfig {
                    read: bool,
                    write: bool,
                    execute: bool,
                    secure: bool,
                    owner: super::vals::Owner,
                    writeonce: bool,
                    lock: bool,
                    size: u8,
                }
                let proxy = RegionConfig {
                    read: self.read(),
                    write: self.write(),
                    execute: self.execute(),
                    secure: self.secure(),
                    owner: self.owner(),
                    writeonce: self.writeonce(),
                    lock: self.lock(),
                    size: self.size(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RramcConfig(pub u32);
        impl RramcConfig {
            #[doc = "Write enable"]
            #[inline(always)]
            pub const fn wen(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write enable"]
            #[inline(always)]
            pub fn set_wen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "write-buffer size in number of 128-bit words"]
            #[inline(always)]
            pub const fn writebufsize(&self) -> super::vals::Writebufsize {
                let val = (self.0 >> 8usize) & 0x3f;
                super::vals::Writebufsize::from_bits(val as u8)
            }
            #[doc = "write-buffer size in number of 128-bit words"]
            #[inline(always)]
            pub fn set_writebufsize(&mut self, val: super::vals::Writebufsize) {
                self.0 = (self.0 & !(0x3f << 8usize)) | (((val.to_bits() as u32) & 0x3f) << 8usize);
            }
        }
        impl Default for RramcConfig {
            #[inline(always)]
            fn default() -> RramcConfig {
                RramcConfig(0)
            }
        }
        impl core::fmt::Debug for RramcConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RramcConfig")
                    .field("wen", &self.wen())
                    .field("writebufsize", &self.writebufsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RramcConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RramcConfig {
                    wen: bool,
                    writebufsize: super::vals::Writebufsize,
                }
                let proxy = RramcConfig {
                    wen: self.wen(),
                    writebufsize: self.writebufsize(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Internal write-buffer is empty"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Writebufempty(pub u32);
        impl Writebufempty {
            #[inline(always)]
            pub const fn empty(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_empty(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Writebufempty {
            #[inline(always)]
            fn default() -> Writebufempty {
                Writebufempty(0)
            }
        }
        impl core::fmt::Debug for Writebufempty {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Writebufempty")
                    .field("empty", &self.empty())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writebufempty {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Writebufempty {
                    empty: bool,
                }
                let proxy = Writebufempty {
                    empty: self.empty(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Erase {
            #[doc = "No operation"]
            NO_OPERATION = 0x0,
            #[doc = "Start erase of chip"]
            ERASE = 0x01,
        }
        impl Erase {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Erase {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Erase {
            #[inline(always)]
            fn from(val: u8) -> Erase {
                Erase::from_bits(val)
            }
        }
        impl From<Erase> for u8 {
            #[inline(always)]
            fn from(val: Erase) -> u8 {
                Erase::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "The RRAM goes into power down mode"]
            POWER_DOWN = 0x0,
            #[doc = "The RRAM automatically goes into standby mode while the RRAM is not being accessed"]
            STANDBY = 0x01,
            #[doc = "The RRAM goes into NAP mode"]
            NAP = 0x02,
            #[doc = "The RRAM is powered Off"]
            POWER_OFF = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Owner {
            #[doc = "Owner ID protection is not enforced"]
            NOT_ENFORCED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Owner {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Owner {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Owner {
            #[inline(always)]
            fn from(val: u8) -> Owner {
                Owner::from_bits(val)
            }
        }
        impl From<Owner> for u8 {
            #[inline(always)]
            fn from(val: Owner) -> u8 {
                Owner::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Pof {
            #[doc = "Wait until the current RRAM write finishes"]
            WAIT = 0x0,
            #[doc = "Abort the current RRAM write"]
            ABORT = 0x01,
        }
        impl Pof {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Pof {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Pof {
            #[inline(always)]
            fn from(val: u8) -> Pof {
                Pof::from_bits(val)
            }
        }
        impl From<Pof> for u8 {
            #[inline(always)]
            fn from(val: Pof) -> u8 {
                Pof::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Writebufsize(pub u8);
        impl Writebufsize {
            #[doc = "Disable buffering"]
            pub const UNBUFFERED: Self = Self(0x0);
        }
        impl Writebufsize {
            pub const fn from_bits(val: u8) -> Writebufsize {
                Self(val & 0x3f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Writebufsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("UNBUFFERED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Writebufsize {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "UNBUFFERED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Writebufsize {
            #[inline(always)]
            fn from(val: u8) -> Writebufsize {
                Writebufsize::from_bits(val)
            }
        }
        impl From<Writebufsize> for u8 {
            #[inline(always)]
            fn from(val: Writebufsize) -> u8 {
                Writebufsize::to_bits(val)
            }
        }
    }
}
pub mod rtc {
    #[doc = "Real-time counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Rtc {}
    unsafe impl Sync for Rtc {}
    impl Rtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start RTC counter"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop RTC counter"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Clear RTC counter"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Set counter to 0xFFFFF0"]
        #[inline(always)]
        pub const fn tasks_trigovrflw(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Description collection: Capture RTC counter to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task TRIGOVRFLW"]
        #[inline(always)]
        pub const fn subscribe_trigovrflw(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 4usize) as _) }
        }
        #[doc = "Event on counter increment"]
        #[inline(always)]
        pub const fn events_tick(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Event on counter overflow"]
        #[inline(always)]
        pub const fn events_ovrflw(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Publish configuration for event TICK"]
        #[inline(always)]
        pub const fn publish_tick(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event OVRFLW"]
        #[inline(always)]
        pub const fn publish_ovrflw(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable or disable event routing"]
        #[inline(always)]
        pub const fn evten(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0340usize) as _) }
        }
        #[doc = "Enable event routing"]
        #[inline(always)]
        pub const fn evtenset(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0344usize) as _) }
        }
        #[doc = "Disable event routing"]
        #[inline(always)]
        pub const fn evtenclr(self) -> crate::common::Reg<regs::Evt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0348usize) as _) }
        }
        #[doc = "Current counter value"]
        #[inline(always)]
        pub const fn counter(self) -> crate::common::Reg<regs::Counter, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "12-bit prescaler for counter frequency (32768 / (PRESCALER + 1)). Must be written when RTC is stopped."]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Description collection: Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<regs::Cc, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: Compare register n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cc(pub u32);
        impl Cc {
            #[doc = "Compare value"]
            #[inline(always)]
            pub const fn compare(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Compare value"]
            #[inline(always)]
            pub fn set_compare(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Cc {
            #[inline(always)]
            fn default() -> Cc {
                Cc(0)
            }
        }
        impl core::fmt::Debug for Cc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cc")
                    .field("compare", &self.compare())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cc {
                    compare: u32,
                }
                let proxy = Cc {
                    compare: self.compare(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Current counter value"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Counter(pub u32);
        impl Counter {
            #[doc = "Counter value"]
            #[inline(always)]
            pub const fn counter(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "Counter value"]
            #[inline(always)]
            pub fn set_counter(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
        }
        impl Default for Counter {
            #[inline(always)]
            fn default() -> Counter {
                Counter(0)
            }
        }
        impl core::fmt::Debug for Counter {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Counter")
                    .field("counter", &self.counter())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Counter {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Counter {
                    counter: u32,
                }
                let proxy = Counter {
                    counter: self.counter(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable event routing"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Evt(pub u32);
        impl Evt {
            #[doc = "Enable or disable event routing for event TICK"]
            #[inline(always)]
            pub const fn tick(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event TICK"]
            #[inline(always)]
            pub fn set_tick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable event routing for event OVRFLW"]
            #[inline(always)]
            pub const fn ovrflw(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event OVRFLW"]
            #[inline(always)]
            pub fn set_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable event routing for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable event routing for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Evt {
            #[inline(always)]
            fn default() -> Evt {
                Evt(0)
            }
        }
        impl core::fmt::Debug for Evt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Evt")
                    .field("tick", &self.tick())
                    .field("ovrflw", &self.ovrflw())
                    .field(
                        "compare",
                        &[
                            self.compare(0usize),
                            self.compare(1usize),
                            self.compare(2usize),
                            self.compare(3usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Evt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Evt {
                    tick: bool,
                    ovrflw: bool,
                    compare: [bool; 4usize],
                }
                let proxy = Evt {
                    tick: self.tick(),
                    ovrflw: self.ovrflw(),
                    compare: [
                        self.compare(0usize),
                        self.compare(1usize),
                        self.compare(2usize),
                        self.compare(3usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TICK"]
            #[inline(always)]
            pub const fn tick(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TICK"]
            #[inline(always)]
            pub fn set_tick(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event OVRFLW"]
            #[inline(always)]
            pub const fn ovrflw(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event OVRFLW"]
            #[inline(always)]
            pub fn set_ovrflw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("tick", &self.tick())
                    .field("ovrflw", &self.ovrflw())
                    .field(
                        "compare",
                        &[
                            self.compare(0usize),
                            self.compare(1usize),
                            self.compare(2usize),
                            self.compare(3usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    tick: bool,
                    ovrflw: bool,
                    compare: [bool; 4usize],
                }
                let proxy = Int {
                    tick: self.tick(),
                    ovrflw: self.ovrflw(),
                    compare: [
                        self.compare(0usize),
                        self.compare(1usize),
                        self.compare(2usize),
                        self.compare(3usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "12-bit prescaler for counter frequency (32768 / (PRESCALER + 1)). Must be written when RTC is stopped."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn prescaler(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub fn set_prescaler(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Prescaler {
                    prescaler: u16,
                }
                let proxy = Prescaler {
                    prescaler: self.prescaler(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub const fn comparen_clear(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub fn set_comparen_clear(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field(
                        "comparen_clear",
                        &[
                            self.comparen_clear(0usize),
                            self.comparen_clear(1usize),
                            self.comparen_clear(2usize),
                            self.comparen_clear(3usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    comparen_clear: [bool; 4usize],
                }
                let proxy = Shorts {
                    comparen_clear: [
                        self.comparen_clear(0usize),
                        self.comparen_clear(1usize),
                        self.comparen_clear(2usize),
                        self.comparen_clear(3usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod saadc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ch {
        ptr: *mut u8,
    }
    unsafe impl Send for Ch {}
    unsafe impl Sync for Ch {}
    impl Ch {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pselp(self) -> crate::common::Reg<regs::Pselp, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[inline(always)]
        pub const fn pseln(self) -> crate::common::Reg<regs::Pseln, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[inline(always)]
        pub const fn limit(self) -> crate::common::Reg<regs::Limit, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsCh {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsCh {}
    unsafe impl Sync for EventsCh {}
    impl EventsCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Last results is equal or above CH\\[n\\].LIMIT.HIGH"]
        #[inline(always)]
        pub const fn limith(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Last results is equal or below CH\\[n\\].LIMIT.LOW"]
        #[inline(always)]
        pub const fn limitl(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishCh {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishCh {}
    unsafe impl Sync for PublishCh {}
    impl PublishCh {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITH"]
        #[inline(always)]
        pub const fn limith(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Publish configuration for event CH\\[n\\].LIMITL"]
        #[inline(always)]
        pub const fn limitl(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "RESULT EasyDMA channel"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Result {
        ptr: *mut u8,
    }
    unsafe impl Send for Result {}
    unsafe impl Sync for Result {}
    impl Result {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Data pointer"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of buffer bytes to transfer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::Maxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events"]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::Amount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Number of buffer bytes transferred since last START, continuously updated"]
        #[inline(always)]
        pub const fn currentamount(
            self,
        ) -> crate::common::Reg<regs::Currentamount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Analog to Digital Converter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Saadc {
        ptr: *mut u8,
    }
    unsafe impl Send for Saadc {}
    unsafe impl Sync for Saadc {}
    impl Saadc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start the ADC and prepare the result buffer in RAM"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Take one ADC sample, if scan is enabled all channels are sampled. This task requires that SAADC has started, i.e. EVENTS_STARTED was set and EVENTS_STOPPED was not."]
        #[inline(always)]
        pub const fn tasks_sample(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Stop the ADC and terminate any on-going conversion"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Starts offset auto-calibration"]
        #[inline(always)]
        pub const fn tasks_calibrateoffset(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task SAMPLE"]
        #[inline(always)]
        pub const fn subscribe_sample(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CALIBRATEOFFSET"]
        #[inline(always)]
        pub const fn subscribe_calibrateoffset(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "The ADC has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "The ADC has filled up the Result buffer"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "A conversion task has been completed. Depending on the mode, multiple conversions might be needed for a result to be transferred to RAM."]
        #[inline(always)]
        pub const fn events_done(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "A result is ready to get transferred to RAM."]
        #[inline(always)]
        pub const fn events_resultdone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Calibration is complete"]
        #[inline(always)]
        pub const fn events_calibratedone(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "The ADC has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_ch(self, n: usize) -> EventsCh {
            assert!(n < 8usize);
            unsafe { EventsCh::from_ptr(self.ptr.add(0x0118usize + n * 8usize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event DONE"]
        #[inline(always)]
        pub const fn publish_done(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for event RESULTDONE"]
        #[inline(always)]
        pub const fn publish_resultdone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event CALIBRATEDONE"]
        #[inline(always)]
        pub const fn publish_calibratedone(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_ch(self, n: usize) -> PublishCh {
            assert!(n < 8usize);
            unsafe { PublishCh::from_ptr(self.ptr.add(0x0198usize + n * 8usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Status"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn trim(self) -> Trim {
            unsafe { Trim::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Enable or disable ADC"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> Ch {
            assert!(n < 8usize);
            unsafe { Ch::from_ptr(self.ptr.add(0x0510usize + n * 16usize) as _) }
        }
        #[doc = "Resolution configuration"]
        #[inline(always)]
        pub const fn resolution(self) -> crate::common::Reg<regs::Resolution, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05f0usize) as _) }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[inline(always)]
        pub const fn oversample(self) -> crate::common::Reg<regs::Oversample, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05f4usize) as _) }
        }
        #[doc = "Controls normal or continuous sample rate"]
        #[inline(always)]
        pub const fn samplerate(self) -> crate::common::Reg<regs::Samplerate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05f8usize) as _) }
        }
        #[doc = "RESULT EasyDMA channel"]
        #[inline(always)]
        pub const fn result(self) -> Result {
            unsafe { Result::from_ptr(self.ptr.add(0x0628usize) as _) }
        }
        #[doc = "Enable noise shaping"]
        #[inline(always)]
        pub const fn noiseshape(self) -> crate::common::Reg<regs::Noiseshape, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0654usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Trim {
        ptr: *mut u8,
    }
    unsafe impl Send for Trim {}
    unsafe impl Sync for Trim {}
    impl Trim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Linearity calibration coefficient"]
        #[inline(always)]
        pub const fn lincalcoeff(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Lincalcoeff, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Amount(pub u32);
        impl Amount {
            #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer bytes transferred since last START, updated after the END or STOPPED events."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Amount {
            #[inline(always)]
            fn default() -> Amount {
                Amount(0)
            }
        }
        impl core::fmt::Debug for Amount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Amount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Amount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Amount {
                    amount: u16,
                }
                let proxy = Amount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Input configuration for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Gain control"]
            #[inline(always)]
            pub const fn gain(&self) -> super::vals::Gain {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Gain::from_bits(val as u8)
            }
            #[doc = "Gain control"]
            #[inline(always)]
            pub fn set_gain(&mut self, val: super::vals::Gain) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Enable burst mode"]
            #[inline(always)]
            pub const fn burst(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Enable burst mode"]
            #[inline(always)]
            pub fn set_burst(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Reference control"]
            #[inline(always)]
            pub const fn refsel(&self) -> super::vals::Refsel {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::Refsel::from_bits(val as u8)
            }
            #[doc = "Reference control"]
            #[inline(always)]
            pub fn set_refsel(&mut self, val: super::vals::Refsel) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable differential mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::ConfigMode {
                let val = (self.0 >> 15usize) & 0x01;
                super::vals::ConfigMode::from_bits(val as u8)
            }
            #[doc = "Enable differential mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::ConfigMode) {
                self.0 =
                    (self.0 & !(0x01 << 15usize)) | (((val.to_bits() as u32) & 0x01) << 15usize);
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage. Resulting acquistion time is ((TACQ+1) x 125 ns)"]
            #[inline(always)]
            pub const fn tacq(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x01ff;
                val as u16
            }
            #[doc = "Acquisition time, the time the ADC uses to sample the input voltage. Resulting acquistion time is ((TACQ+1) x 125 ns)"]
            #[inline(always)]
            pub fn set_tacq(&mut self, val: u16) {
                self.0 = (self.0 & !(0x01ff << 16usize)) | (((val as u32) & 0x01ff) << 16usize);
            }
            #[doc = "Conversion time. Resulting conversion time is ((TCONV+1) x 250 ns)"]
            #[inline(always)]
            pub const fn tconv(&self) -> u8 {
                let val = (self.0 >> 28usize) & 0x07;
                val as u8
            }
            #[doc = "Conversion time. Resulting conversion time is ((TCONV+1) x 250 ns)"]
            #[inline(always)]
            pub fn set_tconv(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 28usize)) | (((val as u32) & 0x07) << 28usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("gain", &self.gain())
                    .field("burst", &self.burst())
                    .field("refsel", &self.refsel())
                    .field("mode", &self.mode())
                    .field("tacq", &self.tacq())
                    .field("tconv", &self.tconv())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    gain: super::vals::Gain,
                    burst: bool,
                    refsel: super::vals::Refsel,
                    mode: super::vals::ConfigMode,
                    tacq: u16,
                    tconv: u8,
                }
                let proxy = Config {
                    gain: self.gain(),
                    burst: self.burst(),
                    refsel: self.refsel(),
                    mode: self.mode(),
                    tacq: self.tacq(),
                    tconv: self.tconv(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of buffer bytes transferred since last START, continuously updated"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentamount(pub u32);
        impl Currentamount {
            #[doc = "Number of buffer bytes transferred since last START, continuously updated."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Number of buffer bytes transferred since last START, continuously updated."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Currentamount {
            #[inline(always)]
            fn default() -> Currentamount {
                Currentamount(0)
            }
        }
        impl core::fmt::Debug for Currentamount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentamount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentamount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Currentamount {
                    amount: u16,
                }
                let proxy = Currentamount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable ADC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable ADC"]
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable ADC"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STARTED"]
            #[inline(always)]
            pub fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub const fn done(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DONE"]
            #[inline(always)]
            pub fn set_done(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[inline(always)]
            pub const fn resultdone(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RESULTDONE"]
            #[inline(always)]
            pub fn set_resultdone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[inline(always)]
            pub const fn calibratedone(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CALIBRATEDONE"]
            #[inline(always)]
            pub fn set_calibratedone(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[inline(always)]
            pub const fn chlimith(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITH"]
            #[inline(always)]
            pub fn set_chlimith(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 6usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[inline(always)]
            pub const fn chlimitl(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CH0LIMITL"]
            #[inline(always)]
            pub fn set_chlimitl(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 7usize + n * 2usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("end", &self.end())
                    .field("done", &self.done())
                    .field("resultdone", &self.resultdone())
                    .field("calibratedone", &self.calibratedone())
                    .field("stopped", &self.stopped())
                    .field(
                        "chlimith",
                        &[
                            self.chlimith(0usize),
                            self.chlimith(1usize),
                            self.chlimith(2usize),
                            self.chlimith(3usize),
                            self.chlimith(4usize),
                            self.chlimith(5usize),
                            self.chlimith(6usize),
                            self.chlimith(7usize),
                        ],
                    )
                    .field(
                        "chlimitl",
                        &[
                            self.chlimitl(0usize),
                            self.chlimitl(1usize),
                            self.chlimitl(2usize),
                            self.chlimitl(3usize),
                            self.chlimitl(4usize),
                            self.chlimitl(5usize),
                            self.chlimitl(6usize),
                            self.chlimitl(7usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    started: bool,
                    end: bool,
                    done: bool,
                    resultdone: bool,
                    calibratedone: bool,
                    stopped: bool,
                    chlimith: [bool; 8usize],
                    chlimitl: [bool; 8usize],
                }
                let proxy = Int {
                    started: self.started(),
                    end: self.end(),
                    done: self.done(),
                    resultdone: self.resultdone(),
                    calibratedone: self.calibratedone(),
                    stopped: self.stopped(),
                    chlimith: [
                        self.chlimith(0usize),
                        self.chlimith(1usize),
                        self.chlimith(2usize),
                        self.chlimith(3usize),
                        self.chlimith(4usize),
                        self.chlimith(5usize),
                        self.chlimith(6usize),
                        self.chlimith(7usize),
                    ],
                    chlimitl: [
                        self.chlimitl(0usize),
                        self.chlimitl(1usize),
                        self.chlimitl(2usize),
                        self.chlimitl(3usize),
                        self.chlimitl(4usize),
                        self.chlimitl(5usize),
                        self.chlimitl(6usize),
                        self.chlimitl(7usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: High/low limits for event monitoring a channel"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Limit(pub u32);
        impl Limit {
            #[doc = "Low level limit"]
            #[inline(always)]
            pub const fn low(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Low level limit"]
            #[inline(always)]
            pub fn set_low(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
            #[doc = "High level limit"]
            #[inline(always)]
            pub const fn high(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "High level limit"]
            #[inline(always)]
            pub fn set_high(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Limit {
            #[inline(always)]
            fn default() -> Limit {
                Limit(0)
            }
        }
        impl core::fmt::Debug for Limit {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Limit")
                    .field("low", &self.low())
                    .field("high", &self.high())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Limit {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Limit {
                    low: u16,
                    high: u16,
                }
                let proxy = Limit {
                    low: self.low(),
                    high: self.high(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Linearity calibration coefficient"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lincalcoeff(pub u32);
        impl Lincalcoeff {
            #[doc = "value"]
            #[inline(always)]
            pub const fn val(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "value"]
            #[inline(always)]
            pub fn set_val(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Lincalcoeff {
            #[inline(always)]
            fn default() -> Lincalcoeff {
                Lincalcoeff(0)
            }
        }
        impl core::fmt::Debug for Lincalcoeff {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lincalcoeff")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lincalcoeff {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lincalcoeff {
                    val: u16,
                }
                let proxy = Lincalcoeff { val: self.val() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of buffer bytes to transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Maxcnt(pub u32);
        impl Maxcnt {
            #[doc = "Maximum number of buffer bytes to transfer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "Maximum number of buffer bytes to transfer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Maxcnt {
            #[inline(always)]
            fn default() -> Maxcnt {
                Maxcnt(0)
            }
        }
        impl core::fmt::Debug for Maxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Maxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Maxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Maxcnt {
                    maxcnt: u16,
                }
                let proxy = Maxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable noise shaping"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Noiseshape(pub u32);
        impl Noiseshape {
            #[doc = "Enable noise shaping"]
            #[inline(always)]
            pub const fn noiseshape(&self) -> super::vals::Noiseshape {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Noiseshape::from_bits(val as u8)
            }
            #[doc = "Enable noise shaping"]
            #[inline(always)]
            pub fn set_noiseshape(&mut self, val: super::vals::Noiseshape) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Noiseshape {
            #[inline(always)]
            fn default() -> Noiseshape {
                Noiseshape(0)
            }
        }
        impl core::fmt::Debug for Noiseshape {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Noiseshape")
                    .field("noiseshape", &self.noiseshape())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Noiseshape {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Noiseshape {
                    noiseshape: super::vals::Noiseshape,
                }
                let proxy = Noiseshape {
                    noiseshape: self.noiseshape(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Oversampling configuration. OVERSAMPLE should not be combined with SCAN. The RESOLUTION is applied before averaging, thus for high OVERSAMPLE a higher RESOLUTION should be used."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oversample(pub u32);
        impl Oversample {
            #[doc = "Oversample control"]
            #[inline(always)]
            pub const fn oversample(&self) -> super::vals::Oversample {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Oversample::from_bits(val as u8)
            }
            #[doc = "Oversample control"]
            #[inline(always)]
            pub fn set_oversample(&mut self, val: super::vals::Oversample) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Oversample {
            #[inline(always)]
            fn default() -> Oversample {
                Oversample(0)
            }
        }
        impl core::fmt::Debug for Oversample {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oversample")
                    .field("oversample", &self.oversample())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oversample {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Oversample {
                    oversample: super::vals::Oversample,
                }
                let proxy = Oversample {
                    oversample: self.oversample(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Input negative pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pseln(pub u32);
        impl Pseln {
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO Port selection"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::PselnConnect {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PselnConnect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub fn set_connect(&mut self, val: super::vals::PselnConnect) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Pseln {
            #[inline(always)]
            fn default() -> Pseln {
                Pseln(0)
            }
        }
        impl core::fmt::Debug for Pseln {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pseln")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pseln {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pseln {
                    pin: u8,
                    port: u8,
                    connect: super::vals::PselnConnect,
                }
                let proxy = Pseln {
                    pin: self.pin(),
                    port: self.port(),
                    connect: self.connect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Input positive pin selection for CH\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pselp(pub u32);
        impl Pselp {
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "GPIO pin selection."]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "GPIO port selection"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 8usize) & 0x0f;
                val as u8
            }
            #[doc = "GPIO port selection"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 8usize)) | (((val as u32) & 0x0f) << 8usize);
            }
            #[doc = "Internal input selection for analog positive input when CH\\[n\\].PSELP.CONNECT = Internal"]
            #[inline(always)]
            pub const fn internal(&self) -> super::vals::Internal {
                let val = (self.0 >> 12usize) & 0x03;
                super::vals::Internal::from_bits(val as u8)
            }
            #[doc = "Internal input selection for analog positive input when CH\\[n\\].PSELP.CONNECT = Internal"]
            #[inline(always)]
            pub fn set_internal(&mut self, val: super::vals::Internal) {
                self.0 =
                    (self.0 & !(0x03 << 12usize)) | (((val.to_bits() as u32) & 0x03) << 12usize);
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::PselpConnect {
                let val = (self.0 >> 30usize) & 0x03;
                super::vals::PselpConnect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub fn set_connect(&mut self, val: super::vals::PselpConnect) {
                self.0 =
                    (self.0 & !(0x03 << 30usize)) | (((val.to_bits() as u32) & 0x03) << 30usize);
            }
        }
        impl Default for Pselp {
            #[inline(always)]
            fn default() -> Pselp {
                Pselp(0)
            }
        }
        impl core::fmt::Debug for Pselp {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pselp")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("internal", &self.internal())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pselp {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pselp {
                    pin: u8,
                    port: u8,
                    internal: super::vals::Internal,
                    connect: super::vals::PselpConnect,
                }
                let proxy = Pselp {
                    pin: self.pin(),
                    port: self.port(),
                    internal: self.internal(),
                    connect: self.connect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Resolution configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Resolution(pub u32);
        impl Resolution {
            #[doc = "Set the resolution"]
            #[inline(always)]
            pub const fn val(&self) -> super::vals::Val {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::Val::from_bits(val as u8)
            }
            #[doc = "Set the resolution"]
            #[inline(always)]
            pub fn set_val(&mut self, val: super::vals::Val) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Resolution {
            #[inline(always)]
            fn default() -> Resolution {
                Resolution(0)
            }
        }
        impl core::fmt::Debug for Resolution {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Resolution")
                    .field("val", &self.val())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Resolution {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Resolution {
                    val: super::vals::Val,
                }
                let proxy = Resolution { val: self.val() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Controls normal or continuous sample rate"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Samplerate(pub u32);
        impl Samplerate {
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[inline(always)]
            pub const fn cc(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x07ff;
                val as u16
            }
            #[doc = "Capture and compare value. Sample rate is 16 MHz/CC"]
            #[inline(always)]
            pub fn set_cc(&mut self, val: u16) {
                self.0 = (self.0 & !(0x07ff << 0usize)) | (((val as u32) & 0x07ff) << 0usize);
            }
            #[doc = "Select mode for sample rate control"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::SamplerateMode {
                let val = (self.0 >> 12usize) & 0x01;
                super::vals::SamplerateMode::from_bits(val as u8)
            }
            #[doc = "Select mode for sample rate control"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::SamplerateMode) {
                self.0 =
                    (self.0 & !(0x01 << 12usize)) | (((val.to_bits() as u32) & 0x01) << 12usize);
            }
        }
        impl Default for Samplerate {
            #[inline(always)]
            fn default() -> Samplerate {
                Samplerate(0)
            }
        }
        impl core::fmt::Debug for Samplerate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Samplerate")
                    .field("cc", &self.cc())
                    .field("mode", &self.mode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Samplerate {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Samplerate {
                    cc: u16,
                    mode: super::vals::SamplerateMode,
                }
                let proxy = Samplerate {
                    cc: self.cc(),
                    mode: self.mode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "Status"]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::Status {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Status::from_bits(val as u8)
            }
            #[doc = "Status"]
            #[inline(always)]
            pub fn set_status(&mut self, val: super::vals::Status) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Status {
                    status: super::vals::Status,
                }
                let proxy = Status {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigMode {
            #[doc = "Single ended, PSELN will be ignored, negative input to ADC shorted to GND"]
            SE = 0x0,
            #[doc = "Differential"]
            DIFF = 0x01,
        }
        impl ConfigMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigMode {
            #[inline(always)]
            fn from(val: u8) -> ConfigMode {
                ConfigMode::from_bits(val)
            }
        }
        impl From<ConfigMode> for u8 {
            #[inline(always)]
            fn from(val: ConfigMode) -> u8 {
                ConfigMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Gain {
            #[doc = "2"]
            GAIN2 = 0x0,
            #[doc = "1"]
            GAIN1 = 0x01,
            #[doc = "2/3"]
            GAIN2_3 = 0x02,
            #[doc = "2/4"]
            GAIN2_4 = 0x03,
            #[doc = "2/5"]
            GAIN2_5 = 0x04,
            #[doc = "2/6"]
            GAIN2_6 = 0x05,
            #[doc = "2/7"]
            GAIN2_7 = 0x06,
            #[doc = "2/8"]
            GAIN2_8 = 0x07,
        }
        impl Gain {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Gain {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Gain {
            #[inline(always)]
            fn from(val: u8) -> Gain {
                Gain::from_bits(val)
            }
        }
        impl From<Gain> for u8 {
            #[inline(always)]
            fn from(val: Gain) -> u8 {
                Gain::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Internal {
            #[doc = "Connected to the internal 0.9V analog supply rail"]
            AVDD = 0x0,
            #[doc = "Connected to the internal 0.9V digital supply rail"]
            DVDD = 0x01,
            #[doc = "Connected to VDD"]
            VDD = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Internal {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Internal {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Internal {
            #[inline(always)]
            fn from(val: u8) -> Internal {
                Internal::from_bits(val)
            }
        }
        impl From<Internal> for u8 {
            #[inline(always)]
            fn from(val: Internal) -> u8 {
                Internal::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Noiseshape {
            #[doc = "Disable noiseshaping. Oversampling based on accumulate and average."]
            DISABLE = 0x0,
            #[doc = "Noiseshaping and decimating. Larger passband. Provides a 50kS/s cut off frequency, 8x the oversampling ratio. See design description for more information"]
            AUDIO = 0x01,
            #[doc = "Noiseshaping and decimating. Smaller passband. Recommended resolution setting is 14 bits. Provides a 5kS/s cut off frequency, 32x the oversampling ratio. See design description for more information"]
            ACCURACY = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Noiseshape {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Noiseshape {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Noiseshape {
            #[inline(always)]
            fn from(val: u8) -> Noiseshape {
                Noiseshape::from_bits(val)
            }
        }
        impl From<Noiseshape> for u8 {
            #[inline(always)]
            fn from(val: Noiseshape) -> u8 {
                Noiseshape::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oversample {
            #[doc = "Bypass oversampling"]
            BYPASS = 0x0,
            #[doc = "Oversample 2x"]
            OVER2X = 0x01,
            #[doc = "Oversample 4x"]
            OVER4X = 0x02,
            #[doc = "Oversample 8x"]
            OVER8X = 0x03,
            #[doc = "Oversample 16x"]
            OVER16X = 0x04,
            #[doc = "Oversample 32x"]
            OVER32X = 0x05,
            #[doc = "Oversample 64x"]
            OVER64X = 0x06,
            #[doc = "Oversample 128x"]
            OVER128X = 0x07,
            #[doc = "Oversample 256x"]
            OVER256X = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Oversample {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oversample {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oversample {
            #[inline(always)]
            fn from(val: u8) -> Oversample {
                Oversample::from_bits(val)
            }
        }
        impl From<Oversample> for u8 {
            #[inline(always)]
            fn from(val: Oversample) -> u8 {
                Oversample::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselnConnect {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "Select analog input"]
            ANALOG_INPUT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselnConnect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselnConnect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselnConnect {
            #[inline(always)]
            fn from(val: u8) -> PselnConnect {
                PselnConnect::from_bits(val)
            }
        }
        impl From<PselnConnect> for u8 {
            #[inline(always)]
            fn from(val: PselnConnect) -> u8 {
                PselnConnect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum PselpConnect {
            #[doc = "Not connected"]
            NC = 0x0,
            #[doc = "Select analog input"]
            ANALOG_INPUT = 0x01,
            #[doc = "Selects internal inputs."]
            INTERNAL = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl PselpConnect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> PselpConnect {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for PselpConnect {
            #[inline(always)]
            fn from(val: u8) -> PselpConnect {
                PselpConnect::from_bits(val)
            }
        }
        impl From<PselpConnect> for u8 {
            #[inline(always)]
            fn from(val: PselpConnect) -> u8 {
                PselpConnect::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Refsel {
            #[doc = "Internal reference (1.024 V)"]
            INTERNAL = 0x0,
            #[doc = "External reference given at PADC_EXT_REF_1V2"]
            EXTERNAL = 0x01,
        }
        impl Refsel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Refsel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Refsel {
            #[inline(always)]
            fn from(val: u8) -> Refsel {
                Refsel::from_bits(val)
            }
        }
        impl From<Refsel> for u8 {
            #[inline(always)]
            fn from(val: Refsel) -> u8 {
                Refsel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SamplerateMode {
            #[doc = "Rate is controlled from SAMPLE task"]
            TASK = 0x0,
            #[doc = "Rate is controlled from local timer (use CC to control the rate)"]
            TIMERS = 0x01,
        }
        impl SamplerateMode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SamplerateMode {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SamplerateMode {
            #[inline(always)]
            fn from(val: u8) -> SamplerateMode {
                SamplerateMode::from_bits(val)
            }
        }
        impl From<SamplerateMode> for u8 {
            #[inline(always)]
            fn from(val: SamplerateMode) -> u8 {
                SamplerateMode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Status {
            #[doc = "ADC is ready. No on-going conversion."]
            READY = 0x0,
            #[doc = "ADC is busy. Single conversion in progress."]
            BUSY = 0x01,
        }
        impl Status {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Status {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Status {
            #[inline(always)]
            fn from(val: u8) -> Status {
                Status::from_bits(val)
            }
        }
        impl From<Status> for u8 {
            #[inline(always)]
            fn from(val: Status) -> u8 {
                Status::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Val {
            #[doc = "8 bit"]
            _8BIT = 0x0,
            #[doc = "10 bit"]
            _10BIT = 0x01,
            #[doc = "12 bit"]
            _12BIT = 0x02,
            #[doc = "14 bit"]
            _14BIT = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Val {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Val {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Val {
            #[inline(always)]
            fn from(val: u8) -> Val {
                Val::from_bits(val)
            }
        }
        impl From<Val> for u8 {
            #[inline(always)]
            fn from(val: Val) -> u8 {
                Val::to_bits(val)
            }
        }
    }
}
pub mod shared {
    pub mod regs {
        #[doc = "Pin select for LRCK signal"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Psel(pub u32);
        impl Psel {
            #[doc = "Pin number"]
            #[inline(always)]
            pub const fn pin(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Pin number"]
            #[inline(always)]
            pub fn set_pin(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub const fn port(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x07;
                val as u8
            }
            #[doc = "Port number"]
            #[inline(always)]
            pub fn set_port(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 5usize)) | (((val as u32) & 0x07) << 5usize);
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub const fn connect(&self) -> super::vals::Connect {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Connect::from_bits(val as u8)
            }
            #[doc = "Connection"]
            #[inline(always)]
            pub fn set_connect(&mut self, val: super::vals::Connect) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Psel {
            #[inline(always)]
            fn default() -> Psel {
                Psel(0)
            }
        }
        impl core::fmt::Debug for Psel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Psel")
                    .field("pin", &self.pin())
                    .field("port", &self.port())
                    .field("connect", &self.connect())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Psel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Psel {
                    pin: u8,
                    port: u8,
                    connect: super::vals::Connect,
                }
                let proxy = Psel {
                    pin: self.pin(),
                    port: self.port(),
                    connect: self.connect(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Publish configuration for event END"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Publish(pub u32);
        impl Publish {
            #[doc = "DPPI channel that event END will publish to"]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that event END will publish to"]
            #[inline(always)]
            pub fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Publish {
            #[inline(always)]
            fn default() -> Publish {
                Publish(0)
            }
        }
        impl core::fmt::Debug for Publish {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Publish")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Publish {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Publish {
                    chidx: u8,
                    en: bool,
                }
                let proxy = Publish {
                    chidx: self.chidx(),
                    en: self.en(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Subscribe configuration for task START"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Subscribe(pub u32);
        impl Subscribe {
            #[doc = "DPPI channel that task START will subscribe to"]
            #[inline(always)]
            pub const fn chidx(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "DPPI channel that task START will subscribe to"]
            #[inline(always)]
            pub fn set_chidx(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
            #[inline(always)]
            pub const fn en(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_en(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Subscribe {
            #[inline(always)]
            fn default() -> Subscribe {
                Subscribe(0)
            }
        }
        impl core::fmt::Debug for Subscribe {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Subscribe")
                    .field("chidx", &self.chidx())
                    .field("en", &self.en())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Subscribe {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Subscribe {
                    chidx: u8,
                    en: bool,
                }
                let proxy = Subscribe {
                    chidx: self.chidx(),
                    en: self.en(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Connect {
            #[doc = "Connect"]
            CONNECTED = 0x0,
            #[doc = "Disconnect"]
            DISCONNECTED = 0x01,
        }
        impl Connect {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Connect {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Connect {
            #[inline(always)]
            fn from(val: u8) -> Connect {
                Connect::from_bits(val)
            }
        }
        impl From<Connect> for u8 {
            #[inline(always)]
            fn from(val: Connect) -> u8 {
                Connect::to_bits(val)
            }
        }
    }
}
pub mod sicr {
    #[doc = "Factory Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Sicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Sicr {}
    unsafe impl Sync for Sicr {}
    impl Sicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unused."]
        #[inline(always)]
        pub const fn unused(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
}
pub mod spim {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::RxList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "EasyDMA list type"]
        #[inline(always)]
        pub const fn list(self) -> crate::common::Reg<regs::TxList, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Iftiming {
        ptr: *mut u8,
    }
    unsafe impl Send for Iftiming {}
    unsafe impl Sync for Iftiming {}
    impl Iftiming {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Sample delay for input serial data on MISO"]
        #[inline(always)]
        pub const fn rxdelay(self) -> crate::common::Reg<regs::Rxdelay, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is also the minimum duration CSN must stay high between transactions."]
        #[inline(always)]
        pub const fn csndur(self) -> crate::common::Reg<regs::Csndur, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for MOSI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for MISO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for DCX signal"]
        #[inline(always)]
        pub const fn dcx(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Pin select for CSN"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Serial Peripheral Interface Master with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spim {
        ptr: *mut u8,
    }
    unsafe impl Send for Spim {}
    unsafe impl Sync for Spim {}
    impl Spim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start SPI transaction"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop SPI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Suspend SPI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Resume SPI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "SPI transaction has started"]
        #[inline(always)]
        pub const fn events_started(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "SPI transaction has stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "End of RXD buffer and TXD buffer reached"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STARTED"]
        #[inline(always)]
        pub const fn publish_started(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0188usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable SPIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "The prescaler is used to set the SPI frequency."]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x052cusize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::SpimConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0554usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn iftiming(self) -> Iftiming {
            unsafe { Iftiming::from_ptr(self.ptr.add(0x05acusize) as _) }
        }
        #[doc = "DCX configuration"]
        #[inline(always)]
        pub const fn dcxcnt(self) -> crate::common::Reg<regs::Dcxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05b4usize) as _) }
        }
        #[doc = "Polarity of CSN output"]
        #[inline(always)]
        pub const fn csnpol(self) -> crate::common::Reg<regs::Csnpol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05b8usize) as _) }
        }
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is also the minimum duration CSN must stay high between transactions."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csndur(pub u32);
        impl Csndur {
            #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is the minimum duration CSN must stay high between transactions. The value is specified in number of SPIM core clock cycles."]
            #[inline(always)]
            pub const fn csndur(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Minimum duration between edge of CSN and edge of SCK. When SHORTS.END_START is used, this is the minimum duration CSN must stay high between transactions. The value is specified in number of SPIM core clock cycles."]
            #[inline(always)]
            pub fn set_csndur(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Csndur {
            #[inline(always)]
            fn default() -> Csndur {
                Csndur(0)
            }
        }
        impl core::fmt::Debug for Csndur {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csndur")
                    .field("csndur", &self.csndur())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csndur {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Csndur {
                    csndur: u8,
                }
                let proxy = Csndur {
                    csndur: self.csndur(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Polarity of CSN output"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Csnpol(pub u32);
        impl Csnpol {
            #[doc = "Polarity of CSN output"]
            #[inline(always)]
            pub const fn csnpol_0(&self) -> super::vals::Csnpol0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Csnpol0::from_bits(val as u8)
            }
            #[doc = "Polarity of CSN output"]
            #[inline(always)]
            pub fn set_csnpol_0(&mut self, val: super::vals::Csnpol0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Csnpol {
            #[inline(always)]
            fn default() -> Csnpol {
                Csnpol(0)
            }
        }
        impl core::fmt::Debug for Csnpol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Csnpol")
                    .field("csnpol_0", &self.csnpol_0())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Csnpol {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Csnpol {
                    csnpol_0: super::vals::Csnpol0,
                }
                let proxy = Csnpol {
                    csnpol_0: self.csnpol_0(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "DCX configuration"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dcxcnt(pub u32);
        impl Dcxcnt {
            #[doc = "This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[inline(always)]
            pub const fn dcxcnt(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "This register specifies the number of command bytes preceding the data bytes. The PSEL.DCX line will be low during transmission of command bytes and high during transmission of data bytes. Value 0xF indicates that all bytes are command bytes."]
            #[inline(always)]
            pub fn set_dcxcnt(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Dcxcnt {
            #[inline(always)]
            fn default() -> Dcxcnt {
                Dcxcnt(0)
            }
        }
        impl core::fmt::Debug for Dcxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dcxcnt")
                    .field("dcxcnt", &self.dcxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dcxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dcxcnt {
                    dcxcnt: u8,
                }
                let proxy = Dcxcnt {
                    dcxcnt: self.dcxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable SPIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPIM"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPIM"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[inline(always)]
            pub const fn started(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STARTED"]
            #[inline(always)]
            pub fn set_started(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn dmarxmatch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("started", &self.started())
                    .field("stopped", &self.stopped())
                    .field("end", &self.end())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field(
                        "dmarxmatch",
                        &[
                            self.dmarxmatch(0usize),
                            self.dmarxmatch(1usize),
                            self.dmarxmatch(2usize),
                            self.dmarxmatch(3usize),
                        ],
                    )
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    started: bool,
                    stopped: bool,
                    end: bool,
                    dmarxend: bool,
                    dmarxready: bool,
                    dmarxbuserror: bool,
                    dmarxmatch: [bool; 4usize],
                    dmatxend: bool,
                    dmatxready: bool,
                    dmatxbuserror: bool,
                }
                let proxy = Int {
                    started: self.started(),
                    stopped: self.stopped(),
                    end: self.end(),
                    dmarxend: self.dmarxend(),
                    dmarxready: self.dmarxready(),
                    dmarxbuserror: self.dmarxbuserror(),
                    dmarxmatch: [
                        self.dmarxmatch(0usize),
                        self.dmarxmatch(1usize),
                        self.dmarxmatch(2usize),
                        self.dmarxmatch(3usize),
                    ],
                    dmatxend: self.dmatxend(),
                    dmatxready: self.dmatxready(),
                    dmatxbuserror: self.dmatxbuserror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct MatchConfig {
                    enable_0: bool,
                    enable_1: bool,
                    enable_2: bool,
                    enable_3: bool,
                    oneshot_0: super::vals::Oneshot0,
                    oneshot_1: super::vals::Oneshot1,
                    oneshot_2: super::vals::Oneshot2,
                    oneshot_3: super::vals::Oneshot3,
                }
                let proxy = MatchConfig {
                    enable_0: self.enable_0(),
                    enable_1: self.enable_1(),
                    enable_2: self.enable_2(),
                    enable_3: self.enable_3(),
                    oneshot_0: self.oneshot_0(),
                    oneshot_1: self.oneshot_1(),
                    oneshot_2: self.oneshot_2(),
                    oneshot_3: self.oneshot_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Byte transmitted after TXD.MAXCNT bytes have been transmitted in the case when RXD.MAXCNT is greater than TXD.MAXCNT."]
            #[inline(always)]
            pub fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Orc {
                    orc: u8,
                }
                let proxy = Orc { orc: self.orc() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The prescaler is used to set the SPI frequency."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Core clock to SCK divisor"]
            #[inline(always)]
            pub const fn divisor(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Core clock to SCK divisor"]
            #[inline(always)]
            pub fn set_divisor(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("divisor", &self.divisor())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Prescaler {
                    divisor: u8,
                }
                let proxy = Prescaler {
                    divisor: self.divisor(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxAmount {
                    amount: u16,
                }
                let proxy = RxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxList(pub u32);
        impl RxList {
            #[doc = "List type"]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::RxListType {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::RxListType::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub fn set_type_(&mut self, val: super::vals::RxListType) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for RxList {
            #[inline(always)]
            fn default() -> RxList {
                RxList(0)
            }
        }
        impl core::fmt::Debug for RxList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxList")
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxList {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxList {
                    type_: super::vals::RxListType,
                }
                let proxy = RxList {
                    type_: self.type_(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = RxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = RxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Sample delay for input serial data on MISO"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rxdelay(pub u32);
        impl Rxdelay {
            #[doc = "Sample delay for input serial data on MISO. The value specifies the number of SPIM core clock cycles delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[inline(always)]
            pub const fn rxdelay(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x07;
                val as u8
            }
            #[doc = "Sample delay for input serial data on MISO. The value specifies the number of SPIM core clock cycles delay from the the sampling edge of SCK (leading edge for CONFIG.CPHA = 0, trailing edge for CONFIG.CPHA = 1) until the input serial data is sampled. As en example, if RXDELAY = 0 and CONFIG.CPHA = 0, the input serial data is sampled on the rising edge of SCK."]
            #[inline(always)]
            pub fn set_rxdelay(&mut self, val: u8) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val as u32) & 0x07) << 0usize);
            }
        }
        impl Default for Rxdelay {
            #[inline(always)]
            fn default() -> Rxdelay {
                Rxdelay(0)
            }
        }
        impl core::fmt::Debug for Rxdelay {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rxdelay")
                    .field("rxdelay", &self.rxdelay())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rxdelay {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rxdelay {
                    rxdelay: u8,
                }
                let proxy = Rxdelay {
                    rxdelay: self.rxdelay(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub const fn end_start(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task START"]
            #[inline(always)]
            pub fn set_end_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[0\\] and task DMA.RX.DISABLEMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[0\\] and task DMA.RX.DISABLEMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[1\\] and task DMA.RX.DISABLEMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[1\\] and task DMA.RX.DISABLEMATCH\\[1\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[2\\] and task DMA.RX.DISABLEMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[2\\] and task DMA.RX.DISABLEMATCH\\[2\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[3\\] and task DMA.RX.DISABLEMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[3\\] and task DMA.RX.DISABLEMATCH\\[3\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_start", &self.end_start())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    end_start: bool,
                    dma_rx_match0_dma_rx_enablematch1: bool,
                    dma_rx_match1_dma_rx_enablematch2: bool,
                    dma_rx_match2_dma_rx_enablematch3: bool,
                    dma_rx_match3_dma_rx_enablematch0: bool,
                    dma_rx_match0_dma_rx_disablematch0: bool,
                    dma_rx_match1_dma_rx_disablematch1: bool,
                    dma_rx_match2_dma_rx_disablematch2: bool,
                    dma_rx_match3_dma_rx_disablematch3: bool,
                }
                let proxy = Shorts {
                    end_start: self.end_start(),
                    dma_rx_match0_dma_rx_enablematch1: self.dma_rx_match0_dma_rx_enablematch1(),
                    dma_rx_match1_dma_rx_enablematch2: self.dma_rx_match1_dma_rx_enablematch2(),
                    dma_rx_match2_dma_rx_enablematch3: self.dma_rx_match2_dma_rx_enablematch3(),
                    dma_rx_match3_dma_rx_enablematch0: self.dma_rx_match3_dma_rx_enablematch0(),
                    dma_rx_match0_dma_rx_disablematch0: self.dma_rx_match0_dma_rx_disablematch0(),
                    dma_rx_match1_dma_rx_disablematch1: self.dma_rx_match1_dma_rx_disablematch1(),
                    dma_rx_match2_dma_rx_disablematch2: self.dma_rx_match2_dma_rx_disablematch2(),
                    dma_rx_match3_dma_rx_disablematch3: self.dma_rx_match3_dma_rx_disablematch3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpimConfig(pub u32);
        impl SpimConfig {
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SpimConfig {
            #[inline(always)]
            fn default() -> SpimConfig {
                SpimConfig(0)
            }
        }
        impl core::fmt::Debug for SpimConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpimConfig")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpimConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SpimConfig {
                    order: super::vals::Order,
                    cpha: super::vals::Cpha,
                    cpol: super::vals::Cpol,
                }
                let proxy = SpimConfig {
                    order: self.order(),
                    cpha: self.cpha(),
                    cpol: self.cpol(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxAmount {
                    amount: u16,
                }
                let proxy = TxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "EasyDMA list type"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxList(pub u32);
        impl TxList {
            #[doc = "List type"]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::TxListType {
                let val = (self.0 >> 0usize) & 0x07;
                super::vals::TxListType::from_bits(val as u8)
            }
            #[doc = "List type"]
            #[inline(always)]
            pub fn set_type_(&mut self, val: super::vals::TxListType) {
                self.0 = (self.0 & !(0x07 << 0usize)) | (((val.to_bits() as u32) & 0x07) << 0usize);
            }
        }
        impl Default for TxList {
            #[inline(always)]
            fn default() -> TxList {
                TxList(0)
            }
        }
        impl core::fmt::Debug for TxList {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxList")
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxList {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxList {
                    type_: super::vals::TxListType,
                }
                let proxy = TxList {
                    type_: self.type_(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = TxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = TxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Csnpol0 {
            #[doc = "Active low (idle state high)"]
            LOW = 0x0,
            #[doc = "Active high (idle state low)"]
            HIGH = 0x01,
        }
        impl Csnpol0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Csnpol0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Csnpol0 {
            #[inline(always)]
            fn from(val: u8) -> Csnpol0 {
                Csnpol0::from_bits(val)
            }
        }
        impl From<Csnpol0> for u8 {
            #[inline(always)]
            fn from(val: Csnpol0) -> u8 {
                Csnpol0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Enable SPIM"]
            ENABLED = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum RxListType {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl RxListType {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> RxListType {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for RxListType {
            #[inline(always)]
            fn from(val: u8) -> RxListType {
                RxListType::from_bits(val)
            }
        }
        impl From<RxListType> for u8 {
            #[inline(always)]
            fn from(val: RxListType) -> u8 {
                RxListType::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum TxListType {
            #[doc = "Disable EasyDMA list"]
            DISABLED = 0x0,
            #[doc = "Use array list"]
            ARRAY_LIST = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl TxListType {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> TxListType {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for TxListType {
            #[inline(always)]
            fn from(val: u8) -> TxListType {
                TxListType::from_bits(val)
            }
        }
        impl From<TxListType> for u8 {
            #[inline(always)]
            fn from(val: TxListType) -> u8 {
                TxListType::to_bits(val)
            }
        }
    }
}
pub mod spis {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCK"]
        #[inline(always)]
        pub const fn sck(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for MISO signal"]
        #[inline(always)]
        pub const fn miso(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for MOSI signal"]
        #[inline(always)]
        pub const fn mosi(
            self,
        ) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for CSN signal"]
        #[inline(always)]
        pub const fn csn(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "SPI Slave 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spis {
        ptr: *mut u8,
    }
    unsafe impl Send for Spis {}
    unsafe impl Sync for Spis {}
    impl Spis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Acquire SPI semaphore"]
        #[inline(always)]
        pub const fn tasks_acquire(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Release SPI semaphore, enabling the SPI slave to acquire it"]
        #[inline(always)]
        pub const fn tasks_release(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task ACQUIRE"]
        #[inline(always)]
        pub const fn subscribe_acquire(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x94usize) as _) }
        }
        #[doc = "Subscribe configuration for task RELEASE"]
        #[inline(always)]
        pub const fn subscribe_release(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x98usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "Granted transaction completed"]
        #[inline(always)]
        pub const fn events_end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Semaphore acquired"]
        #[inline(always)]
        pub const fn events_acquired(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0118usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn publish_end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ACQUIRED"]
        #[inline(always)]
        pub const fn publish_acquired(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0198usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Semaphore status register"]
        #[inline(always)]
        pub const fn semstat(self) -> crate::common::Reg<regs::Semstat, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Status from last transaction"]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::Status, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Enable SPI slave"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::SpisConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0554usize) as _) }
        }
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[inline(always)]
        pub const fn def(self) -> crate::common::Reg<regs::Def, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x055cusize) as _) }
        }
        #[doc = "Over-read character"]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Default character. Character clocked out in case of an ignored transaction."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Def(pub u32);
        impl Def {
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[inline(always)]
            pub const fn def(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Default character. Character clocked out in case of an ignored transaction."]
            #[inline(always)]
            pub fn set_def(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Def {
            #[inline(always)]
            fn default() -> Def {
                Def(0)
            }
        }
        impl core::fmt::Debug for Def {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Def").field("def", &self.def()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Def {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Def {
                    def: u8,
                }
                let proxy = Def { def: self.def() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable SPI slave"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable SPI slave"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable SPI slave"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub const fn end(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event END"]
            #[inline(always)]
            pub fn set_end(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[inline(always)]
            pub const fn acquired(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event ACQUIRED"]
            #[inline(always)]
            pub fn set_acquired(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn dmarxmatch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 22usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("end", &self.end())
                    .field("acquired", &self.acquired())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field(
                        "dmarxmatch",
                        &[
                            self.dmarxmatch(0usize),
                            self.dmarxmatch(1usize),
                            self.dmarxmatch(2usize),
                            self.dmarxmatch(3usize),
                        ],
                    )
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    end: bool,
                    acquired: bool,
                    dmarxend: bool,
                    dmarxready: bool,
                    dmarxbuserror: bool,
                    dmarxmatch: [bool; 4usize],
                    dmatxend: bool,
                    dmatxready: bool,
                    dmatxbuserror: bool,
                }
                let proxy = Int {
                    end: self.end(),
                    acquired: self.acquired(),
                    dmarxend: self.dmarxend(),
                    dmarxready: self.dmarxready(),
                    dmarxbuserror: self.dmarxbuserror(),
                    dmarxmatch: [
                        self.dmarxmatch(0usize),
                        self.dmarxmatch(1usize),
                        self.dmarxmatch(2usize),
                        self.dmarxmatch(3usize),
                    ],
                    dmatxend: self.dmatxend(),
                    dmatxready: self.dmatxready(),
                    dmatxbuserror: self.dmatxbuserror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct MatchConfig {
                    enable_0: bool,
                    enable_1: bool,
                    enable_2: bool,
                    enable_3: bool,
                    oneshot_0: super::vals::Oneshot0,
                    oneshot_1: super::vals::Oneshot1,
                    oneshot_2: super::vals::Oneshot2,
                    oneshot_3: super::vals::Oneshot3,
                }
                let proxy = MatchConfig {
                    enable_0: self.enable_0(),
                    enable_1: self.enable_1(),
                    enable_2: self.enable_2(),
                    enable_3: self.enable_3(),
                    oneshot_0: self.oneshot_0(),
                    oneshot_1: self.oneshot_1(),
                    oneshot_2: self.oneshot_2(),
                    oneshot_3: self.oneshot_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Over-read character"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character clocked out after an over-read of the transmit buffer."]
            #[inline(always)]
            pub fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Orc {
                    orc: u8,
                }
                let proxy = Orc { orc: self.orc() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxAmount {
                    amount: u16,
                }
                let proxy = RxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = RxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = RxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Semaphore status register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Semstat(pub u32);
        impl Semstat {
            #[doc = "Semaphore status"]
            #[inline(always)]
            pub const fn semstat(&self) -> super::vals::Semstat {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Semstat::from_bits(val as u8)
            }
            #[doc = "Semaphore status"]
            #[inline(always)]
            pub fn set_semstat(&mut self, val: super::vals::Semstat) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Semstat {
            #[inline(always)]
            fn default() -> Semstat {
                Semstat(0)
            }
        }
        impl core::fmt::Debug for Semstat {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Semstat")
                    .field("semstat", &self.semstat())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Semstat {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Semstat {
                    semstat: super::vals::Semstat,
                }
                let proxy = Semstat {
                    semstat: self.semstat(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[inline(always)]
            pub const fn end_acquire(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event END and task ACQUIRE"]
            #[inline(always)]
            pub fn set_end_acquire(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("end_acquire", &self.end_acquire())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    end_acquire: bool,
                    dma_rx_match0_dma_rx_enablematch1: bool,
                    dma_rx_match1_dma_rx_enablematch2: bool,
                    dma_rx_match2_dma_rx_enablematch3: bool,
                    dma_rx_match3_dma_rx_enablematch0: bool,
                    dma_rx_match0_dma_rx_disablematch0: bool,
                    dma_rx_match1_dma_rx_disablematch1: bool,
                    dma_rx_match2_dma_rx_disablematch2: bool,
                    dma_rx_match3_dma_rx_disablematch3: bool,
                }
                let proxy = Shorts {
                    end_acquire: self.end_acquire(),
                    dma_rx_match0_dma_rx_enablematch1: self.dma_rx_match0_dma_rx_enablematch1(),
                    dma_rx_match1_dma_rx_enablematch2: self.dma_rx_match1_dma_rx_enablematch2(),
                    dma_rx_match2_dma_rx_enablematch3: self.dma_rx_match2_dma_rx_enablematch3(),
                    dma_rx_match3_dma_rx_enablematch0: self.dma_rx_match3_dma_rx_enablematch0(),
                    dma_rx_match0_dma_rx_disablematch0: self.dma_rx_match0_dma_rx_disablematch0(),
                    dma_rx_match1_dma_rx_disablematch1: self.dma_rx_match1_dma_rx_disablematch1(),
                    dma_rx_match2_dma_rx_disablematch2: self.dma_rx_match2_dma_rx_disablematch2(),
                    dma_rx_match3_dma_rx_disablematch3: self.dma_rx_match3_dma_rx_disablematch3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpisConfig(pub u32);
        impl SpisConfig {
            #[doc = "Bit order"]
            #[inline(always)]
            pub const fn order(&self) -> super::vals::Order {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Order::from_bits(val as u8)
            }
            #[doc = "Bit order"]
            #[inline(always)]
            pub fn set_order(&mut self, val: super::vals::Order) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub const fn cpha(&self) -> super::vals::Cpha {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Cpha::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) phase"]
            #[inline(always)]
            pub fn set_cpha(&mut self, val: super::vals::Cpha) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub const fn cpol(&self) -> super::vals::Cpol {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Cpol::from_bits(val as u8)
            }
            #[doc = "Serial clock (SCK) polarity"]
            #[inline(always)]
            pub fn set_cpol(&mut self, val: super::vals::Cpol) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for SpisConfig {
            #[inline(always)]
            fn default() -> SpisConfig {
                SpisConfig(0)
            }
        }
        impl core::fmt::Debug for SpisConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpisConfig")
                    .field("order", &self.order())
                    .field("cpha", &self.cpha())
                    .field("cpol", &self.cpol())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpisConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SpisConfig {
                    order: super::vals::Order,
                    cpha: super::vals::Cpha,
                    cpol: super::vals::Cpol,
                }
                let proxy = SpisConfig {
                    order: self.order(),
                    cpha: self.cpha(),
                    cpol: self.cpol(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status from last transaction"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Status(pub u32);
        impl Status {
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Status {
            #[inline(always)]
            fn default() -> Status {
                Status(0)
            }
        }
        impl core::fmt::Debug for Status {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Status")
                    .field("overread", &self.overread())
                    .field("overflow", &self.overflow())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Status {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Status {
                    overread: bool,
                    overflow: bool,
                }
                let proxy = Status {
                    overread: self.overread(),
                    overflow: self.overflow(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxAmount {
                    amount: u16,
                }
                let proxy = TxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = TxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = TxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpha {
            #[doc = "Sample on leading edge of clock, shift serial data on trailing edge"]
            LEADING = 0x0,
            #[doc = "Sample on trailing edge of clock, shift serial data on leading edge"]
            TRAILING = 0x01,
        }
        impl Cpha {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpha {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpha {
            #[inline(always)]
            fn from(val: u8) -> Cpha {
                Cpha::from_bits(val)
            }
        }
        impl From<Cpha> for u8 {
            #[inline(always)]
            fn from(val: Cpha) -> u8 {
                Cpha::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cpol {
            #[doc = "Active high"]
            ACTIVE_HIGH = 0x0,
            #[doc = "Active low"]
            ACTIVE_LOW = 0x01,
        }
        impl Cpol {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cpol {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cpol {
            #[inline(always)]
            fn from(val: u8) -> Cpol {
                Cpol::from_bits(val)
            }
        }
        impl From<Cpol> for u8 {
            #[inline(always)]
            fn from(val: Cpol) -> u8 {
                Cpol::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable SPI slave"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "Enable SPI slave"]
            ENABLED = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Order {
            #[doc = "Most significant bit shifted out first"]
            MSB_FIRST = 0x0,
            #[doc = "Least significant bit shifted out first"]
            LSB_FIRST = 0x01,
        }
        impl Order {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Order {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Order {
            #[inline(always)]
            fn from(val: u8) -> Order {
                Order::from_bits(val)
            }
        }
        impl From<Order> for u8 {
            #[inline(always)]
            fn from(val: Order) -> u8 {
                Order::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Semstat {
            #[doc = "Semaphore is free"]
            FREE = 0x0,
            #[doc = "Semaphore is assigned to CPU"]
            CPU = 0x01,
            #[doc = "Semaphore is assigned to SPI slave"]
            SPIS = 0x02,
            #[doc = "Semaphore is assigned to SPI but a handover to the CPU is pending"]
            CPUPENDING = 0x03,
        }
        impl Semstat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Semstat {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Semstat {
            #[inline(always)]
            fn from(val: u8) -> Semstat {
                Semstat::from_bits(val)
            }
        }
        impl From<Semstat> for u8 {
            #[inline(always)]
            fn from(val: Semstat) -> u8 {
                Semstat::to_bits(val)
            }
        }
    }
}
pub mod spu {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracen {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracen {}
    unsafe impl Sync for Cracen {}
    impl Cracen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configuration for CRACEN SEED"]
        #[inline(always)]
        pub const fn seed(self) -> crate::common::Reg<regs::Seed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dppic {
        ptr: *mut u8,
    }
    unsafe impl Send for Dppic {}
    unsafe impl Sync for Dppic {}
    impl Dppic {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for channel n of DPPIC"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> crate::common::Reg<regs::DppicCh, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Configuration of features for channel group n of DPPIC"]
        #[inline(always)]
        pub const fn chg(self, n: usize) -> crate::common::Reg<regs::Chg, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Feature {
        ptr: *mut u8,
    }
    unsafe impl Send for Feature {}
    unsafe impl Sync for Feature {}
    impl Feature {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dppic(self) -> Dppic {
            unsafe { Dppic::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpiote(self, n: usize) -> Gpiote {
            assert!(n < 2usize);
            unsafe { Gpiote::from_ptr(self.ptr.add(0x0100usize + n * 64usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn cracen(self) -> Cracen {
            unsafe { Cracen::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn gpio(self, n: usize) -> Gpio {
            assert!(n < 3usize);
            unsafe { Gpio::from_ptr(self.ptr.add(0x0200usize + n * 128usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn grtc(self) -> Grtc {
            unsafe { Grtc::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpio {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpio {}
    unsafe impl Sync for Gpio {}
    impl Gpio {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for GPIO\\[n\\] PIN\\[o\\]"]
        #[inline(always)]
        pub const fn pin(self, n: usize) -> crate::common::Reg<regs::Pin, crate::common::RW> {
            assert!(n < 32usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Gpiote {
        ptr: *mut u8,
    }
    unsafe impl Send for Gpiote {}
    unsafe impl Sync for Gpiote {}
    impl Gpiote {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for channel o of GPIOTE\\[n\\]"]
        #[inline(always)]
        pub const fn ch(self, n: usize) -> crate::common::Reg<regs::GpioteCh, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Configuration of features for interrupt o of GPIOTE\\[n\\]"]
        #[inline(always)]
        pub const fn interrupt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::GpioteInterrupt, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Grtc {
        ptr: *mut u8,
    }
    unsafe impl Send for Grtc {}
    unsafe impl Sync for Grtc {}
    impl Grtc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Configuration of features for CC n of GRTC"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<regs::Cc, crate::common::RW> {
            assert!(n < 24usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Configuration of feature for PWMCONFIG of GRTC"]
        #[inline(always)]
        pub const fn pwmconfig(self) -> crate::common::Reg<regs::Pwmconfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Configuration of features for CLKOUT/CLKCFG of GRTC"]
        #[inline(always)]
        pub const fn clk(self) -> crate::common::Reg<regs::Clk, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x78usize) as _) }
        }
        #[doc = "Configuration of features for SYSCOUNTERL/SYSCOUNTERH of GRTC"]
        #[inline(always)]
        pub const fn syscounter(self) -> crate::common::Reg<regs::Syscounter, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x7cusize) as _) }
        }
        #[doc = "Description collection: Configuration of features for interrupt n of GRTC"]
        #[inline(always)]
        pub const fn interrupt(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::GrtcInterrupt, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periph {
        ptr: *mut u8,
    }
    unsafe impl Send for Periph {}
    unsafe impl Sync for Periph {}
    impl Periph {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Get and set the applicable access permissions for the peripheral slave index n"]
        #[inline(always)]
        pub const fn perm(self) -> crate::common::Reg<regs::Perm, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Periphaccerr {
        ptr: *mut u8,
    }
    unsafe impl Send for Periphaccerr {}
    unsafe impl Sync for Periphaccerr {}
    impl Periphaccerr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Address of the transaction that caused first error."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "System protection unit 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spu {
        ptr: *mut u8,
    }
    unsafe impl Send for Spu {}
    unsafe impl Sync for Spu {}
    impl Spu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "A security violation has been detected on one or several peripherals"]
        #[inline(always)]
        pub const fn events_periphaccerr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periphaccerr(self) -> Periphaccerr {
            unsafe { Periphaccerr::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn periph(self, n: usize) -> Periph {
            assert!(n < 64usize);
            unsafe { Periph::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn feature(self) -> Feature {
            unsafe { Feature::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address of the transaction that caused first error."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address"]
            #[inline(always)]
            pub const fn address(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Address"]
            #[inline(always)]
            pub fn set_address(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Address {
                    address: u16,
                }
                let proxy = Address {
                    address: self.address(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for CC n of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cc(pub u32);
        impl Cc {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Cc {
            #[inline(always)]
            fn default() -> Cc {
                Cc(0)
            }
        }
        impl core::fmt::Debug for Cc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cc")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cc {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Cc {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for channel group n of DPPIC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chg(pub u32);
        impl Chg {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Chg {
            #[inline(always)]
            fn default() -> Chg {
                Chg(0)
            }
        }
        impl core::fmt::Debug for Chg {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chg")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chg {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Chg {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Chg {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of features for CLKOUT/CLKCFG of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Clk(pub u32);
        impl Clk {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Clk {
            #[inline(always)]
            fn default() -> Clk {
                Clk(0)
            }
        }
        impl core::fmt::Debug for Clk {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Clk")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Clk {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Clk {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Clk {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for channel n of DPPIC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DppicCh(pub u32);
        impl DppicCh {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for DppicCh {
            #[inline(always)]
            fn default() -> DppicCh {
                DppicCh(0)
            }
        }
        impl core::fmt::Debug for DppicCh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DppicCh")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DppicCh {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct DppicCh {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = DppicCh {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for channel o of GPIOTE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioteCh(pub u32);
        impl GpioteCh {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GpioteCh {
            #[inline(always)]
            fn default() -> GpioteCh {
                GpioteCh(0)
            }
        }
        impl core::fmt::Debug for GpioteCh {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioteCh")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioteCh {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GpioteCh {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = GpioteCh {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for interrupt o of GPIOTE\\[n\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GpioteInterrupt(pub u32);
        impl GpioteInterrupt {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GpioteInterrupt {
            #[inline(always)]
            fn default() -> GpioteInterrupt {
                GpioteInterrupt(0)
            }
        }
        impl core::fmt::Debug for GpioteInterrupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GpioteInterrupt")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GpioteInterrupt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GpioteInterrupt {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = GpioteInterrupt {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for interrupt n of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GrtcInterrupt(pub u32);
        impl GrtcInterrupt {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for GrtcInterrupt {
            #[inline(always)]
            fn default() -> GrtcInterrupt {
                GrtcInterrupt(0)
            }
        }
        impl core::fmt::Debug for GrtcInterrupt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GrtcInterrupt")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GrtcInterrupt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GrtcInterrupt {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = GrtcInterrupt {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[inline(always)]
            pub const fn periphaccerr(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event PERIPHACCERR"]
            #[inline(always)]
            pub fn set_periphaccerr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("periphaccerr", &self.periphaccerr())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    periphaccerr: bool,
                }
                let proxy = Int {
                    periphaccerr: self.periphaccerr(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Get and set the applicable access permissions for the peripheral slave index n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Perm(pub u32);
        impl Perm {
            #[doc = "Read capabilities for TrustZone Cortex-M secure attribute"]
            #[inline(always)]
            pub const fn securemapping(&self) -> super::vals::Securemapping {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Securemapping::from_bits(val as u8)
            }
            #[doc = "Read capabilities for TrustZone Cortex-M secure attribute"]
            #[inline(always)]
            pub fn set_securemapping(&mut self, val: super::vals::Securemapping) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Read the peripheral DMA capabilities"]
            #[inline(always)]
            pub const fn dma(&self) -> super::vals::Dma {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Dma::from_bits(val as u8)
            }
            #[doc = "Read the peripheral DMA capabilities"]
            #[inline(always)]
            pub fn set_dma(&mut self, val: super::vals::Dma) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Peripheral security mapping"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Peripheral security mapping"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[inline(always)]
            pub const fn dmasec(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Security attribution for the DMA transfer"]
            #[inline(always)]
            pub fn set_dmasec(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Register lock"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Register lock"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates if a peripheral is present with peripheral slave index n"]
            #[inline(always)]
            pub const fn present(&self) -> super::vals::Present {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Present::from_bits(val as u8)
            }
            #[doc = "Indicates if a peripheral is present with peripheral slave index n"]
            #[inline(always)]
            pub fn set_present(&mut self, val: super::vals::Present) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Perm {
            #[inline(always)]
            fn default() -> Perm {
                Perm(0)
            }
        }
        impl core::fmt::Debug for Perm {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Perm")
                    .field("securemapping", &self.securemapping())
                    .field("dma", &self.dma())
                    .field("secattr", &self.secattr())
                    .field("dmasec", &self.dmasec())
                    .field("lock", &self.lock())
                    .field("present", &self.present())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Perm {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Perm {
                    securemapping: super::vals::Securemapping,
                    dma: super::vals::Dma,
                    secattr: bool,
                    dmasec: bool,
                    lock: bool,
                    present: super::vals::Present,
                }
                let proxy = Perm {
                    securemapping: self.securemapping(),
                    dma: self.dma(),
                    secattr: self.secattr(),
                    dmasec: self.dmasec(),
                    lock: self.lock(),
                    present: self.present(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Configuration of features for GPIO\\[n\\] PIN\\[o\\]"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pin(pub u32);
        impl Pin {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Pin {
            #[inline(always)]
            fn default() -> Pin {
                Pin(0)
            }
        }
        impl core::fmt::Debug for Pin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pin")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pin {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pin {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Pin {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of feature for PWMCONFIG of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Pwmconfig(pub u32);
        impl Pwmconfig {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Pwmconfig {
            #[inline(always)]
            fn default() -> Pwmconfig {
                Pwmconfig(0)
            }
        }
        impl core::fmt::Debug for Pwmconfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Pwmconfig")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Pwmconfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Pwmconfig {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Pwmconfig {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration for CRACEN SEED"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Seed(pub u32);
        impl Seed {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Seed {
            #[inline(always)]
            fn default() -> Seed {
                Seed(0)
            }
        }
        impl core::fmt::Debug for Seed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Seed")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Seed {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Seed {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Seed {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of features for SYSCOUNTERL/SYSCOUNTERH of GRTC"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syscounter(pub u32);
        impl Syscounter {
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub const fn secattr(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "SECATTR feature"]
            #[inline(always)]
            pub fn set_secattr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "LOCK feature"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
        }
        impl Default for Syscounter {
            #[inline(always)]
            fn default() -> Syscounter {
                Syscounter(0)
            }
        }
        impl core::fmt::Debug for Syscounter {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syscounter")
                    .field("secattr", &self.secattr())
                    .field("lock", &self.lock())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syscounter {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Syscounter {
                    secattr: bool,
                    lock: bool,
                }
                let proxy = Syscounter {
                    secattr: self.secattr(),
                    lock: self.lock(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Dma {
            #[doc = "Peripheral has no DMA capability"]
            NO_DMA = 0x0,
            #[doc = "Peripheral has DMA and DMA transfers always have the same security attribute as assigned to the peripheral"]
            NO_SEPARATE_ATTRIBUTE = 0x01,
            #[doc = "Peripheral has DMA and DMA transfers can have a different security attribute than the one assigned to the peripheral"]
            SEPARATE_ATTRIBUTE = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Dma {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Dma {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Dma {
            #[inline(always)]
            fn from(val: u8) -> Dma {
                Dma::from_bits(val)
            }
        }
        impl From<Dma> for u8 {
            #[inline(always)]
            fn from(val: Dma) -> u8 {
                Dma::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Present {
            #[doc = "Peripheral is not present"]
            NOT_PRESENT = 0x0,
            #[doc = "Peripheral is present"]
            IS_PRESENT = 0x01,
        }
        impl Present {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Present {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Present {
            #[inline(always)]
            fn from(val: u8) -> Present {
                Present::from_bits(val)
            }
        }
        impl From<Present> for u8 {
            #[inline(always)]
            fn from(val: Present) -> u8 {
                Present::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Securemapping {
            #[doc = "This peripheral is always accessible as a non-secure peripheral"]
            NON_SECURE = 0x0,
            #[doc = "This peripheral is always accessible as a secure peripheral"]
            SECURE = 0x01,
            #[doc = "Non-secure or secure attribute for this peripheral is defined by the PERIPH\\[n\\].PERM register"]
            USER_SELECTABLE = 0x02,
            #[doc = "This peripheral implements the split security mechanism."]
            SPLIT = 0x03,
        }
        impl Securemapping {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Securemapping {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Securemapping {
            #[inline(always)]
            fn from(val: u8) -> Securemapping {
                Securemapping::from_bits(val)
            }
        }
        impl From<Securemapping> for u8 {
            #[inline(always)]
            fn from(val: Securemapping) -> u8 {
                Securemapping::to_bits(val)
            }
        }
    }
}
pub mod swi {
    #[doc = "Software interrupt 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Swi {
        ptr: *mut u8,
    }
    unsafe impl Send for Swi {}
    unsafe impl Sync for Swi {}
    impl Swi {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unused."]
        #[inline(always)]
        pub const fn unused(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
}
pub mod tad {
    #[doc = "Trace and debug control 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tad {
        ptr: *mut u8,
    }
    unsafe impl Send for Tad {}
    unsafe impl Sync for Tad {}
    impl Tad {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "System power-up request"]
        #[inline(always)]
        pub const fn syspwrupreq(self) -> crate::common::Reg<regs::Syspwrupreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Debug power-up request"]
        #[inline(always)]
        pub const fn dbgpwrupreq(self) -> crate::common::Reg<regs::Dbgpwrupreq, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Trace port speed"]
        #[inline(always)]
        pub const fn traceportspeed(
            self,
        ) -> crate::common::Reg<regs::Traceportspeed, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0518usize) as _) }
        }
        #[doc = "SW-DP Target instance"]
        #[inline(always)]
        pub const fn tinstance(self) -> crate::common::Reg<regs::Tinstance, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Debug power-up request"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dbgpwrupreq(pub u32);
        impl Dbgpwrupreq {
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Dbgpwrupreq {
            #[inline(always)]
            fn default() -> Dbgpwrupreq {
                Dbgpwrupreq(0)
            }
        }
        impl core::fmt::Debug for Dbgpwrupreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dbgpwrupreq")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dbgpwrupreq {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dbgpwrupreq {
                    active: bool,
                }
                let proxy = Dbgpwrupreq {
                    active: self.active(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable debug domain and aquire selected GPIOs"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: bool,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "System power-up request"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Syspwrupreq(pub u32);
        impl Syspwrupreq {
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub const fn active(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Activate power-up request"]
            #[inline(always)]
            pub fn set_active(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Syspwrupreq {
            #[inline(always)]
            fn default() -> Syspwrupreq {
                Syspwrupreq(0)
            }
        }
        impl core::fmt::Debug for Syspwrupreq {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Syspwrupreq")
                    .field("active", &self.active())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Syspwrupreq {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Syspwrupreq {
                    active: bool,
                }
                let proxy = Syspwrupreq {
                    active: self.active(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "SW-DP Target instance"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tinstance(pub u32);
        impl Tinstance {
            #[doc = "TINSTANCE bits are used in the SW-DP DLPIDR.TINSTANCE field."]
            #[inline(always)]
            pub const fn tinstance(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "TINSTANCE bits are used in the SW-DP DLPIDR.TINSTANCE field."]
            #[inline(always)]
            pub fn set_tinstance(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Tinstance {
            #[inline(always)]
            fn default() -> Tinstance {
                Tinstance(0)
            }
        }
        impl core::fmt::Debug for Tinstance {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tinstance")
                    .field("tinstance", &self.tinstance())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tinstance {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tinstance {
                    tinstance: u8,
                }
                let proxy = Tinstance {
                    tinstance: self.tinstance(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Trace port speed"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Traceportspeed(pub u32);
        impl Traceportspeed {
            #[doc = "Trace port speed is divided from CPU clock. The TRACECLK pin output will be divided again by two from the trace port clock."]
            #[inline(always)]
            pub const fn traceportspeed(&self) -> super::vals::Traceportspeed {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Traceportspeed::from_bits(val as u8)
            }
            #[doc = "Trace port speed is divided from CPU clock. The TRACECLK pin output will be divided again by two from the trace port clock."]
            #[inline(always)]
            pub fn set_traceportspeed(&mut self, val: super::vals::Traceportspeed) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Traceportspeed {
            #[inline(always)]
            fn default() -> Traceportspeed {
                Traceportspeed(0)
            }
        }
        impl core::fmt::Debug for Traceportspeed {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Traceportspeed")
                    .field("traceportspeed", &self.traceportspeed())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Traceportspeed {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Traceportspeed {
                    traceportspeed: super::vals::Traceportspeed,
                }
                let proxy = Traceportspeed {
                    traceportspeed: self.traceportspeed(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Traceportspeed {
            #[doc = "Trace port speed equals CPU clock"]
            DIV1 = 0x0,
            #[doc = "Trace port speed equals CPU clock divided by 2"]
            DIV2 = 0x01,
            #[doc = "Trace port speed equals CPU clock divided by 4"]
            DIV4 = 0x02,
            #[doc = "Trace port speed equals CPU clock divided by 32"]
            DIV32 = 0x03,
        }
        impl Traceportspeed {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Traceportspeed {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Traceportspeed {
            #[inline(always)]
            fn from(val: u8) -> Traceportspeed {
                Traceportspeed::from_bits(val)
            }
        }
        impl From<Traceportspeed> for u8 {
            #[inline(always)]
            fn from(val: Traceportspeed) -> u8 {
                Traceportspeed::to_bits(val)
            }
        }
    }
}
pub mod tampc {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Ap {
        ptr: *mut u8,
    }
    unsafe impl Send for Ap {}
    unsafe impl Sync for Ap {}
    impl Ap {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dbgen(self) -> ApDbgen {
            unsafe { ApDbgen::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ApDbgen {
        ptr: *mut u8,
    }
    unsafe impl Send for ApDbgen {}
    unsafe impl Sync for ApDbgen {}
    impl ApDbgen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register to enable invasive (halting) debug in domain n's access port."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ApDbgenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n's access port."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::ApDbgenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Enable tamper detector from CRACEN."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Cracentamp {
        ptr: *mut u8,
    }
    unsafe impl Send for Cracentamp {}
    unsafe impl Sync for Cracentamp {}
    impl Cracentamp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for CRACEN tamper detector enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::CracentampCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for CRACEN tamper detector enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::CracentampStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Domain {
        ptr: *mut u8,
    }
    unsafe impl Send for Domain {}
    unsafe impl Sync for Domain {}
    impl Domain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dbgen(self) -> DomainDbgen {
            unsafe { DomainDbgen::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn niden(self) -> Niden {
            unsafe { Niden::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn spiden(self) -> Spiden {
            unsafe { Spiden::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn spniden(self) -> Spniden {
            unsafe { Spniden::from_ptr(self.ptr.add(0x18usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DomainDbgen {
        ptr: *mut u8,
    }
    unsafe impl Send for DomainDbgen {}
    unsafe impl Sync for DomainDbgen {}
    impl DomainDbgen {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for invasive (halting) debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::DomainDbgenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::DomainDbgenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Device erase protection."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for erase protection."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::EraseprotectCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for eraseprotect."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::EraseprotectStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Trigger a reset when tamper is detected by the external tamper detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Extreseten {
        ptr: *mut u8,
    }
    unsafe impl Send for Extreseten {}
    unsafe impl Sync for Extreseten {}
    impl Extreseten {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for external tamper reset enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ExtresetenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for external tamper reset enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::ExtresetenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Enable fast domain glitch detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchfastdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchfastdomain {}
    unsafe impl Sync for Glitchfastdomain {}
    impl Glitchfastdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for fast domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn ctrl(
            self,
        ) -> crate::common::Reg<regs::GlitchfastdomainCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for fast domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::GlitchfastdomainStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Enable slow domain glitch detectors."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Glitchslowdomain {
        ptr: *mut u8,
    }
    unsafe impl Send for Glitchslowdomain {}
    unsafe impl Sync for Glitchslowdomain {}
    impl Glitchslowdomain {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for slow domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn ctrl(
            self,
        ) -> crate::common::Reg<regs::GlitchslowdomainCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for slow domain glitch detectors enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::GlitchslowdomainStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Trigger a reset when tamper is detected by the glitch detectors, signal protector or CRACEN tamper detector."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Intreseten {
        ptr: *mut u8,
    }
    unsafe impl Send for Intreseten {}
    unsafe impl Sync for Intreseten {}
    impl Intreseten {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for internal tamper reset enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::IntresetenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for internal tamper reset enable signal."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::IntresetenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Niden {
        ptr: *mut u8,
    }
    unsafe impl Send for Niden {}
    unsafe impl Sync for Niden {}
    impl Niden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for non-invasive debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::NidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for non-invasive debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::NidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Protect {
        ptr: *mut u8,
    }
    unsafe impl Send for Protect {}
    unsafe impl Sync for Protect {}
    impl Protect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn domain(self, n: usize) -> Domain {
            assert!(n < 1usize);
            unsafe { Domain::from_ptr(self.ptr.add(0x0usize + n * 32usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn ap(self, n: usize) -> Ap {
            assert!(n < 1usize);
            unsafe { Ap::from_ptr(self.ptr.add(0x0200usize + n * 16usize) as _) }
        }
        #[doc = "Enable active shield detector."]
        #[inline(always)]
        pub const fn activeshield(self) -> ProtectActiveshield {
            unsafe { ProtectActiveshield::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Enable tamper detector from CRACEN."]
        #[inline(always)]
        pub const fn cracentamp(self) -> Cracentamp {
            unsafe { Cracentamp::from_ptr(self.ptr.add(0x0438usize) as _) }
        }
        #[doc = "Enable slow domain glitch detectors."]
        #[inline(always)]
        pub const fn glitchslowdomain(self) -> Glitchslowdomain {
            unsafe { Glitchslowdomain::from_ptr(self.ptr.add(0x0440usize) as _) }
        }
        #[doc = "Enable fast domain glitch detectors."]
        #[inline(always)]
        pub const fn glitchfastdomain(self) -> Glitchfastdomain {
            unsafe { Glitchfastdomain::from_ptr(self.ptr.add(0x0448usize) as _) }
        }
        #[doc = "Trigger a reset when tamper is detected by the external tamper detectors."]
        #[inline(always)]
        pub const fn extreseten(self) -> Extreseten {
            unsafe { Extreseten::from_ptr(self.ptr.add(0x0470usize) as _) }
        }
        #[doc = "Trigger a reset when tamper is detected by the glitch detectors, signal protector or CRACEN tamper detector."]
        #[inline(always)]
        pub const fn intreseten(self) -> Intreseten {
            unsafe { Intreseten::from_ptr(self.ptr.add(0x0478usize) as _) }
        }
        #[doc = "Device erase protection."]
        #[inline(always)]
        pub const fn eraseprotect(self) -> Eraseprotect {
            unsafe { Eraseprotect::from_ptr(self.ptr.add(0x0480usize) as _) }
        }
    }
    #[doc = "Enable active shield detector."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct ProtectActiveshield {
        ptr: *mut u8,
    }
    unsafe impl Send for ProtectActiveshield {}
    unsafe impl Sync for ProtectActiveshield {}
    impl ProtectActiveshield {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Control register for active shield detector enable signal."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::ActiveshieldCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Status register for active shield detector enable signal."]
        #[inline(always)]
        pub const fn status(
            self,
        ) -> crate::common::Reg<regs::ActiveshieldStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spiden {
        ptr: *mut u8,
    }
    unsafe impl Send for Spiden {}
    unsafe impl Sync for Spiden {}
    impl Spiden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for secure priviliged invasive (halting) debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::SpidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for secure priviliged invasive (halting) debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::SpidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Spniden {
        ptr: *mut u8,
    }
    unsafe impl Send for Spniden {}
    unsafe impl Sync for Spniden {}
    impl Spniden {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Control register for secure priviliged non-invasive debug enable for the local debug components within domain n."]
        #[inline(always)]
        pub const fn ctrl(self) -> crate::common::Reg<regs::SpnidenCtrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Status register for secure priviliged non-invasive debug enable for domain n."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::SpnidenStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Tamper controller"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tampc {
        ptr: *mut u8,
    }
    unsafe impl Send for Tampc {}
    unsafe impl Sync for Tampc {}
    impl Tampc {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Tamper controller detected an error."]
        #[inline(always)]
        pub const fn events_tamper(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Attempt to write a VALUE in PROTECT registers without clearing the WRITEPROTECT."]
        #[inline(always)]
        pub const fn events_writeerror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "The tamper controller status."]
        #[inline(always)]
        pub const fn status(self) -> crate::common::Reg<regs::TampcStatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn activeshield(self) -> TampcActiveshield {
            unsafe { TampcActiveshield::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn protect(self) -> Protect {
            unsafe { Protect::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TampcActiveshield {
        ptr: *mut u8,
    }
    unsafe impl Send for TampcActiveshield {}
    unsafe impl Sync for TampcActiveshield {}
    impl TampcActiveshield {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Active shield detector channel enable register."]
        #[inline(always)]
        pub const fn chen(self) -> crate::common::Reg<regs::Chen, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Control register for active shield detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActiveshieldCtrl(pub u32);
        impl ActiveshieldCtrl {
            #[doc = "Set value of active shield enable signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ActiveshieldCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ActiveshieldCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of active shield enable signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::ActiveshieldCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ActiveshieldCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ActiveshieldCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(
                &mut self,
                val: super::vals::ActiveshieldCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ActiveshieldCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ActiveshieldCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::ActiveshieldCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ActiveshieldCtrl {
            #[inline(always)]
            fn default() -> ActiveshieldCtrl {
                ActiveshieldCtrl(0)
            }
        }
        impl core::fmt::Debug for ActiveshieldCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActiveshieldCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ActiveshieldCtrl {
                    value: super::vals::ActiveshieldCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::ActiveshieldCtrlWriteprotection,
                    key: super::vals::ActiveshieldCtrlKey,
                }
                let proxy = ActiveshieldCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for active shield detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ActiveshieldStatus(pub u32);
        impl ActiveshieldStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ActiveshieldStatus {
            #[inline(always)]
            fn default() -> ActiveshieldStatus {
                ActiveshieldStatus(0)
            }
        }
        impl core::fmt::Debug for ActiveshieldStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ActiveshieldStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ActiveshieldStatus {
                    error: bool,
                }
                let proxy = ActiveshieldStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Control register to enable invasive (halting) debug in domain n's access port."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApDbgenCtrl(pub u32);
        impl ApDbgenCtrl {
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ApDbgenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ApDbgenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::ApDbgenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ApDbgenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ApDbgenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::ApDbgenCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ApDbgenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ApDbgenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::ApDbgenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ApDbgenCtrl {
            #[inline(always)]
            fn default() -> ApDbgenCtrl {
                ApDbgenCtrl(0)
            }
        }
        impl core::fmt::Debug for ApDbgenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApDbgenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ApDbgenCtrl {
                    value: super::vals::ApDbgenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::ApDbgenCtrlWriteprotection,
                    key: super::vals::ApDbgenCtrlKey,
                }
                let proxy = ApDbgenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n's access port."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApDbgenStatus(pub u32);
        impl ApDbgenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ApDbgenStatus {
            #[inline(always)]
            fn default() -> ApDbgenStatus {
                ApDbgenStatus(0)
            }
        }
        impl core::fmt::Debug for ApDbgenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApDbgenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ApDbgenStatus {
                    error: bool,
                }
                let proxy = ApDbgenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Active shield detector channel enable register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Chen(pub u32);
        impl Chen {
            #[doc = "Enable or disable active shield channel 0."]
            #[inline(always)]
            pub const fn ch(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable active shield channel 0."]
            #[inline(always)]
            pub fn set_ch(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Chen {
            #[inline(always)]
            fn default() -> Chen {
                Chen(0)
            }
        }
        impl core::fmt::Debug for Chen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Chen")
                    .field(
                        "ch",
                        &[
                            self.ch(0usize),
                            self.ch(1usize),
                            self.ch(2usize),
                            self.ch(3usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Chen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Chen {
                    ch: [bool; 4usize],
                }
                let proxy = Chen {
                    ch: [
                        self.ch(0usize),
                        self.ch(1usize),
                        self.ch(2usize),
                        self.ch(3usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register for CRACEN tamper detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CracentampCtrl(pub u32);
        impl CracentampCtrl {
            #[doc = "Set value of CRACEN tamper detector enable signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::CracentampCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CracentampCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of CRACEN tamper detector enable signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::CracentampCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::CracentampCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::CracentampCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::CracentampCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::CracentampCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::CracentampCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::CracentampCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for CracentampCtrl {
            #[inline(always)]
            fn default() -> CracentampCtrl {
                CracentampCtrl(0)
            }
        }
        impl core::fmt::Debug for CracentampCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CracentampCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct CracentampCtrl {
                    value: super::vals::CracentampCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::CracentampCtrlWriteprotection,
                    key: super::vals::CracentampCtrlKey,
                }
                let proxy = CracentampCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for CRACEN tamper detector enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct CracentampStatus(pub u32);
        impl CracentampStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for CracentampStatus {
            #[inline(always)]
            fn default() -> CracentampStatus {
                CracentampStatus(0)
            }
        }
        impl core::fmt::Debug for CracentampStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("CracentampStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct CracentampStatus {
                    error: bool,
                }
                let proxy = CracentampStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Control register for invasive (halting) debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DomainDbgenCtrl(pub u32);
        impl DomainDbgenCtrl {
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::DomainDbgenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::DomainDbgenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of dbgen signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::DomainDbgenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::DomainDbgenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::DomainDbgenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(
                &mut self,
                val: super::vals::DomainDbgenCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::DomainDbgenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::DomainDbgenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::DomainDbgenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for DomainDbgenCtrl {
            #[inline(always)]
            fn default() -> DomainDbgenCtrl {
                DomainDbgenCtrl(0)
            }
        }
        impl core::fmt::Debug for DomainDbgenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DomainDbgenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct DomainDbgenCtrl {
                    value: super::vals::DomainDbgenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::DomainDbgenCtrlWriteprotection,
                    key: super::vals::DomainDbgenCtrlKey,
                }
                let proxy = DomainDbgenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Status register for invasive (halting) debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct DomainDbgenStatus(pub u32);
        impl DomainDbgenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for DomainDbgenStatus {
            #[inline(always)]
            fn default() -> DomainDbgenStatus {
                DomainDbgenStatus(0)
            }
        }
        impl core::fmt::Debug for DomainDbgenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("DomainDbgenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct DomainDbgenStatus {
                    error: bool,
                }
                let proxy = DomainDbgenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register for erase protection."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectCtrl(pub u32);
        impl EraseprotectCtrl {
            #[doc = "Set value of eraseprotect signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::EraseprotectCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::EraseprotectCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of eraseprotect signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::EraseprotectCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::EraseprotectCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::EraseprotectCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(
                &mut self,
                val: super::vals::EraseprotectCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::EraseprotectCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::EraseprotectCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::EraseprotectCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for EraseprotectCtrl {
            #[inline(always)]
            fn default() -> EraseprotectCtrl {
                EraseprotectCtrl(0)
            }
        }
        impl core::fmt::Debug for EraseprotectCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct EraseprotectCtrl {
                    value: super::vals::EraseprotectCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::EraseprotectCtrlWriteprotection,
                    key: super::vals::EraseprotectCtrlKey,
                }
                let proxy = EraseprotectCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for eraseprotect."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectStatus(pub u32);
        impl EraseprotectStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for EraseprotectStatus {
            #[inline(always)]
            fn default() -> EraseprotectStatus {
                EraseprotectStatus(0)
            }
        }
        impl core::fmt::Debug for EraseprotectStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct EraseprotectStatus {
                    error: bool,
                }
                let proxy = EraseprotectStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register for external tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtresetenCtrl(pub u32);
        impl ExtresetenCtrl {
            #[doc = "Set value of external tamper reset enable signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::ExtresetenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ExtresetenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of external tamper reset enable signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::ExtresetenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::ExtresetenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::ExtresetenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::ExtresetenCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::ExtresetenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::ExtresetenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::ExtresetenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for ExtresetenCtrl {
            #[inline(always)]
            fn default() -> ExtresetenCtrl {
                ExtresetenCtrl(0)
            }
        }
        impl core::fmt::Debug for ExtresetenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtresetenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ExtresetenCtrl {
                    value: super::vals::ExtresetenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::ExtresetenCtrlWriteprotection,
                    key: super::vals::ExtresetenCtrlKey,
                }
                let proxy = ExtresetenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for external tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ExtresetenStatus(pub u32);
        impl ExtresetenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for ExtresetenStatus {
            #[inline(always)]
            fn default() -> ExtresetenStatus {
                ExtresetenStatus(0)
            }
        }
        impl core::fmt::Debug for ExtresetenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ExtresetenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ExtresetenStatus {
                    error: bool,
                }
                let proxy = ExtresetenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register for fast domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchfastdomainCtrl(pub u32);
        impl GlitchfastdomainCtrl {
            #[doc = "Set value of fast domain glitch detector's enable signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::GlitchfastdomainCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GlitchfastdomainCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of fast domain glitch detector's enable signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::GlitchfastdomainCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(
                &self,
            ) -> super::vals::GlitchfastdomainCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::GlitchfastdomainCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(
                &mut self,
                val: super::vals::GlitchfastdomainCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::GlitchfastdomainCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::GlitchfastdomainCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::GlitchfastdomainCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlitchfastdomainCtrl {
            #[inline(always)]
            fn default() -> GlitchfastdomainCtrl {
                GlitchfastdomainCtrl(0)
            }
        }
        impl core::fmt::Debug for GlitchfastdomainCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchfastdomainCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GlitchfastdomainCtrl {
                    value: super::vals::GlitchfastdomainCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::GlitchfastdomainCtrlWriteprotection,
                    key: super::vals::GlitchfastdomainCtrlKey,
                }
                let proxy = GlitchfastdomainCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for fast domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchfastdomainStatus(pub u32);
        impl GlitchfastdomainStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GlitchfastdomainStatus {
            #[inline(always)]
            fn default() -> GlitchfastdomainStatus {
                GlitchfastdomainStatus(0)
            }
        }
        impl core::fmt::Debug for GlitchfastdomainStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchfastdomainStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GlitchfastdomainStatus {
                    error: bool,
                }
                let proxy = GlitchfastdomainStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register for slow domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchslowdomainCtrl(pub u32);
        impl GlitchslowdomainCtrl {
            #[doc = "Set value of slow domain glitch detectors enable signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::GlitchslowdomainCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::GlitchslowdomainCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of slow domain glitch detectors enable signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::GlitchslowdomainCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(
                &self,
            ) -> super::vals::GlitchslowdomainCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::GlitchslowdomainCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(
                &mut self,
                val: super::vals::GlitchslowdomainCtrlWriteprotection,
            ) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::GlitchslowdomainCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::GlitchslowdomainCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::GlitchslowdomainCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for GlitchslowdomainCtrl {
            #[inline(always)]
            fn default() -> GlitchslowdomainCtrl {
                GlitchslowdomainCtrl(0)
            }
        }
        impl core::fmt::Debug for GlitchslowdomainCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchslowdomainCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GlitchslowdomainCtrl {
                    value: super::vals::GlitchslowdomainCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::GlitchslowdomainCtrlWriteprotection,
                    key: super::vals::GlitchslowdomainCtrlKey,
                }
                let proxy = GlitchslowdomainCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for slow domain glitch detectors enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct GlitchslowdomainStatus(pub u32);
        impl GlitchslowdomainStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for GlitchslowdomainStatus {
            #[inline(always)]
            fn default() -> GlitchslowdomainStatus {
                GlitchslowdomainStatus(0)
            }
        }
        impl core::fmt::Debug for GlitchslowdomainStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("GlitchslowdomainStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct GlitchslowdomainStatus {
                    error: bool,
                }
                let proxy = GlitchslowdomainStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TAMPER"]
            #[inline(always)]
            pub const fn tamper(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TAMPER"]
            #[inline(always)]
            pub fn set_tamper(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event WRITEERROR"]
            #[inline(always)]
            pub const fn writeerror(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITEERROR"]
            #[inline(always)]
            pub fn set_writeerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("tamper", &self.tamper())
                    .field("writeerror", &self.writeerror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    tamper: bool,
                    writeerror: bool,
                }
                let proxy = Int {
                    tamper: self.tamper(),
                    writeerror: self.writeerror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Control register for internal tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntresetenCtrl(pub u32);
        impl IntresetenCtrl {
            #[doc = "Set value of internal tamper reset enable signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::IntresetenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IntresetenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of internal tamper reset enable signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::IntresetenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::IntresetenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::IntresetenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::IntresetenCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::IntresetenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::IntresetenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::IntresetenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for IntresetenCtrl {
            #[inline(always)]
            fn default() -> IntresetenCtrl {
                IntresetenCtrl(0)
            }
        }
        impl core::fmt::Debug for IntresetenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntresetenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct IntresetenCtrl {
                    value: super::vals::IntresetenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::IntresetenCtrlWriteprotection,
                    key: super::vals::IntresetenCtrlKey,
                }
                let proxy = IntresetenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register for internal tamper reset enable signal."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct IntresetenStatus(pub u32);
        impl IntresetenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for IntresetenStatus {
            #[inline(always)]
            fn default() -> IntresetenStatus {
                IntresetenStatus(0)
            }
        }
        impl core::fmt::Debug for IntresetenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("IntresetenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct IntresetenStatus {
                    error: bool,
                }
                let proxy = IntresetenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Control register for non-invasive debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NidenCtrl(pub u32);
        impl NidenCtrl {
            #[doc = "Set value of niden signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::NidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::NidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of niden signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::NidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::NidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::NidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::NidenCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::NidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::NidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::NidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for NidenCtrl {
            #[inline(always)]
            fn default() -> NidenCtrl {
                NidenCtrl(0)
            }
        }
        impl core::fmt::Debug for NidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct NidenCtrl {
                    value: super::vals::NidenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::NidenCtrlWriteprotection,
                    key: super::vals::NidenCtrlKey,
                }
                let proxy = NidenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Status register for non-invasive debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct NidenStatus(pub u32);
        impl NidenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for NidenStatus {
            #[inline(always)]
            fn default() -> NidenStatus {
                NidenStatus(0)
            }
        }
        impl core::fmt::Debug for NidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("NidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct NidenStatus {
                    error: bool,
                }
                let proxy = NidenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Control register for secure priviliged invasive (halting) debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpidenCtrl(pub u32);
        impl SpidenCtrl {
            #[doc = "Set value of spiden signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::SpidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SpidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of spiden signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::SpidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::SpidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::SpidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::SpidenCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::SpidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::SpidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::SpidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for SpidenCtrl {
            #[inline(always)]
            fn default() -> SpidenCtrl {
                SpidenCtrl(0)
            }
        }
        impl core::fmt::Debug for SpidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SpidenCtrl {
                    value: super::vals::SpidenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::SpidenCtrlWriteprotection,
                    key: super::vals::SpidenCtrlKey,
                }
                let proxy = SpidenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Status register for secure priviliged invasive (halting) debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpidenStatus(pub u32);
        impl SpidenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SpidenStatus {
            #[inline(always)]
            fn default() -> SpidenStatus {
                SpidenStatus(0)
            }
        }
        impl core::fmt::Debug for SpidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SpidenStatus {
                    error: bool,
                }
                let proxy = SpidenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Control register for secure priviliged non-invasive debug enable for the local debug components within domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnidenCtrl(pub u32);
        impl SpnidenCtrl {
            #[doc = "Set value of spniden signal."]
            #[inline(always)]
            pub const fn value(&self) -> super::vals::SpnidenCtrlValue {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::SpnidenCtrlValue::from_bits(val as u8)
            }
            #[doc = "Set value of spniden signal."]
            #[inline(always)]
            pub fn set_value(&mut self, val: super::vals::SpnidenCtrlValue) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Lock this register to prevent changes to the VALUE field until next reset."]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub const fn writeprotection(&self) -> super::vals::SpnidenCtrlWriteprotection {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::SpnidenCtrlWriteprotection::from_bits(val as u8)
            }
            #[doc = "The write protection must be cleared to allow updates to the VALUE field."]
            #[inline(always)]
            pub fn set_writeprotection(&mut self, val: super::vals::SpnidenCtrlWriteprotection) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub const fn key(&self) -> super::vals::SpnidenCtrlKey {
                let val = (self.0 >> 16usize) & 0xffff;
                super::vals::SpnidenCtrlKey::from_bits(val as u16)
            }
            #[doc = "Required write key for upper 16 bits. Must be included in all register write operations."]
            #[inline(always)]
            pub fn set_key(&mut self, val: super::vals::SpnidenCtrlKey) {
                self.0 = (self.0 & !(0xffff << 16usize))
                    | (((val.to_bits() as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for SpnidenCtrl {
            #[inline(always)]
            fn default() -> SpnidenCtrl {
                SpnidenCtrl(0)
            }
        }
        impl core::fmt::Debug for SpnidenCtrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnidenCtrl")
                    .field("value", &self.value())
                    .field("lock", &self.lock())
                    .field("writeprotection", &self.writeprotection())
                    .field("key", &self.key())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenCtrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SpnidenCtrl {
                    value: super::vals::SpnidenCtrlValue,
                    lock: bool,
                    writeprotection: super::vals::SpnidenCtrlWriteprotection,
                    key: super::vals::SpnidenCtrlKey,
                }
                let proxy = SpnidenCtrl {
                    value: self.value(),
                    lock: self.lock(),
                    writeprotection: self.writeprotection(),
                    key: self.key(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Status register for secure priviliged non-invasive debug enable for domain n."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SpnidenStatus(pub u32);
        impl SpnidenStatus {
            #[doc = "Error detection status."]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Error detection status."]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for SpnidenStatus {
            #[inline(always)]
            fn default() -> SpnidenStatus {
                SpnidenStatus(0)
            }
        }
        impl core::fmt::Debug for SpnidenStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SpnidenStatus")
                    .field("error", &self.error())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SpnidenStatus {
                    error: bool,
                }
                let proxy = SpnidenStatus {
                    error: self.error(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The tamper controller status."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TampcStatus(pub u32);
        impl TampcStatus {
            #[doc = "Active shield detector detected an error."]
            #[inline(always)]
            pub const fn activeshield(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Active shield detector detected an error."]
            #[inline(always)]
            pub fn set_activeshield(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Error detected for the protected signals."]
            #[inline(always)]
            pub const fn protect(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Error detected for the protected signals."]
            #[inline(always)]
            pub fn set_protect(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "CRACEN detected an error."]
            #[inline(always)]
            pub const fn cracentamp(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "CRACEN detected an error."]
            #[inline(always)]
            pub fn set_cracentamp(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Slow domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub const fn glitchslowdomain(&self, n: usize) -> bool {
                assert!(n < 1usize);
                let offs = 8usize + n * 0usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Slow domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub fn set_glitchslowdomain(&mut self, n: usize, val: bool) {
                assert!(n < 1usize);
                let offs = 8usize + n * 0usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Fast domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub const fn glitchfastdomain(&self, n: usize) -> bool {
                assert!(n < 4usize);
                let offs = 12usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Fast domain glitch detector 0 detected an error."]
            #[inline(always)]
            pub fn set_glitchfastdomain(&mut self, n: usize, val: bool) {
                assert!(n < 4usize);
                let offs = 12usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for TampcStatus {
            #[inline(always)]
            fn default() -> TampcStatus {
                TampcStatus(0)
            }
        }
        impl core::fmt::Debug for TampcStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TampcStatus")
                    .field("activeshield", &self.activeshield())
                    .field("protect", &self.protect())
                    .field("cracentamp", &self.cracentamp())
                    .field("glitchslowdomain", &[self.glitchslowdomain(0usize)])
                    .field(
                        "glitchfastdomain",
                        &[
                            self.glitchfastdomain(0usize),
                            self.glitchfastdomain(1usize),
                            self.glitchfastdomain(2usize),
                            self.glitchfastdomain(3usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TampcStatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TampcStatus {
                    activeshield: bool,
                    protect: bool,
                    cracentamp: bool,
                    glitchslowdomain: [bool; 1usize],
                    glitchfastdomain: [bool; 4usize],
                }
                let proxy = TampcStatus {
                    activeshield: self.activeshield(),
                    protect: self.protect(),
                    cracentamp: self.cracentamp(),
                    glitchslowdomain: [self.glitchslowdomain(0usize)],
                    glitchfastdomain: [
                        self.glitchfastdomain(0usize),
                        self.glitchfastdomain(1usize),
                        self.glitchfastdomain(2usize),
                        self.glitchfastdomain(3usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ActiveshieldCtrlKey(pub u16);
        impl ActiveshieldCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ActiveshieldCtrlKey {
            pub const fn from_bits(val: u16) -> ActiveshieldCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ActiveshieldCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ActiveshieldCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ActiveshieldCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ActiveshieldCtrlKey {
                ActiveshieldCtrlKey::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlKey) -> u16 {
                ActiveshieldCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ActiveshieldCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ActiveshieldCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ActiveshieldCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ActiveshieldCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ActiveshieldCtrlValue {
                ActiveshieldCtrlValue::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlValue) -> u8 {
                ActiveshieldCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ActiveshieldCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ActiveshieldCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ActiveshieldCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ActiveshieldCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ActiveshieldCtrlWriteprotection {
                ActiveshieldCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ActiveshieldCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ActiveshieldCtrlWriteprotection) -> u8 {
                ActiveshieldCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApDbgenCtrlKey(pub u16);
        impl ApDbgenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ApDbgenCtrlKey {
            pub const fn from_bits(val: u16) -> ApDbgenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ApDbgenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApDbgenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ApDbgenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ApDbgenCtrlKey {
                ApDbgenCtrlKey::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlKey) -> u16 {
                ApDbgenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApDbgenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ApDbgenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ApDbgenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ApDbgenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ApDbgenCtrlValue {
                ApDbgenCtrlValue::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlValue) -> u8 {
                ApDbgenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ApDbgenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ApDbgenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ApDbgenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ApDbgenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ApDbgenCtrlWriteprotection {
                ApDbgenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ApDbgenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ApDbgenCtrlWriteprotection) -> u8 {
                ApDbgenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct CracentampCtrlKey(pub u16);
        impl CracentampCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl CracentampCtrlKey {
            pub const fn from_bits(val: u16) -> CracentampCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for CracentampCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for CracentampCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for CracentampCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> CracentampCtrlKey {
                CracentampCtrlKey::from_bits(val)
            }
        }
        impl From<CracentampCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: CracentampCtrlKey) -> u16 {
                CracentampCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CracentampCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl CracentampCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CracentampCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CracentampCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> CracentampCtrlValue {
                CracentampCtrlValue::from_bits(val)
            }
        }
        impl From<CracentampCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: CracentampCtrlValue) -> u8 {
                CracentampCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CracentampCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl CracentampCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CracentampCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CracentampCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> CracentampCtrlWriteprotection {
                CracentampCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<CracentampCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: CracentampCtrlWriteprotection) -> u8 {
                CracentampCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct DomainDbgenCtrlKey(pub u16);
        impl DomainDbgenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl DomainDbgenCtrlKey {
            pub const fn from_bits(val: u16) -> DomainDbgenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for DomainDbgenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for DomainDbgenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for DomainDbgenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> DomainDbgenCtrlKey {
                DomainDbgenCtrlKey::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlKey) -> u16 {
                DomainDbgenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DomainDbgenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl DomainDbgenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DomainDbgenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DomainDbgenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> DomainDbgenCtrlValue {
                DomainDbgenCtrlValue::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlValue) -> u8 {
                DomainDbgenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum DomainDbgenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl DomainDbgenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> DomainDbgenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for DomainDbgenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> DomainDbgenCtrlWriteprotection {
                DomainDbgenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<DomainDbgenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: DomainDbgenCtrlWriteprotection) -> u8 {
                DomainDbgenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectCtrlKey(pub u16);
        impl EraseprotectCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl EraseprotectCtrlKey {
            pub const fn from_bits(val: u16) -> EraseprotectCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for EraseprotectCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> EraseprotectCtrlKey {
                EraseprotectCtrlKey::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlKey) -> u16 {
                EraseprotectCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EraseprotectCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl EraseprotectCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EraseprotectCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EraseprotectCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> EraseprotectCtrlValue {
                EraseprotectCtrlValue::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlValue) -> u8 {
                EraseprotectCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum EraseprotectCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl EraseprotectCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> EraseprotectCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for EraseprotectCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> EraseprotectCtrlWriteprotection {
                EraseprotectCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<EraseprotectCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: EraseprotectCtrlWriteprotection) -> u8 {
                EraseprotectCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ExtresetenCtrlKey(pub u16);
        impl ExtresetenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl ExtresetenCtrlKey {
            pub const fn from_bits(val: u16) -> ExtresetenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for ExtresetenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ExtresetenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for ExtresetenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> ExtresetenCtrlKey {
                ExtresetenCtrlKey::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlKey) -> u16 {
                ExtresetenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtresetenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl ExtresetenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtresetenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtresetenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> ExtresetenCtrlValue {
                ExtresetenCtrlValue::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlValue) -> u8 {
                ExtresetenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ExtresetenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl ExtresetenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ExtresetenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ExtresetenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> ExtresetenCtrlWriteprotection {
                ExtresetenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<ExtresetenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: ExtresetenCtrlWriteprotection) -> u8 {
                ExtresetenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct GlitchfastdomainCtrlKey(pub u16);
        impl GlitchfastdomainCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl GlitchfastdomainCtrlKey {
            pub const fn from_bits(val: u16) -> GlitchfastdomainCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for GlitchfastdomainCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchfastdomainCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for GlitchfastdomainCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> GlitchfastdomainCtrlKey {
                GlitchfastdomainCtrlKey::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlKey) -> u16 {
                GlitchfastdomainCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchfastdomainCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl GlitchfastdomainCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchfastdomainCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchfastdomainCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> GlitchfastdomainCtrlValue {
                GlitchfastdomainCtrlValue::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlValue) -> u8 {
                GlitchfastdomainCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchfastdomainCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl GlitchfastdomainCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchfastdomainCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchfastdomainCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> GlitchfastdomainCtrlWriteprotection {
                GlitchfastdomainCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<GlitchfastdomainCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: GlitchfastdomainCtrlWriteprotection) -> u8 {
                GlitchfastdomainCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct GlitchslowdomainCtrlKey(pub u16);
        impl GlitchslowdomainCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl GlitchslowdomainCtrlKey {
            pub const fn from_bits(val: u16) -> GlitchslowdomainCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for GlitchslowdomainCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for GlitchslowdomainCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for GlitchslowdomainCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> GlitchslowdomainCtrlKey {
                GlitchslowdomainCtrlKey::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlKey) -> u16 {
                GlitchslowdomainCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchslowdomainCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl GlitchslowdomainCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchslowdomainCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchslowdomainCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> GlitchslowdomainCtrlValue {
                GlitchslowdomainCtrlValue::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlValue) -> u8 {
                GlitchslowdomainCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum GlitchslowdomainCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl GlitchslowdomainCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> GlitchslowdomainCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for GlitchslowdomainCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> GlitchslowdomainCtrlWriteprotection {
                GlitchslowdomainCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<GlitchslowdomainCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: GlitchslowdomainCtrlWriteprotection) -> u8 {
                GlitchslowdomainCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct IntresetenCtrlKey(pub u16);
        impl IntresetenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl IntresetenCtrlKey {
            pub const fn from_bits(val: u16) -> IntresetenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for IntresetenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for IntresetenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for IntresetenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> IntresetenCtrlKey {
                IntresetenCtrlKey::from_bits(val)
            }
        }
        impl From<IntresetenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: IntresetenCtrlKey) -> u16 {
                IntresetenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntresetenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl IntresetenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntresetenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntresetenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> IntresetenCtrlValue {
                IntresetenCtrlValue::from_bits(val)
            }
        }
        impl From<IntresetenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: IntresetenCtrlValue) -> u8 {
                IntresetenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IntresetenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl IntresetenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IntresetenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IntresetenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> IntresetenCtrlWriteprotection {
                IntresetenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<IntresetenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: IntresetenCtrlWriteprotection) -> u8 {
                IntresetenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct NidenCtrlKey(pub u16);
        impl NidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl NidenCtrlKey {
            pub const fn from_bits(val: u16) -> NidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for NidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for NidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for NidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> NidenCtrlKey {
                NidenCtrlKey::from_bits(val)
            }
        }
        impl From<NidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: NidenCtrlKey) -> u16 {
                NidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NidenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl NidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> NidenCtrlValue {
                NidenCtrlValue::from_bits(val)
            }
        }
        impl From<NidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: NidenCtrlValue) -> u8 {
                NidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum NidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl NidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> NidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for NidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> NidenCtrlWriteprotection {
                NidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<NidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: NidenCtrlWriteprotection) -> u8 {
                NidenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SpidenCtrlKey(pub u16);
        impl SpidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl SpidenCtrlKey {
            pub const fn from_bits(val: u16) -> SpidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for SpidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for SpidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> SpidenCtrlKey {
                SpidenCtrlKey::from_bits(val)
            }
        }
        impl From<SpidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: SpidenCtrlKey) -> u16 {
                SpidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpidenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl SpidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> SpidenCtrlValue {
                SpidenCtrlValue::from_bits(val)
            }
        }
        impl From<SpidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: SpidenCtrlValue) -> u8 {
                SpidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl SpidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> SpidenCtrlWriteprotection {
                SpidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<SpidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: SpidenCtrlWriteprotection) -> u8 {
                SpidenCtrlWriteprotection::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SpnidenCtrlKey(pub u16);
        impl SpnidenCtrlKey {
            #[doc = "Write key value."]
            pub const KEY: Self = Self(0x50fa);
        }
        impl SpnidenCtrlKey {
            pub const fn from_bits(val: u16) -> SpnidenCtrlKey {
                Self(val & 0xffff)
            }
            pub const fn to_bits(self) -> u16 {
                self.0
            }
        }
        impl core::fmt::Debug for SpnidenCtrlKey {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x50fa => f.write_str("KEY"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SpnidenCtrlKey {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x50fa => defmt::write!(f, "KEY"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u16> for SpnidenCtrlKey {
            #[inline(always)]
            fn from(val: u16) -> SpnidenCtrlKey {
                SpnidenCtrlKey::from_bits(val)
            }
        }
        impl From<SpnidenCtrlKey> for u16 {
            #[inline(always)]
            fn from(val: SpnidenCtrlKey) -> u16 {
                SpnidenCtrlKey::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpnidenCtrlValue {
            #[doc = "Signal is logic 0."]
            LOW = 0x0,
            #[doc = "Signal is logic 1."]
            HIGH = 0x01,
        }
        impl SpnidenCtrlValue {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpnidenCtrlValue {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpnidenCtrlValue {
            #[inline(always)]
            fn from(val: u8) -> SpnidenCtrlValue {
                SpnidenCtrlValue::from_bits(val)
            }
        }
        impl From<SpnidenCtrlValue> for u8 {
            #[inline(always)]
            fn from(val: SpnidenCtrlValue) -> u8 {
                SpnidenCtrlValue::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum SpnidenCtrlWriteprotection {
            #[doc = "Read: Write protection is disabled."]
            DISABLED = 0x0,
            #[doc = "Read: Write protection is enabled."]
            ENABLED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "Write: Value to clear write protection."]
            CLEAR = 0x0f,
        }
        impl SpnidenCtrlWriteprotection {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> SpnidenCtrlWriteprotection {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for SpnidenCtrlWriteprotection {
            #[inline(always)]
            fn from(val: u8) -> SpnidenCtrlWriteprotection {
                SpnidenCtrlWriteprotection::from_bits(val)
            }
        }
        impl From<SpnidenCtrlWriteprotection> for u8 {
            #[inline(always)]
            fn from(val: SpnidenCtrlWriteprotection) -> u8 {
                SpnidenCtrlWriteprotection::to_bits(val)
            }
        }
    }
}
pub mod temp {
    #[doc = "Temperature Sensor 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Temp {
        ptr: *mut u8,
    }
    unsafe impl Send for Temp {}
    unsafe impl Sync for Temp {}
    impl Temp {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start temperature measurement"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop temperature measurement"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Temperature measurement complete, data ready"]
        #[inline(always)]
        pub const fn events_datardy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Publish configuration for event DATARDY"]
        #[inline(always)]
        pub const fn publish_datardy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Temperature in degC (0.25deg steps)"]
        #[inline(always)]
        pub const fn temp(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Slope of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn a(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize + n * 4usize) as _) }
        }
        #[doc = "y-intercept of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn b(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize + n * 4usize) as _) }
        }
        #[doc = "End point of 1st piece wise linear function"]
        #[inline(always)]
        pub const fn t(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 6usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0560usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event DATARDY"]
            #[inline(always)]
            pub const fn datardy(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event DATARDY"]
            #[inline(always)]
            pub fn set_datardy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("datardy", &self.datardy())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    datardy: bool,
                }
                let proxy = Int {
                    datardy: self.datardy(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
}
pub mod timer {
    #[doc = "Timer/Counter 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Timer {
        ptr: *mut u8,
    }
    unsafe impl Send for Timer {}
    unsafe impl Sync for Timer {}
    impl Timer {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start Timer"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop Timer"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Increment Timer (Counter mode only)"]
        #[inline(always)]
        pub const fn tasks_count(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Clear time"]
        #[inline(always)]
        pub const fn tasks_clear(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Deprecated register - Shut down timer"]
        #[inline(always)]
        pub const fn tasks_shutdown(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Description collection: Capture Timer value to CC\\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_capture(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize + n * 4usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task COUNT"]
        #[inline(always)]
        pub const fn subscribe_count(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x88usize) as _) }
        }
        #[doc = "Subscribe configuration for task CLEAR"]
        #[inline(always)]
        pub const fn subscribe_clear(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Deprecated register - Subscribe configuration for task SHUTDOWN"]
        #[inline(always)]
        pub const fn subscribe_shutdown(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task CAPTURE\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_capture(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Compare event on CC\\[n\\] match"]
        #[inline(always)]
        pub const fn events_compare(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event COMPARE\\[n\\]"]
        #[inline(always)]
        pub const fn publish_compare(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize + n * 4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Timer mode selection"]
        #[inline(always)]
        pub const fn mode(self) -> crate::common::Reg<regs::Mode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Configure the number of bits used by the TIMER"]
        #[inline(always)]
        pub const fn bitmode(self) -> crate::common::Reg<regs::Bitmode, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Timer prescaler register"]
        #[inline(always)]
        pub const fn prescaler(self) -> crate::common::Reg<regs::Prescaler, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0510usize) as _) }
        }
        #[doc = "Description collection: Capture/Compare register n"]
        #[inline(always)]
        pub const fn cc(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0540usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[inline(always)]
        pub const fn oneshoten(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Oneshoten, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0580usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configure the number of bits used by the TIMER"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bitmode(pub u32);
        impl Bitmode {
            #[doc = "Timer bit width"]
            #[inline(always)]
            pub const fn bitmode(&self) -> super::vals::Bitmode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Bitmode::from_bits(val as u8)
            }
            #[doc = "Timer bit width"]
            #[inline(always)]
            pub fn set_bitmode(&mut self, val: super::vals::Bitmode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Bitmode {
            #[inline(always)]
            fn default() -> Bitmode {
                Bitmode(0)
            }
        }
        impl core::fmt::Debug for Bitmode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bitmode")
                    .field("bitmode", &self.bitmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bitmode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Bitmode {
                    bitmode: super::vals::Bitmode,
                }
                let proxy = Bitmode {
                    bitmode: self.bitmode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub const fn compare(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event COMPARE\\[0\\]"]
            #[inline(always)]
            pub fn set_compare(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field(
                        "compare",
                        &[
                            self.compare(0usize),
                            self.compare(1usize),
                            self.compare(2usize),
                            self.compare(3usize),
                            self.compare(4usize),
                            self.compare(5usize),
                            self.compare(6usize),
                            self.compare(7usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    compare: [bool; 8usize],
                }
                let proxy = Int {
                    compare: [
                        self.compare(0usize),
                        self.compare(1usize),
                        self.compare(2usize),
                        self.compare(3usize),
                        self.compare(4usize),
                        self.compare(5usize),
                        self.compare(6usize),
                        self.compare(7usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Timer mode selection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Mode(pub u32);
        impl Mode {
            #[doc = "Timer mode"]
            #[inline(always)]
            pub const fn mode(&self) -> super::vals::Mode {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Mode::from_bits(val as u8)
            }
            #[doc = "Timer mode"]
            #[inline(always)]
            pub fn set_mode(&mut self, val: super::vals::Mode) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
        }
        impl Default for Mode {
            #[inline(always)]
            fn default() -> Mode {
                Mode(0)
            }
        }
        impl core::fmt::Debug for Mode {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Mode").field("mode", &self.mode()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Mode {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Mode {
                    mode: super::vals::Mode,
                }
                let proxy = Mode { mode: self.mode() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Enable one-shot operation for Capture/Compare channel n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Oneshoten(pub u32);
        impl Oneshoten {
            #[doc = "Enable one-shot operation"]
            #[inline(always)]
            pub const fn oneshoten(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable one-shot operation"]
            #[inline(always)]
            pub fn set_oneshoten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Oneshoten {
            #[inline(always)]
            fn default() -> Oneshoten {
                Oneshoten(0)
            }
        }
        impl core::fmt::Debug for Oneshoten {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Oneshoten")
                    .field("oneshoten", &self.oneshoten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Oneshoten {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Oneshoten {
                    oneshoten: bool,
                }
                let proxy = Oneshoten {
                    oneshoten: self.oneshoten(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Timer prescaler register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Prescaler(pub u32);
        impl Prescaler {
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub const fn prescaler(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Prescaler value"]
            #[inline(always)]
            pub fn set_prescaler(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Prescaler {
            #[inline(always)]
            fn default() -> Prescaler {
                Prescaler(0)
            }
        }
        impl core::fmt::Debug for Prescaler {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Prescaler")
                    .field("prescaler", &self.prescaler())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Prescaler {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Prescaler {
                    prescaler: u8,
                }
                let proxy = Prescaler {
                    prescaler: self.prescaler(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub const fn compare_clear(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task CLEAR"]
            #[inline(always)]
            pub fn set_compare_clear(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[inline(always)]
            pub const fn compare_stop(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event COMPARE\\[0\\] and task STOP"]
            #[inline(always)]
            pub fn set_compare_stop(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 16usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field(
                        "compare_clear",
                        &[
                            self.compare_clear(0usize),
                            self.compare_clear(1usize),
                            self.compare_clear(2usize),
                            self.compare_clear(3usize),
                            self.compare_clear(4usize),
                            self.compare_clear(5usize),
                            self.compare_clear(6usize),
                            self.compare_clear(7usize),
                        ],
                    )
                    .field(
                        "compare_stop",
                        &[
                            self.compare_stop(0usize),
                            self.compare_stop(1usize),
                            self.compare_stop(2usize),
                            self.compare_stop(3usize),
                            self.compare_stop(4usize),
                            self.compare_stop(5usize),
                            self.compare_stop(6usize),
                            self.compare_stop(7usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    compare_clear: [bool; 8usize],
                    compare_stop: [bool; 8usize],
                }
                let proxy = Shorts {
                    compare_clear: [
                        self.compare_clear(0usize),
                        self.compare_clear(1usize),
                        self.compare_clear(2usize),
                        self.compare_clear(3usize),
                        self.compare_clear(4usize),
                        self.compare_clear(5usize),
                        self.compare_clear(6usize),
                        self.compare_clear(7usize),
                    ],
                    compare_stop: [
                        self.compare_stop(0usize),
                        self.compare_stop(1usize),
                        self.compare_stop(2usize),
                        self.compare_stop(3usize),
                        self.compare_stop(4usize),
                        self.compare_stop(5usize),
                        self.compare_stop(6usize),
                        self.compare_stop(7usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Bitmode {
            #[doc = "16 bit timer bit width"]
            _16BIT = 0x0,
            #[doc = "8 bit timer bit width"]
            _08BIT = 0x01,
            #[doc = "24 bit timer bit width"]
            _24BIT = 0x02,
            #[doc = "32 bit timer bit width"]
            _32BIT = 0x03,
        }
        impl Bitmode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Bitmode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Bitmode {
            #[inline(always)]
            fn from(val: u8) -> Bitmode {
                Bitmode::from_bits(val)
            }
        }
        impl From<Bitmode> for u8 {
            #[inline(always)]
            fn from(val: Bitmode) -> u8 {
                Bitmode::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Mode {
            #[doc = "Select Timer mode"]
            TIMER = 0x0,
            #[doc = "Deprecated enumerator - Select Counter mode"]
            COUNTER = 0x01,
            #[doc = "Select Low Power Counter mode"]
            LOW_POWER_COUNTER = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Mode {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Mode {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Mode {
            #[inline(always)]
            fn from(val: u8) -> Mode {
                Mode::from_bits(val)
            }
        }
        impl From<Mode> for u8 {
            #[inline(always)]
            fn from(val: Mode) -> u8 {
                Mode::to_bits(val)
            }
        }
    }
}
pub mod tpiu {
    #[doc = "Trace Port Interface Unit"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Tpiu {
        ptr: *mut u8,
    }
    unsafe impl Send for Tpiu {}
    unsafe impl Sync for Tpiu {}
    impl Tpiu {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Each bit location is a single port size that is supported on the device."]
        #[inline(always)]
        pub const fn supportedportsizes(
            self,
        ) -> crate::common::Reg<regs::Supportedportsizes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Each bit location is a single port size. One bit can be set, and indicates the current port size."]
        #[inline(always)]
        pub const fn currentportsize(
            self,
        ) -> crate::common::Reg<regs::Currentportsize, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "The Supported_trigger_modes register indicates the implemented trigger counter multipliers and other supported features of the trigger system."]
        #[inline(always)]
        pub const fn supportedtriggermodes(
            self,
        ) -> crate::common::Reg<regs::Supportedtriggermodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "The Trigger_counter_value register enables delaying the indication of triggers to any external connected trace capture or storage devices."]
        #[inline(always)]
        pub const fn triggercountervalue(
            self,
        ) -> crate::common::Reg<regs::Triggercountervalue, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "The Trigger_multiplier register contains the selectors for the trigger counter multiplier."]
        #[inline(always)]
        pub const fn triggermultiplier(
            self,
        ) -> crate::common::Reg<regs::Triggermultiplier, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0108usize) as _) }
        }
        #[doc = "The Supported_test_pattern_modes register provides a set of known bit sequences or patterns that can be output over the trace port and can be detected by the TPA or other associated trace capture device."]
        #[inline(always)]
        pub const fn suppportedtestpatternmodes(
            self,
        ) -> crate::common::Reg<regs::Suppportedtestpatternmodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Current_test_pattern_mode indicates the current test pattern or mode selected."]
        #[inline(always)]
        pub const fn currenttestpatternmodes(
            self,
        ) -> crate::common::Reg<regs::Currenttestpatternmodes, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0204usize) as _) }
        }
        #[doc = "The TPRCR register is an 8-bit counter start value that is decremented. A write sets the initial counter value and a read returns the programmed value."]
        #[inline(always)]
        pub const fn tprcr(self) -> crate::common::Reg<regs::Tprcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0208usize) as _) }
        }
        #[doc = "The FFSR register indicates the current status of the formatter and flush features available in the TPIU."]
        #[inline(always)]
        pub const fn ffsr(self) -> crate::common::Reg<regs::Ffsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "The FFCR register controls the generation of stop, trigger, and flush events."]
        #[inline(always)]
        pub const fn ffcr(self) -> crate::common::Reg<regs::Ffcr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "The FSCR register enables the frequency of synchronization information to be optimized to suit the Trace Port Analyzer (TPA) capture buffer size."]
        #[inline(always)]
        pub const fn fscr(self) -> crate::common::Reg<regs::Fscr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high-speed trace port solution."]
        #[inline(always)]
        pub const fn extctlinport(
            self,
        ) -> crate::common::Reg<regs::Extctlinport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high speed trace port solution. These ports are raw register banks that sample or export the corresponding external pins."]
        #[inline(always)]
        pub const fn extctloutport(
            self,
        ) -> crate::common::Reg<regs::Extctloutport, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "The ITTRFLINACK register enables control of the triginack and flushinack outputs from the TPIU."]
        #[inline(always)]
        pub const fn ittrflinack(self) -> crate::common::Reg<regs::Ittrflinack, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ee4usize) as _) }
        }
        #[doc = "The ITTRFLIN register contains the values of the flushin and trigin inputs to the TPIU."]
        #[inline(always)]
        pub const fn ittrflin(self) -> crate::common::Reg<regs::Ittrflin, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ee8usize) as _) }
        }
        #[doc = "The ITATBDATA0 register contains the value of the atdatas inputs to the TPIU. The values are valid only when atvalids is HIGH."]
        #[inline(always)]
        pub const fn itatbdata0(self) -> crate::common::Reg<regs::Itatbdata0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0eecusize) as _) }
        }
        #[doc = "Enables control of the atreadys and afvalids outputs of the TPIU."]
        #[inline(always)]
        pub const fn itatbctr2(self) -> crate::common::Reg<regs::Itatbctr2, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef0usize) as _) }
        }
        #[doc = "The ITATBCTR1 register contains the value of the atids input to the TPIU. This is only valid when atvalids is HIGH."]
        #[inline(always)]
        pub const fn itatbctr1(self) -> crate::common::Reg<regs::Itatbctr1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef4usize) as _) }
        }
        #[doc = "The ITATBCTR0 register captures the values of the atvalids, afreadys, and atbytess inputs to the TPIU. To ensure the integration registers work correctly in a system, the value of atbytess is only valid when atvalids, bit\\[0\\], is HIGH."]
        #[inline(always)]
        pub const fn itatbctr0(self) -> crate::common::Reg<regs::Itatbctr0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ef8usize) as _) }
        }
        #[doc = "Used to enable topology detection. This register enables the component to switch from a functional mode, the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for integration testing and topology solving."]
        #[inline(always)]
        pub const fn itctrl(self) -> crate::common::Reg<regs::Itctrl, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0f00usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[inline(always)]
        pub const fn claimset(self) -> crate::common::Reg<regs::Claimset, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa0usize) as _) }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[inline(always)]
        pub const fn claimclr(self) -> crate::common::Reg<regs::Claimclr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fa4usize) as _) }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[inline(always)]
        pub const fn lar(self) -> crate::common::Reg<regs::Lar, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb0usize) as _) }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[inline(always)]
        pub const fn lsr(self) -> crate::common::Reg<regs::Lsr, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb4usize) as _) }
        }
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[inline(always)]
        pub const fn authstatus(self) -> crate::common::Reg<regs::Authstatus, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fb8usize) as _) }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[inline(always)]
        pub const fn devid(self) -> crate::common::Reg<regs::Devid, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fc8usize) as _) }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[inline(always)]
        pub const fn devtype(self) -> crate::common::Reg<regs::Devtype, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fccusize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr4(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fd0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fe0usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fe4usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fe8usize) as _) }
        }
        #[doc = "Coresight peripheral identification registers."]
        #[inline(always)]
        pub const fn pidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0fecusize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff0usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff4usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ff8usize) as _) }
        }
        #[doc = "Coresight component identification registers."]
        #[inline(always)]
        pub const fn cidr_3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0ffcusize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Indicates the current level of tracing permitted by the system"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Authstatus(pub u32);
        impl Authstatus {
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub const fn nsid(&self) -> super::vals::Nsid {
                let val = (self.0 >> 0usize) & 0x03;
                super::vals::Nsid::from_bits(val as u8)
            }
            #[doc = "Non-secure Invasive Debug"]
            #[inline(always)]
            pub fn set_nsid(&mut self, val: super::vals::Nsid) {
                self.0 = (self.0 & !(0x03 << 0usize)) | (((val.to_bits() as u32) & 0x03) << 0usize);
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn nsnid(&self) -> super::vals::Nsnid {
                let val = (self.0 >> 2usize) & 0x03;
                super::vals::Nsnid::from_bits(val as u8)
            }
            #[doc = "Non-secure Non-Invasive Debug"]
            #[inline(always)]
            pub fn set_nsnid(&mut self, val: super::vals::Nsnid) {
                self.0 = (self.0 & !(0x03 << 2usize)) | (((val.to_bits() as u32) & 0x03) << 2usize);
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub const fn sid(&self) -> super::vals::Sid {
                let val = (self.0 >> 4usize) & 0x03;
                super::vals::Sid::from_bits(val as u8)
            }
            #[doc = "Secure Invasive Debug"]
            #[inline(always)]
            pub fn set_sid(&mut self, val: super::vals::Sid) {
                self.0 = (self.0 & !(0x03 << 4usize)) | (((val.to_bits() as u32) & 0x03) << 4usize);
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub const fn snid(&self) -> super::vals::Snid {
                let val = (self.0 >> 6usize) & 0x03;
                super::vals::Snid::from_bits(val as u8)
            }
            #[doc = "Secure Non-Invasive Debug"]
            #[inline(always)]
            pub fn set_snid(&mut self, val: super::vals::Snid) {
                self.0 = (self.0 & !(0x03 << 6usize)) | (((val.to_bits() as u32) & 0x03) << 6usize);
            }
        }
        impl Default for Authstatus {
            #[inline(always)]
            fn default() -> Authstatus {
                Authstatus(0)
            }
        }
        impl core::fmt::Debug for Authstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Authstatus")
                    .field("nsid", &self.nsid())
                    .field("nsnid", &self.nsnid())
                    .field("sid", &self.sid())
                    .field("snid", &self.snid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Authstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Authstatus {
                    nsid: super::vals::Nsid,
                    nsnid: super::vals::Nsnid,
                    sid: super::vals::Sid,
                    snid: super::vals::Snid,
                }
                let proxy = Authstatus {
                    nsid: self.nsid(),
                    nsnid: self.nsnid(),
                    sid: self.sid(),
                    snid: self.snid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMCLR register sets the bits in the claim tag to 0 and determines the current value of the claim tag."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimclr(pub u32);
        impl Claimclr {
            #[doc = "Read or clear claim bit 0."]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimclrBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimclrBit0::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 0."]
            #[inline(always)]
            pub fn set_bit_0(&mut self, val: super::vals::ClaimclrBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Read or clear claim bit 1."]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimclrBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimclrBit1::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 1."]
            #[inline(always)]
            pub fn set_bit_1(&mut self, val: super::vals::ClaimclrBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Read or clear claim bit 2."]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimclrBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimclrBit2::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 2."]
            #[inline(always)]
            pub fn set_bit_2(&mut self, val: super::vals::ClaimclrBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Read or clear claim bit 3."]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimclrBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimclrBit3::from_bits(val as u8)
            }
            #[doc = "Read or clear claim bit 3."]
            #[inline(always)]
            pub fn set_bit_3(&mut self, val: super::vals::ClaimclrBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimclr {
            #[inline(always)]
            fn default() -> Claimclr {
                Claimclr(0)
            }
        }
        impl core::fmt::Debug for Claimclr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimclr")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimclr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Claimclr {
                    bit_0: super::vals::ClaimclrBit0,
                    bit_1: super::vals::ClaimclrBit1,
                    bit_2: super::vals::ClaimclrBit2,
                    bit_3: super::vals::ClaimclrBit3,
                }
                let proxy = Claimclr {
                    bit_0: self.bit_0(),
                    bit_1: self.bit_1(),
                    bit_2: self.bit_2(),
                    bit_3: self.bit_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Software can use the claim tag to coordinate application and debugger access to trace unit functionality. The claim tags have no effect on the operation of the component. The CLAIMSET register sets bits in the claim tag, and determines the number of claim bits implemented."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Claimset(pub u32);
        impl Claimset {
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn bit_0(&self) -> super::vals::ClaimsetBit0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::ClaimsetBit0::from_bits(val as u8)
            }
            #[doc = "Set claim bit 0 and check if bit is implemented or not."]
            #[inline(always)]
            pub fn set_bit_0(&mut self, val: super::vals::ClaimsetBit0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn bit_1(&self) -> super::vals::ClaimsetBit1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::ClaimsetBit1::from_bits(val as u8)
            }
            #[doc = "Set claim bit 1 and check if bit is implemented or not."]
            #[inline(always)]
            pub fn set_bit_1(&mut self, val: super::vals::ClaimsetBit1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn bit_2(&self) -> super::vals::ClaimsetBit2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::ClaimsetBit2::from_bits(val as u8)
            }
            #[doc = "Set claim bit 2 and check if bit is implemented or not."]
            #[inline(always)]
            pub fn set_bit_2(&mut self, val: super::vals::ClaimsetBit2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[inline(always)]
            pub const fn bit_3(&self) -> super::vals::ClaimsetBit3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::ClaimsetBit3::from_bits(val as u8)
            }
            #[doc = "Set claim bit 3 and check if bit is implemented or not."]
            #[inline(always)]
            pub fn set_bit_3(&mut self, val: super::vals::ClaimsetBit3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Claimset {
            #[inline(always)]
            fn default() -> Claimset {
                Claimset(0)
            }
        }
        impl core::fmt::Debug for Claimset {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Claimset")
                    .field("bit_0", &self.bit_0())
                    .field("bit_1", &self.bit_1())
                    .field("bit_2", &self.bit_2())
                    .field("bit_3", &self.bit_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Claimset {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Claimset {
                    bit_0: super::vals::ClaimsetBit0,
                    bit_1: super::vals::ClaimsetBit1,
                    bit_2: super::vals::ClaimsetBit2,
                    bit_3: super::vals::ClaimsetBit3,
                }
                let proxy = Claimset {
                    bit_0: self.bit_0(),
                    bit_1: self.bit_1(),
                    bit_2: self.bit_2(),
                    bit_3: self.bit_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Each bit location is a single port size. One bit can be set, and indicates the current port size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currentportsize(pub u32);
        impl Currentportsize {
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_5(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_6(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_7(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_8(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_9(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_10(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_11(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_12(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_13(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_14(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_15(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_16(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_17(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_18(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_19(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_20(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_21(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_22(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_23(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_24(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_25(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_26(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_27(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_28(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_29(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_30(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_31(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub const fn port_size_32(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates which port size is currently selected."]
            #[inline(always)]
            pub fn set_port_size_32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Currentportsize {
            #[inline(always)]
            fn default() -> Currentportsize {
                Currentportsize(0)
            }
        }
        impl core::fmt::Debug for Currentportsize {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currentportsize")
                    .field("port_size_1", &self.port_size_1())
                    .field("port_size_2", &self.port_size_2())
                    .field("port_size_3", &self.port_size_3())
                    .field("port_size_4", &self.port_size_4())
                    .field("port_size_5", &self.port_size_5())
                    .field("port_size_6", &self.port_size_6())
                    .field("port_size_7", &self.port_size_7())
                    .field("port_size_8", &self.port_size_8())
                    .field("port_size_9", &self.port_size_9())
                    .field("port_size_10", &self.port_size_10())
                    .field("port_size_11", &self.port_size_11())
                    .field("port_size_12", &self.port_size_12())
                    .field("port_size_13", &self.port_size_13())
                    .field("port_size_14", &self.port_size_14())
                    .field("port_size_15", &self.port_size_15())
                    .field("port_size_16", &self.port_size_16())
                    .field("port_size_17", &self.port_size_17())
                    .field("port_size_18", &self.port_size_18())
                    .field("port_size_19", &self.port_size_19())
                    .field("port_size_20", &self.port_size_20())
                    .field("port_size_21", &self.port_size_21())
                    .field("port_size_22", &self.port_size_22())
                    .field("port_size_23", &self.port_size_23())
                    .field("port_size_24", &self.port_size_24())
                    .field("port_size_25", &self.port_size_25())
                    .field("port_size_26", &self.port_size_26())
                    .field("port_size_27", &self.port_size_27())
                    .field("port_size_28", &self.port_size_28())
                    .field("port_size_29", &self.port_size_29())
                    .field("port_size_30", &self.port_size_30())
                    .field("port_size_31", &self.port_size_31())
                    .field("port_size_32", &self.port_size_32())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currentportsize {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Currentportsize {
                    port_size_1: bool,
                    port_size_2: bool,
                    port_size_3: bool,
                    port_size_4: bool,
                    port_size_5: bool,
                    port_size_6: bool,
                    port_size_7: bool,
                    port_size_8: bool,
                    port_size_9: bool,
                    port_size_10: bool,
                    port_size_11: bool,
                    port_size_12: bool,
                    port_size_13: bool,
                    port_size_14: bool,
                    port_size_15: bool,
                    port_size_16: bool,
                    port_size_17: bool,
                    port_size_18: bool,
                    port_size_19: bool,
                    port_size_20: bool,
                    port_size_21: bool,
                    port_size_22: bool,
                    port_size_23: bool,
                    port_size_24: bool,
                    port_size_25: bool,
                    port_size_26: bool,
                    port_size_27: bool,
                    port_size_28: bool,
                    port_size_29: bool,
                    port_size_30: bool,
                    port_size_31: bool,
                    port_size_32: bool,
                }
                let proxy = Currentportsize {
                    port_size_1: self.port_size_1(),
                    port_size_2: self.port_size_2(),
                    port_size_3: self.port_size_3(),
                    port_size_4: self.port_size_4(),
                    port_size_5: self.port_size_5(),
                    port_size_6: self.port_size_6(),
                    port_size_7: self.port_size_7(),
                    port_size_8: self.port_size_8(),
                    port_size_9: self.port_size_9(),
                    port_size_10: self.port_size_10(),
                    port_size_11: self.port_size_11(),
                    port_size_12: self.port_size_12(),
                    port_size_13: self.port_size_13(),
                    port_size_14: self.port_size_14(),
                    port_size_15: self.port_size_15(),
                    port_size_16: self.port_size_16(),
                    port_size_17: self.port_size_17(),
                    port_size_18: self.port_size_18(),
                    port_size_19: self.port_size_19(),
                    port_size_20: self.port_size_20(),
                    port_size_21: self.port_size_21(),
                    port_size_22: self.port_size_22(),
                    port_size_23: self.port_size_23(),
                    port_size_24: self.port_size_24(),
                    port_size_25: self.port_size_25(),
                    port_size_26: self.port_size_26(),
                    port_size_27: self.port_size_27(),
                    port_size_28: self.port_size_28(),
                    port_size_29: self.port_size_29(),
                    port_size_30: self.port_size_30(),
                    port_size_31: self.port_size_31(),
                    port_size_32: self.port_size_32(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Current_test_pattern_mode indicates the current test pattern or mode selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Currenttestpatternmodes(pub u32);
        impl Currenttestpatternmodes {
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn patw1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_patw1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn patw0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_patw0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn pata5(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_pata5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn patf0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_patf0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub const fn ptimeen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub fn set_ptimeen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub const fn pconten(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub fn set_pconten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Currenttestpatternmodes {
            #[inline(always)]
            fn default() -> Currenttestpatternmodes {
                Currenttestpatternmodes(0)
            }
        }
        impl core::fmt::Debug for Currenttestpatternmodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Currenttestpatternmodes")
                    .field("patw1", &self.patw1())
                    .field("patw0", &self.patw0())
                    .field("pata5", &self.pata5())
                    .field("patf0", &self.patf0())
                    .field("ptimeen", &self.ptimeen())
                    .field("pconten", &self.pconten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Currenttestpatternmodes {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Currenttestpatternmodes {
                    patw1: bool,
                    patw0: bool,
                    pata5: bool,
                    patf0: bool,
                    ptimeen: bool,
                    pconten: bool,
                }
                let proxy = Currenttestpatternmodes {
                    patw1: self.patw1(),
                    patw0: self.patw0(),
                    pata5: self.pata5(),
                    patf0: self.patf0(),
                    ptimeen: self.ptimeen(),
                    pconten: self.pconten(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Indicates the capabilities of the component."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devid(pub u32);
        impl Devid {
            #[doc = "Indicates the hidden level of input multiplexing. When non-zero, this value indicates the type of multiplexing on the input to the ATB. Currently only 0x00 is supported, that is, no multiplexing is present. This value helps detect the ATB structure."]
            #[inline(always)]
            pub const fn muxnum(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x1f;
                val as u8
            }
            #[doc = "Indicates the hidden level of input multiplexing. When non-zero, this value indicates the type of multiplexing on the input to the ATB. Currently only 0x00 is supported, that is, no multiplexing is present. This value helps detect the ATB structure."]
            #[inline(always)]
            pub fn set_muxnum(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 0usize)) | (((val as u32) & 0x1f) << 0usize);
            }
            #[doc = "Indicates the relationship between atclk and traceclkin."]
            #[inline(always)]
            pub const fn clkrelat(&self) -> super::vals::Clkrelat {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Clkrelat::from_bits(val as u8)
            }
            #[doc = "Indicates the relationship between atclk and traceclkin."]
            #[inline(always)]
            pub fn set_clkrelat(&mut self, val: super::vals::Clkrelat) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "FIFO size in powers of 2."]
            #[inline(always)]
            pub const fn fifosize(&self) -> super::vals::Fifosize {
                let val = (self.0 >> 6usize) & 0x07;
                super::vals::Fifosize::from_bits(val as u8)
            }
            #[doc = "FIFO size in powers of 2."]
            #[inline(always)]
            pub fn set_fifosize(&mut self, val: super::vals::Fifosize) {
                self.0 = (self.0 & !(0x07 << 6usize)) | (((val.to_bits() as u32) & 0x07) << 6usize);
            }
            #[doc = "Indicates whether trace clock plus data is supported."]
            #[inline(always)]
            pub const fn tclkdata(&self) -> super::vals::Tclkdata {
                let val = (self.0 >> 9usize) & 0x01;
                super::vals::Tclkdata::from_bits(val as u8)
            }
            #[doc = "Indicates whether trace clock plus data is supported."]
            #[inline(always)]
            pub fn set_tclkdata(&mut self, val: super::vals::Tclkdata) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val.to_bits() as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether Serial Wire Output, Manchester encoded format, is supported."]
            #[inline(always)]
            pub const fn swoman(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether Serial Wire Output, Manchester encoded format, is supported."]
            #[inline(always)]
            pub fn set_swoman(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether Serial Wire Output, UART or NRZ, is supported."]
            #[inline(always)]
            pub const fn swouartnrz(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether Serial Wire Output, UART or NRZ, is supported."]
            #[inline(always)]
            pub fn set_swouartnrz(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
        }
        impl Default for Devid {
            #[inline(always)]
            fn default() -> Devid {
                Devid(0)
            }
        }
        impl core::fmt::Debug for Devid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devid")
                    .field("muxnum", &self.muxnum())
                    .field("clkrelat", &self.clkrelat())
                    .field("fifosize", &self.fifosize())
                    .field("tclkdata", &self.tclkdata())
                    .field("swoman", &self.swoman())
                    .field("swouartnrz", &self.swouartnrz())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devid {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Devid {
                    muxnum: u8,
                    clkrelat: super::vals::Clkrelat,
                    fifosize: super::vals::Fifosize,
                    tclkdata: super::vals::Tclkdata,
                    swoman: bool,
                    swouartnrz: bool,
                }
                let proxy = Devid {
                    muxnum: self.muxnum(),
                    clkrelat: self.clkrelat(),
                    fifosize: self.fifosize(),
                    tclkdata: self.tclkdata(),
                    swoman: self.swoman(),
                    swouartnrz: self.swouartnrz(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The DEVTYPE register provides a debugger with information about the component when the Part Number field is not recognized. The debugger can then report this information."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Devtype(pub u32);
        impl Devtype {
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub const fn major(&self) -> super::vals::Major {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Major::from_bits(val as u8)
            }
            #[doc = "The main type of the component"]
            #[inline(always)]
            pub fn set_major(&mut self, val: super::vals::Major) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub const fn sub(&self) -> super::vals::Sub {
                let val = (self.0 >> 4usize) & 0x0f;
                super::vals::Sub::from_bits(val as u8)
            }
            #[doc = "The sub-type of the component"]
            #[inline(always)]
            pub fn set_sub(&mut self, val: super::vals::Sub) {
                self.0 = (self.0 & !(0x0f << 4usize)) | (((val.to_bits() as u32) & 0x0f) << 4usize);
            }
        }
        impl Default for Devtype {
            #[inline(always)]
            fn default() -> Devtype {
                Devtype(0)
            }
        }
        impl core::fmt::Debug for Devtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Devtype")
                    .field("major", &self.major())
                    .field("sub", &self.sub())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Devtype {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Devtype {
                    major: super::vals::Major,
                    sub: super::vals::Sub,
                }
                let proxy = Devtype {
                    major: self.major(),
                    sub: self.sub(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high-speed trace port solution."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extctlinport(pub u32);
        impl Extctlinport {
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_0(&self) -> super::vals::Extctlin0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Extctlin0::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_0(&mut self, val: super::vals::Extctlin0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_1(&self) -> super::vals::Extctlin1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Extctlin1::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_1(&mut self, val: super::vals::Extctlin1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_2(&self) -> super::vals::Extctlin2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Extctlin2::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_2(&mut self, val: super::vals::Extctlin2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_3(&self) -> super::vals::Extctlin3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Extctlin3::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_3(&mut self, val: super::vals::Extctlin3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_4(&self) -> super::vals::Extctlin4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Extctlin4::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_4(&mut self, val: super::vals::Extctlin4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_5(&self) -> super::vals::Extctlin5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Extctlin5::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_5(&mut self, val: super::vals::Extctlin5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_6(&self) -> super::vals::Extctlin6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Extctlin6::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_6(&mut self, val: super::vals::Extctlin6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub const fn extctlin_7(&self) -> super::vals::Extctlin7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Extctlin7::from_bits(val as u8)
            }
            #[doc = "EXTCTL inputs."]
            #[inline(always)]
            pub fn set_extctlin_7(&mut self, val: super::vals::Extctlin7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Extctlinport {
            #[inline(always)]
            fn default() -> Extctlinport {
                Extctlinport(0)
            }
        }
        impl core::fmt::Debug for Extctlinport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extctlinport")
                    .field("extctlin_0", &self.extctlin_0())
                    .field("extctlin_1", &self.extctlin_1())
                    .field("extctlin_2", &self.extctlin_2())
                    .field("extctlin_3", &self.extctlin_3())
                    .field("extctlin_4", &self.extctlin_4())
                    .field("extctlin_5", &self.extctlin_5())
                    .field("extctlin_6", &self.extctlin_6())
                    .field("extctlin_7", &self.extctlin_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extctlinport {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Extctlinport {
                    extctlin_0: super::vals::Extctlin0,
                    extctlin_1: super::vals::Extctlin1,
                    extctlin_2: super::vals::Extctlin2,
                    extctlin_3: super::vals::Extctlin3,
                    extctlin_4: super::vals::Extctlin4,
                    extctlin_5: super::vals::Extctlin5,
                    extctlin_6: super::vals::Extctlin6,
                    extctlin_7: super::vals::Extctlin7,
                }
                let proxy = Extctlinport {
                    extctlin_0: self.extctlin_0(),
                    extctlin_1: self.extctlin_1(),
                    extctlin_2: self.extctlin_2(),
                    extctlin_3: self.extctlin_3(),
                    extctlin_4: self.extctlin_4(),
                    extctlin_5: self.extctlin_5(),
                    extctlin_6: self.extctlin_6(),
                    extctlin_7: self.extctlin_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Two ports can be used as a control and feedback mechanism for any serializers, pin sharing multiplexers, or other solutions that might be added to the trace output pins either for pin control or a high speed trace port solution. These ports are raw register banks that sample or export the corresponding external pins."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Extctloutport(pub u32);
        impl Extctloutport {
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_0(&self) -> super::vals::Extctlout0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Extctlout0::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_0(&mut self, val: super::vals::Extctlout0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_1(&self) -> super::vals::Extctlout1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Extctlout1::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_1(&mut self, val: super::vals::Extctlout1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_2(&self) -> super::vals::Extctlout2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Extctlout2::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_2(&mut self, val: super::vals::Extctlout2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_3(&self) -> super::vals::Extctlout3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Extctlout3::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_3(&mut self, val: super::vals::Extctlout3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_4(&self) -> super::vals::Extctlout4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Extctlout4::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_4(&mut self, val: super::vals::Extctlout4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_5(&self) -> super::vals::Extctlout5 {
                let val = (self.0 >> 5usize) & 0x01;
                super::vals::Extctlout5::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_5(&mut self, val: super::vals::Extctlout5) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val.to_bits() as u32) & 0x01) << 5usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_6(&self) -> super::vals::Extctlout6 {
                let val = (self.0 >> 6usize) & 0x01;
                super::vals::Extctlout6::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_6(&mut self, val: super::vals::Extctlout6) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val.to_bits() as u32) & 0x01) << 6usize);
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub const fn extctlout_7(&self) -> super::vals::Extctlout7 {
                let val = (self.0 >> 7usize) & 0x01;
                super::vals::Extctlout7::from_bits(val as u8)
            }
            #[doc = "EXTCTL outputs."]
            #[inline(always)]
            pub fn set_extctlout_7(&mut self, val: super::vals::Extctlout7) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val.to_bits() as u32) & 0x01) << 7usize);
            }
        }
        impl Default for Extctloutport {
            #[inline(always)]
            fn default() -> Extctloutport {
                Extctloutport(0)
            }
        }
        impl core::fmt::Debug for Extctloutport {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Extctloutport")
                    .field("extctlout_0", &self.extctlout_0())
                    .field("extctlout_1", &self.extctlout_1())
                    .field("extctlout_2", &self.extctlout_2())
                    .field("extctlout_3", &self.extctlout_3())
                    .field("extctlout_4", &self.extctlout_4())
                    .field("extctlout_5", &self.extctlout_5())
                    .field("extctlout_6", &self.extctlout_6())
                    .field("extctlout_7", &self.extctlout_7())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Extctloutport {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Extctloutport {
                    extctlout_0: super::vals::Extctlout0,
                    extctlout_1: super::vals::Extctlout1,
                    extctlout_2: super::vals::Extctlout2,
                    extctlout_3: super::vals::Extctlout3,
                    extctlout_4: super::vals::Extctlout4,
                    extctlout_5: super::vals::Extctlout5,
                    extctlout_6: super::vals::Extctlout6,
                    extctlout_7: super::vals::Extctlout7,
                }
                let proxy = Extctloutport {
                    extctlout_0: self.extctlout_0(),
                    extctlout_1: self.extctlout_1(),
                    extctlout_2: self.extctlout_2(),
                    extctlout_3: self.extctlout_3(),
                    extctlout_4: self.extctlout_4(),
                    extctlout_5: self.extctlout_5(),
                    extctlout_6: self.extctlout_6(),
                    extctlout_7: self.extctlout_7(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The FFCR register controls the generation of stop, trigger, and flush events."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffcr(pub u32);
        impl Ffcr {
            #[doc = "Do not embed triggers into the formatted stream. Trace disable cycles and triggers are indicated by tracectl, where present."]
            #[inline(always)]
            pub const fn enftc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Do not embed triggers into the formatted stream. Trace disable cycles and triggers are indicated by tracectl, where present."]
            #[inline(always)]
            pub fn set_enftc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Is embedded in trigger packets and indicates that no cycle is using sync packets."]
            #[inline(always)]
            pub const fn enfcont(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Is embedded in trigger packets and indicates that no cycle is using sync packets."]
            #[inline(always)]
            pub fn set_enfcont(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enables the use of the flushin connection."]
            #[inline(always)]
            pub const fn fonflin(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the use of the flushin connection."]
            #[inline(always)]
            pub fn set_fonflin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Initiates a manual flush of data in the system when a trigger event occurs."]
            #[inline(always)]
            pub const fn fontrig(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Initiates a manual flush of data in the system when a trigger event occurs."]
            #[inline(always)]
            pub fn set_fontrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Generates a flush. This bit is set to 0 when this flush is serviced."]
            #[inline(always)]
            pub const fn fonmanr(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Generates a flush. This bit is set to 0 when this flush is serviced."]
            #[inline(always)]
            pub fn set_fonmanr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Generates a flush. This bit is set to 1 when this flush is serviced."]
            #[inline(always)]
            pub const fn fonmanw(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Generates a flush. This bit is set to 1 when this flush is serviced."]
            #[inline(always)]
            pub fn set_fonmanw(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates a trigger when trigin is asserted."]
            #[inline(always)]
            pub const fn trigin(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger when trigin is asserted."]
            #[inline(always)]
            pub fn set_trigin(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates a trigger on a trigger event."]
            #[inline(always)]
            pub const fn trigevt(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger on a trigger event."]
            #[inline(always)]
            pub fn set_trigevt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates a trigger when flush completion on afreadys is returned."]
            #[inline(always)]
            pub const fn trigfl(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates a trigger when flush completion on afreadys is returned."]
            #[inline(always)]
            pub fn set_trigfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Forces the FIFO to drain off any part-completed packets."]
            #[inline(always)]
            pub const fn stopfl(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Forces the FIFO to drain off any part-completed packets."]
            #[inline(always)]
            pub fn set_stopfl(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Stops the formatter after a trigger event is observed. Reset to disabled or 0."]
            #[inline(always)]
            pub const fn stoptrig(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Stops the formatter after a trigger event is observed. Reset to disabled or 0."]
            #[inline(always)]
            pub fn set_stoptrig(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
        }
        impl Default for Ffcr {
            #[inline(always)]
            fn default() -> Ffcr {
                Ffcr(0)
            }
        }
        impl core::fmt::Debug for Ffcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffcr")
                    .field("enftc", &self.enftc())
                    .field("enfcont", &self.enfcont())
                    .field("fonflin", &self.fonflin())
                    .field("fontrig", &self.fontrig())
                    .field("fonmanr", &self.fonmanr())
                    .field("fonmanw", &self.fonmanw())
                    .field("trigin", &self.trigin())
                    .field("trigevt", &self.trigevt())
                    .field("trigfl", &self.trigfl())
                    .field("stopfl", &self.stopfl())
                    .field("stoptrig", &self.stoptrig())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffcr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ffcr {
                    enftc: bool,
                    enfcont: bool,
                    fonflin: bool,
                    fontrig: bool,
                    fonmanr: bool,
                    fonmanw: bool,
                    trigin: bool,
                    trigevt: bool,
                    trigfl: bool,
                    stopfl: bool,
                    stoptrig: bool,
                }
                let proxy = Ffcr {
                    enftc: self.enftc(),
                    enfcont: self.enfcont(),
                    fonflin: self.fonflin(),
                    fontrig: self.fontrig(),
                    fonmanr: self.fonmanr(),
                    fonmanw: self.fonmanw(),
                    trigin: self.trigin(),
                    trigevt: self.trigevt(),
                    trigfl: self.trigfl(),
                    stopfl: self.stopfl(),
                    stoptrig: self.stoptrig(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The FFSR register indicates the current status of the formatter and flush features available in the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ffsr(pub u32);
        impl Ffsr {
            #[doc = "Flush in progress."]
            #[inline(always)]
            pub const fn flinprog(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Flush in progress."]
            #[inline(always)]
            pub fn set_flinprog(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "The formatter has received a stop request signal and all trace data and post-amble is sent. Any additional trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[inline(always)]
            pub const fn ftstopped(&self) -> super::vals::Ftstopped {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Ftstopped::from_bits(val as u8)
            }
            #[doc = "The formatter has received a stop request signal and all trace data and post-amble is sent. Any additional trace data on the ATB interface is ignored and atreadys goes HIGH."]
            #[inline(always)]
            pub fn set_ftstopped(&mut self, val: super::vals::Ftstopped) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the TRACECTL pin is available for use."]
            #[inline(always)]
            pub const fn tcpresent(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TRACECTL pin is available for use."]
            #[inline(always)]
            pub fn set_tcpresent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Ffsr {
            #[inline(always)]
            fn default() -> Ffsr {
                Ffsr(0)
            }
        }
        impl core::fmt::Debug for Ffsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ffsr")
                    .field("flinprog", &self.flinprog())
                    .field("ftstopped", &self.ftstopped())
                    .field("tcpresent", &self.tcpresent())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ffsr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ffsr {
                    flinprog: bool,
                    ftstopped: super::vals::Ftstopped,
                    tcpresent: bool,
                }
                let proxy = Ffsr {
                    flinprog: self.flinprog(),
                    ftstopped: self.ftstopped(),
                    tcpresent: self.tcpresent(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The FSCR register enables the frequency of synchronization information to be optimized to suit the Trace Port Analyzer (TPA) capture buffer size."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Fscr(pub u32);
        impl Fscr {
            #[doc = "12-bit counter reload value. Indicates the number of complete frames between full synchronization packets."]
            #[inline(always)]
            pub const fn cyccount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "12-bit counter reload value. Indicates the number of complete frames between full synchronization packets."]
            #[inline(always)]
            pub fn set_cyccount(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
        }
        impl Default for Fscr {
            #[inline(always)]
            fn default() -> Fscr {
                Fscr(0)
            }
        }
        impl core::fmt::Debug for Fscr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Fscr")
                    .field("cyccount", &self.cyccount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Fscr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Fscr {
                    cyccount: u16,
                }
                let proxy = Fscr {
                    cyccount: self.cyccount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The ITATBCTR0 register captures the values of the atvalids, afreadys, and atbytess inputs to the TPIU. To ensure the integration registers work correctly in a system, the value of atbytess is only valid when atvalids, bit\\[0\\], is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr0(pub u32);
        impl Itatbctr0 {
            #[doc = "Reads the value of atvalids."]
            #[inline(always)]
            pub const fn atvalid(&self) -> super::vals::Atvalid {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atvalid::from_bits(val as u8)
            }
            #[doc = "Reads the value of atvalids."]
            #[inline(always)]
            pub fn set_atvalid(&mut self, val: super::vals::Atvalid) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of afreadys."]
            #[inline(always)]
            pub const fn afready(&self) -> super::vals::Afready {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Afready::from_bits(val as u8)
            }
            #[doc = "Reads the value of afreadys."]
            #[inline(always)]
            pub fn set_afready(&mut self, val: super::vals::Afready) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Reads the value of atbytess."]
            #[inline(always)]
            pub const fn atbytes(&self) -> super::vals::Atbytes {
                let val = (self.0 >> 8usize) & 0x03;
                super::vals::Atbytes::from_bits(val as u8)
            }
            #[doc = "Reads the value of atbytess."]
            #[inline(always)]
            pub fn set_atbytes(&mut self, val: super::vals::Atbytes) {
                self.0 = (self.0 & !(0x03 << 8usize)) | (((val.to_bits() as u32) & 0x03) << 8usize);
            }
        }
        impl Default for Itatbctr0 {
            #[inline(always)]
            fn default() -> Itatbctr0 {
                Itatbctr0(0)
            }
        }
        impl core::fmt::Debug for Itatbctr0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr0")
                    .field("atvalid", &self.atvalid())
                    .field("afready", &self.afready())
                    .field("atbytes", &self.atbytes())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Itatbctr0 {
                    atvalid: super::vals::Atvalid,
                    afready: super::vals::Afready,
                    atbytes: super::vals::Atbytes,
                }
                let proxy = Itatbctr0 {
                    atvalid: self.atvalid(),
                    afready: self.afready(),
                    atbytes: self.atbytes(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The ITATBCTR1 register contains the value of the atids input to the TPIU. This is only valid when atvalids is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr1(pub u32);
        impl Itatbctr1 {
            #[doc = "Reads the value of atids."]
            #[inline(always)]
            pub const fn atid(&self) -> super::vals::Atid {
                let val = (self.0 >> 0usize) & 0x7f;
                super::vals::Atid::from_bits(val as u8)
            }
            #[doc = "Reads the value of atids."]
            #[inline(always)]
            pub fn set_atid(&mut self, val: super::vals::Atid) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val.to_bits() as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Itatbctr1 {
            #[inline(always)]
            fn default() -> Itatbctr1 {
                Itatbctr1(0)
            }
        }
        impl core::fmt::Debug for Itatbctr1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr1")
                    .field("atid", &self.atid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Itatbctr1 {
                    atid: super::vals::Atid,
                }
                let proxy = Itatbctr1 { atid: self.atid() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enables control of the atreadys and afvalids outputs of the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbctr2(pub u32);
        impl Itatbctr2 {
            #[doc = "Sets the value of afvalid."]
            #[inline(always)]
            pub const fn atready(&self) -> super::vals::Atready {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atready::from_bits(val as u8)
            }
            #[doc = "Sets the value of afvalid."]
            #[inline(always)]
            pub fn set_atready(&mut self, val: super::vals::Atready) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of atready."]
            #[inline(always)]
            pub const fn afvalid(&self) -> super::vals::Afvalid {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Afvalid::from_bits(val as u8)
            }
            #[doc = "Sets the value of atready."]
            #[inline(always)]
            pub fn set_afvalid(&mut self, val: super::vals::Afvalid) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Itatbctr2 {
            #[inline(always)]
            fn default() -> Itatbctr2 {
                Itatbctr2(0)
            }
        }
        impl core::fmt::Debug for Itatbctr2 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbctr2")
                    .field("atready", &self.atready())
                    .field("afvalid", &self.afvalid())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbctr2 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Itatbctr2 {
                    atready: super::vals::Atready,
                    afvalid: super::vals::Afvalid,
                }
                let proxy = Itatbctr2 {
                    atready: self.atready(),
                    afvalid: self.afvalid(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The ITATBDATA0 register contains the value of the atdatas inputs to the TPIU. The values are valid only when atvalids is HIGH."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itatbdata0(pub u32);
        impl Itatbdata0 {
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn atdata_0(&self) -> super::vals::Atdata0 {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Atdata0::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub fn set_atdata_0(&mut self, val: super::vals::Atdata0) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn atdata_1(&self) -> super::vals::Atdata1 {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Atdata1::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub fn set_atdata_1(&mut self, val: super::vals::Atdata1) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn atdata_2(&self) -> super::vals::Atdata2 {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Atdata2::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub fn set_atdata_2(&mut self, val: super::vals::Atdata2) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn atdata_3(&self) -> super::vals::Atdata3 {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Atdata3::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub fn set_atdata_3(&mut self, val: super::vals::Atdata3) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub const fn atdata_4(&self) -> super::vals::Atdata4 {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Atdata4::from_bits(val as u8)
            }
            #[doc = "A read access returns the value of a pin on atdatas_x of the enabled port. A write access writes to the corresponding atdatam pin of the enabled port."]
            #[inline(always)]
            pub fn set_atdata_4(&mut self, val: super::vals::Atdata4) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Itatbdata0 {
            #[inline(always)]
            fn default() -> Itatbdata0 {
                Itatbdata0(0)
            }
        }
        impl core::fmt::Debug for Itatbdata0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itatbdata0")
                    .field("atdata_0", &self.atdata_0())
                    .field("atdata_1", &self.atdata_1())
                    .field("atdata_2", &self.atdata_2())
                    .field("atdata_3", &self.atdata_3())
                    .field("atdata_4", &self.atdata_4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itatbdata0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Itatbdata0 {
                    atdata_0: super::vals::Atdata0,
                    atdata_1: super::vals::Atdata1,
                    atdata_2: super::vals::Atdata2,
                    atdata_3: super::vals::Atdata3,
                    atdata_4: super::vals::Atdata4,
                }
                let proxy = Itatbdata0 {
                    atdata_0: self.atdata_0(),
                    atdata_1: self.atdata_1(),
                    atdata_2: self.atdata_2(),
                    atdata_3: self.atdata_3(),
                    atdata_4: self.atdata_4(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Used to enable topology detection. This register enables the component to switch from a functional mode, the default behavior, to integration mode where the inputs and outputs of the component can be directly controlled for integration testing and topology solving."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Itctrl(pub u32);
        impl Itctrl {
            #[doc = "Enables the component to switch from functional mode to integration mode and back. If no integration functionality is implemented, this register must read as zero."]
            #[inline(always)]
            pub const fn integrationmode(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enables the component to switch from functional mode to integration mode and back. If no integration functionality is implemented, this register must read as zero."]
            #[inline(always)]
            pub fn set_integrationmode(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Itctrl {
            #[inline(always)]
            fn default() -> Itctrl {
                Itctrl(0)
            }
        }
        impl core::fmt::Debug for Itctrl {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Itctrl")
                    .field("integrationmode", &self.integrationmode())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Itctrl {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Itctrl {
                    integrationmode: bool,
                }
                let proxy = Itctrl {
                    integrationmode: self.integrationmode(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The ITTRFLIN register contains the values of the flushin and trigin inputs to the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflin(pub u32);
        impl Ittrflin {
            #[doc = "Reads the value of trigin."]
            #[inline(always)]
            pub const fn trigin(&self) -> super::vals::IttrflinTrigin {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::IttrflinTrigin::from_bits(val as u8)
            }
            #[doc = "Reads the value of trigin."]
            #[inline(always)]
            pub fn set_trigin(&mut self, val: super::vals::IttrflinTrigin) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Reads the value of flushin."]
            #[inline(always)]
            pub const fn flushin(&self) -> super::vals::Flushin {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Flushin::from_bits(val as u8)
            }
            #[doc = "Reads the value of flushin."]
            #[inline(always)]
            pub fn set_flushin(&mut self, val: super::vals::Flushin) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflin {
            #[inline(always)]
            fn default() -> Ittrflin {
                Ittrflin(0)
            }
        }
        impl core::fmt::Debug for Ittrflin {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflin")
                    .field("trigin", &self.trigin())
                    .field("flushin", &self.flushin())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflin {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ittrflin {
                    trigin: super::vals::IttrflinTrigin,
                    flushin: super::vals::Flushin,
                }
                let proxy = Ittrflin {
                    trigin: self.trigin(),
                    flushin: self.flushin(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The ITTRFLINACK register enables control of the triginack and flushinack outputs from the TPIU."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Ittrflinack(pub u32);
        impl Ittrflinack {
            #[doc = "Sets the value of triginack."]
            #[inline(always)]
            pub const fn triginack(&self) -> super::vals::Triginack {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Triginack::from_bits(val as u8)
            }
            #[doc = "Sets the value of triginack."]
            #[inline(always)]
            pub fn set_triginack(&mut self, val: super::vals::Triginack) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Sets the value of flushinack."]
            #[inline(always)]
            pub const fn flushinack(&self) -> super::vals::Flushinack {
                let val = (self.0 >> 1usize) & 0x01;
                super::vals::Flushinack::from_bits(val as u8)
            }
            #[doc = "Sets the value of flushinack."]
            #[inline(always)]
            pub fn set_flushinack(&mut self, val: super::vals::Flushinack) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val.to_bits() as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Ittrflinack {
            #[inline(always)]
            fn default() -> Ittrflinack {
                Ittrflinack(0)
            }
        }
        impl core::fmt::Debug for Ittrflinack {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Ittrflinack")
                    .field("triginack", &self.triginack())
                    .field("flushinack", &self.flushinack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Ittrflinack {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Ittrflinack {
                    triginack: super::vals::Triginack,
                    flushinack: super::vals::Flushinack,
                }
                let proxy = Ittrflinack {
                    triginack: self.triginack(),
                    flushinack: self.flushinack(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "This is used to enable write access to device registers."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lar(pub u32);
        impl Lar {
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[inline(always)]
            pub const fn access(&self) -> super::vals::Access {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Access::from_bits(val as u32)
            }
            #[doc = "A write of 0xC5ACCE55 enables further write access to this device. Any other write removes write access."]
            #[inline(always)]
            pub fn set_access(&mut self, val: super::vals::Access) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Lar {
            #[inline(always)]
            fn default() -> Lar {
                Lar(0)
            }
        }
        impl core::fmt::Debug for Lar {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lar")
                    .field("access", &self.access())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lar {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lar {
                    access: super::vals::Access,
                }
                let proxy = Lar {
                    access: self.access(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "This indicates the status of the lock control mechanism. This lock prevents accidental writes by code under debug. Accesses to the extended stimulus port registers are not affected by the lock mechanism. This register must always be present although there might not be any lock access control mechanism. The lock mechanism, where present and locked, must block write accesses to any control register, except the Lock Access Register. For most components this covers all registers except for the Lock Access Register."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Lsr(pub u32);
        impl Lsr {
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[inline(always)]
            pub const fn present(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates that a lock control mechanism exists for this device."]
            #[inline(always)]
            pub fn set_present(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Returns the current status of the Lock."]
            #[inline(always)]
            pub const fn locked(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Returns the current status of the Lock."]
            #[inline(always)]
            pub fn set_locked(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[inline(always)]
            pub const fn type_(&self) -> super::vals::Type {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Type::from_bits(val as u8)
            }
            #[doc = "Indicates if the Lock Access Register is implemented as 8-bit or 32-bit."]
            #[inline(always)]
            pub fn set_type_(&mut self, val: super::vals::Type) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Lsr {
            #[inline(always)]
            fn default() -> Lsr {
                Lsr(0)
            }
        }
        impl core::fmt::Debug for Lsr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Lsr")
                    .field("present", &self.present())
                    .field("locked", &self.locked())
                    .field("type_", &self.type_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Lsr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Lsr {
                    present: bool,
                    locked: bool,
                    type_: super::vals::Type,
                }
                let proxy = Lsr {
                    present: self.present(),
                    locked: self.locked(),
                    type_: self.type_(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Each bit location is a single port size that is supported on the device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Supportedportsizes(pub u32);
        impl Supportedportsizes {
            #[doc = "Indicates whether the TPIU supports port size of 1-bit."]
            #[inline(always)]
            pub const fn port_size_1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 1-bit."]
            #[inline(always)]
            pub fn set_port_size_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 2-bit."]
            #[inline(always)]
            pub const fn port_size_2(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 2-bit."]
            #[inline(always)]
            pub fn set_port_size_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 3-bit."]
            #[inline(always)]
            pub const fn port_size_3(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 3-bit."]
            #[inline(always)]
            pub fn set_port_size_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 4-bit."]
            #[inline(always)]
            pub const fn port_size_4(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 4-bit."]
            #[inline(always)]
            pub fn set_port_size_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 5-bit."]
            #[inline(always)]
            pub const fn port_size_5(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 5-bit."]
            #[inline(always)]
            pub fn set_port_size_5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 6-bit."]
            #[inline(always)]
            pub const fn port_size_6(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 6-bit."]
            #[inline(always)]
            pub fn set_port_size_6(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 7-bit."]
            #[inline(always)]
            pub const fn port_size_7(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 7-bit."]
            #[inline(always)]
            pub fn set_port_size_7(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 8-bit."]
            #[inline(always)]
            pub const fn port_size_8(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 8-bit."]
            #[inline(always)]
            pub fn set_port_size_8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 9-bit."]
            #[inline(always)]
            pub const fn port_size_9(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 9-bit."]
            #[inline(always)]
            pub fn set_port_size_9(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 10-bit."]
            #[inline(always)]
            pub const fn port_size_10(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 10-bit."]
            #[inline(always)]
            pub fn set_port_size_10(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 11-bit."]
            #[inline(always)]
            pub const fn port_size_11(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 11-bit."]
            #[inline(always)]
            pub fn set_port_size_11(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 12-bit."]
            #[inline(always)]
            pub const fn port_size_12(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 12-bit."]
            #[inline(always)]
            pub fn set_port_size_12(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 13-bit."]
            #[inline(always)]
            pub const fn port_size_13(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 13-bit."]
            #[inline(always)]
            pub fn set_port_size_13(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 14-bit."]
            #[inline(always)]
            pub const fn port_size_14(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 14-bit."]
            #[inline(always)]
            pub fn set_port_size_14(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 15-bit."]
            #[inline(always)]
            pub const fn port_size_15(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 15-bit."]
            #[inline(always)]
            pub fn set_port_size_15(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 16-bit."]
            #[inline(always)]
            pub const fn port_size_16(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 16-bit."]
            #[inline(always)]
            pub fn set_port_size_16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 17-bit."]
            #[inline(always)]
            pub const fn port_size_17(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 17-bit."]
            #[inline(always)]
            pub fn set_port_size_17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 18-bit."]
            #[inline(always)]
            pub const fn port_size_18(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 18-bit."]
            #[inline(always)]
            pub fn set_port_size_18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 19-bit."]
            #[inline(always)]
            pub const fn port_size_19(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 19-bit."]
            #[inline(always)]
            pub fn set_port_size_19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 20-bit."]
            #[inline(always)]
            pub const fn port_size_20(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 20-bit."]
            #[inline(always)]
            pub fn set_port_size_20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 21-bit."]
            #[inline(always)]
            pub const fn port_size_21(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 21-bit."]
            #[inline(always)]
            pub fn set_port_size_21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 22-bit."]
            #[inline(always)]
            pub const fn port_size_22(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 22-bit."]
            #[inline(always)]
            pub fn set_port_size_22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 23-bit."]
            #[inline(always)]
            pub const fn port_size_23(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 23-bit."]
            #[inline(always)]
            pub fn set_port_size_23(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 24-bit."]
            #[inline(always)]
            pub const fn port_size_24(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 24-bit."]
            #[inline(always)]
            pub fn set_port_size_24(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 25-bit."]
            #[inline(always)]
            pub const fn port_size_25(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 25-bit."]
            #[inline(always)]
            pub fn set_port_size_25(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 26-bit."]
            #[inline(always)]
            pub const fn port_size_26(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 26-bit."]
            #[inline(always)]
            pub fn set_port_size_26(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 27-bit."]
            #[inline(always)]
            pub const fn port_size_27(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 27-bit."]
            #[inline(always)]
            pub fn set_port_size_27(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 28-bit."]
            #[inline(always)]
            pub const fn port_size_28(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 28-bit."]
            #[inline(always)]
            pub fn set_port_size_28(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 29-bit."]
            #[inline(always)]
            pub const fn port_size_29(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 29-bit."]
            #[inline(always)]
            pub fn set_port_size_29(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 30-bit."]
            #[inline(always)]
            pub const fn port_size_30(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 30-bit."]
            #[inline(always)]
            pub fn set_port_size_30(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 31-bit."]
            #[inline(always)]
            pub const fn port_size_31(&self) -> bool {
                let val = (self.0 >> 30usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 31-bit."]
            #[inline(always)]
            pub fn set_port_size_31(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 30usize)) | (((val as u32) & 0x01) << 30usize);
            }
            #[doc = "Indicates whether the TPIU supports port size of 32-bit."]
            #[inline(always)]
            pub const fn port_size_32(&self) -> bool {
                let val = (self.0 >> 31usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the TPIU supports port size of 32-bit."]
            #[inline(always)]
            pub fn set_port_size_32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 31usize)) | (((val as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Supportedportsizes {
            #[inline(always)]
            fn default() -> Supportedportsizes {
                Supportedportsizes(0)
            }
        }
        impl core::fmt::Debug for Supportedportsizes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Supportedportsizes")
                    .field("port_size_1", &self.port_size_1())
                    .field("port_size_2", &self.port_size_2())
                    .field("port_size_3", &self.port_size_3())
                    .field("port_size_4", &self.port_size_4())
                    .field("port_size_5", &self.port_size_5())
                    .field("port_size_6", &self.port_size_6())
                    .field("port_size_7", &self.port_size_7())
                    .field("port_size_8", &self.port_size_8())
                    .field("port_size_9", &self.port_size_9())
                    .field("port_size_10", &self.port_size_10())
                    .field("port_size_11", &self.port_size_11())
                    .field("port_size_12", &self.port_size_12())
                    .field("port_size_13", &self.port_size_13())
                    .field("port_size_14", &self.port_size_14())
                    .field("port_size_15", &self.port_size_15())
                    .field("port_size_16", &self.port_size_16())
                    .field("port_size_17", &self.port_size_17())
                    .field("port_size_18", &self.port_size_18())
                    .field("port_size_19", &self.port_size_19())
                    .field("port_size_20", &self.port_size_20())
                    .field("port_size_21", &self.port_size_21())
                    .field("port_size_22", &self.port_size_22())
                    .field("port_size_23", &self.port_size_23())
                    .field("port_size_24", &self.port_size_24())
                    .field("port_size_25", &self.port_size_25())
                    .field("port_size_26", &self.port_size_26())
                    .field("port_size_27", &self.port_size_27())
                    .field("port_size_28", &self.port_size_28())
                    .field("port_size_29", &self.port_size_29())
                    .field("port_size_30", &self.port_size_30())
                    .field("port_size_31", &self.port_size_31())
                    .field("port_size_32", &self.port_size_32())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Supportedportsizes {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Supportedportsizes {
                    port_size_1: bool,
                    port_size_2: bool,
                    port_size_3: bool,
                    port_size_4: bool,
                    port_size_5: bool,
                    port_size_6: bool,
                    port_size_7: bool,
                    port_size_8: bool,
                    port_size_9: bool,
                    port_size_10: bool,
                    port_size_11: bool,
                    port_size_12: bool,
                    port_size_13: bool,
                    port_size_14: bool,
                    port_size_15: bool,
                    port_size_16: bool,
                    port_size_17: bool,
                    port_size_18: bool,
                    port_size_19: bool,
                    port_size_20: bool,
                    port_size_21: bool,
                    port_size_22: bool,
                    port_size_23: bool,
                    port_size_24: bool,
                    port_size_25: bool,
                    port_size_26: bool,
                    port_size_27: bool,
                    port_size_28: bool,
                    port_size_29: bool,
                    port_size_30: bool,
                    port_size_31: bool,
                    port_size_32: bool,
                }
                let proxy = Supportedportsizes {
                    port_size_1: self.port_size_1(),
                    port_size_2: self.port_size_2(),
                    port_size_3: self.port_size_3(),
                    port_size_4: self.port_size_4(),
                    port_size_5: self.port_size_5(),
                    port_size_6: self.port_size_6(),
                    port_size_7: self.port_size_7(),
                    port_size_8: self.port_size_8(),
                    port_size_9: self.port_size_9(),
                    port_size_10: self.port_size_10(),
                    port_size_11: self.port_size_11(),
                    port_size_12: self.port_size_12(),
                    port_size_13: self.port_size_13(),
                    port_size_14: self.port_size_14(),
                    port_size_15: self.port_size_15(),
                    port_size_16: self.port_size_16(),
                    port_size_17: self.port_size_17(),
                    port_size_18: self.port_size_18(),
                    port_size_19: self.port_size_19(),
                    port_size_20: self.port_size_20(),
                    port_size_21: self.port_size_21(),
                    port_size_22: self.port_size_22(),
                    port_size_23: self.port_size_23(),
                    port_size_24: self.port_size_24(),
                    port_size_25: self.port_size_25(),
                    port_size_26: self.port_size_26(),
                    port_size_27: self.port_size_27(),
                    port_size_28: self.port_size_28(),
                    port_size_29: self.port_size_29(),
                    port_size_30: self.port_size_30(),
                    port_size_31: self.port_size_31(),
                    port_size_32: self.port_size_32(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The Supported_trigger_modes register indicates the implemented trigger counter multipliers and other supported features of the trigger system."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Supportedtriggermodes(pub u32);
        impl Supportedtriggermodes {
            #[doc = "Indicates whether multiplying the trigger counter by 2^(0+1) is supported."]
            #[inline(always)]
            pub const fn mult_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(0+1) is supported."]
            #[inline(always)]
            pub fn set_mult_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(1+1) is supported."]
            #[inline(always)]
            pub const fn mult_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(1+1) is supported."]
            #[inline(always)]
            pub fn set_mult_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(2+1) is supported."]
            #[inline(always)]
            pub const fn mult_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(2+1) is supported."]
            #[inline(always)]
            pub fn set_mult_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(3+1) is supported."]
            #[inline(always)]
            pub const fn mult_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(3+1) is supported."]
            #[inline(always)]
            pub fn set_mult_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(4+1) is supported."]
            #[inline(always)]
            pub const fn mult_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether multiplying the trigger counter by 2^(4+1) is supported."]
            #[inline(always)]
            pub fn set_mult_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Indicates whether an 8-bit wide counter register is implemented."]
            #[inline(always)]
            pub const fn tcount8(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether an 8-bit wide counter register is implemented."]
            #[inline(always)]
            pub fn set_tcount8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "A trigger has occurred and the counter has reached 0."]
            #[inline(always)]
            pub const fn triggered(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "A trigger has occurred and the counter has reached 0."]
            #[inline(always)]
            pub fn set_triggered(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "A trigger has occurred but the counter is not at 0."]
            #[inline(always)]
            pub const fn trgrun(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "A trigger has occurred but the counter is not at 0."]
            #[inline(always)]
            pub fn set_trgrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Supportedtriggermodes {
            #[inline(always)]
            fn default() -> Supportedtriggermodes {
                Supportedtriggermodes(0)
            }
        }
        impl core::fmt::Debug for Supportedtriggermodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Supportedtriggermodes")
                    .field("mult_0", &self.mult_0())
                    .field("mult_1", &self.mult_1())
                    .field("mult_2", &self.mult_2())
                    .field("mult_3", &self.mult_3())
                    .field("mult_4", &self.mult_4())
                    .field("tcount8", &self.tcount8())
                    .field("triggered", &self.triggered())
                    .field("trgrun", &self.trgrun())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Supportedtriggermodes {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Supportedtriggermodes {
                    mult_0: bool,
                    mult_1: bool,
                    mult_2: bool,
                    mult_3: bool,
                    mult_4: bool,
                    tcount8: bool,
                    triggered: bool,
                    trgrun: bool,
                }
                let proxy = Supportedtriggermodes {
                    mult_0: self.mult_0(),
                    mult_1: self.mult_1(),
                    mult_2: self.mult_2(),
                    mult_3: self.mult_3(),
                    mult_4: self.mult_4(),
                    tcount8: self.tcount8(),
                    triggered: self.triggered(),
                    trgrun: self.trgrun(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The Supported_test_pattern_modes register provides a set of known bit sequences or patterns that can be output over the trace port and can be detected by the TPA or other associated trace capture device."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Suppportedtestpatternmodes(pub u32);
        impl Suppportedtestpatternmodes {
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn patw1(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 1s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_patw1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn patw0(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the walking 0s pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_patw0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn pata5(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the AA/55 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_pata5(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub const fn patf0(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether the FF/00 pattern is supported as output over the trace port."]
            #[inline(always)]
            pub fn set_patf0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub const fn ptimeen(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether timed mode is supported."]
            #[inline(always)]
            pub fn set_ptimeen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub const fn pconten(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether continuous mode is supported."]
            #[inline(always)]
            pub fn set_pconten(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
        }
        impl Default for Suppportedtestpatternmodes {
            #[inline(always)]
            fn default() -> Suppportedtestpatternmodes {
                Suppportedtestpatternmodes(0)
            }
        }
        impl core::fmt::Debug for Suppportedtestpatternmodes {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Suppportedtestpatternmodes")
                    .field("patw1", &self.patw1())
                    .field("patw0", &self.patw0())
                    .field("pata5", &self.pata5())
                    .field("patf0", &self.patf0())
                    .field("ptimeen", &self.ptimeen())
                    .field("pconten", &self.pconten())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Suppportedtestpatternmodes {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Suppportedtestpatternmodes {
                    patw1: bool,
                    patw0: bool,
                    pata5: bool,
                    patf0: bool,
                    ptimeen: bool,
                    pconten: bool,
                }
                let proxy = Suppportedtestpatternmodes {
                    patw1: self.patw1(),
                    patw0: self.patw0(),
                    pata5: self.pata5(),
                    patf0: self.patf0(),
                    ptimeen: self.ptimeen(),
                    pconten: self.pconten(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The TPRCR register is an 8-bit counter start value that is decremented. A write sets the initial counter value and a read returns the programmed value."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tprcr(pub u32);
        impl Tprcr {
            #[doc = "8-bit counter value to indicate the number of traceclkin cycles for which a pattern runs before it switches to the next pattern."]
            #[inline(always)]
            pub const fn pattcount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit counter value to indicate the number of traceclkin cycles for which a pattern runs before it switches to the next pattern."]
            #[inline(always)]
            pub fn set_pattcount(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Tprcr {
            #[inline(always)]
            fn default() -> Tprcr {
                Tprcr(0)
            }
        }
        impl core::fmt::Debug for Tprcr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tprcr")
                    .field("pattcount", &self.pattcount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tprcr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tprcr {
                    pattcount: u8,
                }
                let proxy = Tprcr {
                    pattcount: self.pattcount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The Trigger_counter_value register enables delaying the indication of triggers to any external connected trace capture or storage devices."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Triggercountervalue(pub u32);
        impl Triggercountervalue {
            #[doc = "8-bit counter value for the number of words to be output from the formatter before a trigger is inserted."]
            #[inline(always)]
            pub const fn trig_count(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "8-bit counter value for the number of words to be output from the formatter before a trigger is inserted."]
            #[inline(always)]
            pub fn set_trig_count(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Triggercountervalue {
            #[inline(always)]
            fn default() -> Triggercountervalue {
                Triggercountervalue(0)
            }
        }
        impl core::fmt::Debug for Triggercountervalue {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Triggercountervalue")
                    .field("trig_count", &self.trig_count())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Triggercountervalue {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Triggercountervalue {
                    trig_count: u8,
                }
                let proxy = Triggercountervalue {
                    trig_count: self.trig_count(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "The Trigger_multiplier register contains the selectors for the trigger counter multiplier."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Triggermultiplier(pub u32);
        impl Triggermultiplier {
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn mult_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub fn set_mult_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn mult_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub fn set_mult_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn mult_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub fn set_mult_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn mult_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub fn set_mult_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub const fn mult_4(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Multiply the Trigger Counter by 2^n."]
            #[inline(always)]
            pub fn set_mult_4(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
        }
        impl Default for Triggermultiplier {
            #[inline(always)]
            fn default() -> Triggermultiplier {
                Triggermultiplier(0)
            }
        }
        impl core::fmt::Debug for Triggermultiplier {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Triggermultiplier")
                    .field("mult_0", &self.mult_0())
                    .field("mult_1", &self.mult_1())
                    .field("mult_2", &self.mult_2())
                    .field("mult_3", &self.mult_3())
                    .field("mult_4", &self.mult_4())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Triggermultiplier {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Triggermultiplier {
                    mult_0: bool,
                    mult_1: bool,
                    mult_2: bool,
                    mult_3: bool,
                    mult_4: bool,
                }
                let proxy = Triggermultiplier {
                    mult_0: self.mult_0(),
                    mult_1: self.mult_1(),
                    mult_2: self.mult_2(),
                    mult_3: self.mult_3(),
                    mult_4: self.mult_4(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Access(pub u32);
        impl Access {
            #[doc = "Unlock register interface."]
            pub const UN_LOCK: Self = Self(0xc5ac_ce55);
        }
        impl Access {
            pub const fn from_bits(val: u32) -> Access {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Access {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xc5ac_ce55 => f.write_str("UN_LOCK"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Access {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xc5ac_ce55 => defmt::write!(f, "UN_LOCK"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Access {
            #[inline(always)]
            fn from(val: u32) -> Access {
                Access::from_bits(val)
            }
        }
        impl From<Access> for u32 {
            #[inline(always)]
            fn from(val: Access) -> u32 {
                Access::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afready {
            #[inline(always)]
            fn from(val: u8) -> Afready {
                Afready::from_bits(val)
            }
        }
        impl From<Afready> for u8 {
            #[inline(always)]
            fn from(val: Afready) -> u8 {
                Afready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Afvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Afvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Afvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Afvalid {
            #[inline(always)]
            fn from(val: u8) -> Afvalid {
                Afvalid::from_bits(val)
            }
        }
        impl From<Afvalid> for u8 {
            #[inline(always)]
            fn from(val: Afvalid) -> u8 {
                Afvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atbytes {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Atbytes {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atbytes {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atbytes {
            #[inline(always)]
            fn from(val: u8) -> Atbytes {
                Atbytes::from_bits(val)
            }
        }
        impl From<Atbytes> for u8 {
            #[inline(always)]
            fn from(val: Atbytes) -> u8 {
                Atbytes::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata0 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata0 {
            #[inline(always)]
            fn from(val: u8) -> Atdata0 {
                Atdata0::from_bits(val)
            }
        }
        impl From<Atdata0> for u8 {
            #[inline(always)]
            fn from(val: Atdata0) -> u8 {
                Atdata0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata1 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata1 {
            #[inline(always)]
            fn from(val: u8) -> Atdata1 {
                Atdata1::from_bits(val)
            }
        }
        impl From<Atdata1> for u8 {
            #[inline(always)]
            fn from(val: Atdata1) -> u8 {
                Atdata1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata2 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata2 {
            #[inline(always)]
            fn from(val: u8) -> Atdata2 {
                Atdata2::from_bits(val)
            }
        }
        impl From<Atdata2> for u8 {
            #[inline(always)]
            fn from(val: Atdata2) -> u8 {
                Atdata2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata3 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata3 {
            #[inline(always)]
            fn from(val: u8) -> Atdata3 {
                Atdata3::from_bits(val)
            }
        }
        impl From<Atdata3> for u8 {
            #[inline(always)]
            fn from(val: Atdata3) -> u8 {
                Atdata3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atdata4 {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atdata4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atdata4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atdata4 {
            #[inline(always)]
            fn from(val: u8) -> Atdata4 {
                Atdata4::from_bits(val)
            }
        }
        impl From<Atdata4> for u8 {
            #[inline(always)]
            fn from(val: Atdata4) -> u8 {
                Atdata4::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Atid(pub u8);
        impl Atid {
            #[doc = "Pin is logic 0."]
            pub const LOW: Self = Self(0x0);
            #[doc = "Pin is logic 1."]
            pub const HIGH: Self = Self(0x01);
        }
        impl Atid {
            pub const fn from_bits(val: u8) -> Atid {
                Self(val & 0x7f)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Atid {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("LOW"),
                    0x01 => f.write_str("HIGH"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Atid {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "LOW"),
                    0x01 => defmt::write!(f, "HIGH"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Atid {
            #[inline(always)]
            fn from(val: u8) -> Atid {
                Atid::from_bits(val)
            }
        }
        impl From<Atid> for u8 {
            #[inline(always)]
            fn from(val: Atid) -> u8 {
                Atid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atready {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atready {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atready {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atready {
            #[inline(always)]
            fn from(val: u8) -> Atready {
                Atready::from_bits(val)
            }
        }
        impl From<Atready> for u8 {
            #[inline(always)]
            fn from(val: Atready) -> u8 {
                Atready::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Atvalid {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Atvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Atvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Atvalid {
            #[inline(always)]
            fn from(val: u8) -> Atvalid {
                Atvalid::from_bits(val)
            }
        }
        impl From<Atvalid> for u8 {
            #[inline(always)]
            fn from(val: Atvalid) -> u8 {
                Atvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit0 {
            #[doc = "Claim bit 0 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 0 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit0 {
                ClaimclrBit0::from_bits(val)
            }
        }
        impl From<ClaimclrBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit0) -> u8 {
                ClaimclrBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit1 {
            #[doc = "Claim bit 1 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 1 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit1 {
                ClaimclrBit1::from_bits(val)
            }
        }
        impl From<ClaimclrBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit1) -> u8 {
                ClaimclrBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit2 {
            #[doc = "Claim bit 2 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 2 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit2 {
                ClaimclrBit2::from_bits(val)
            }
        }
        impl From<ClaimclrBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit2) -> u8 {
                ClaimclrBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimclrBit3 {
            #[doc = "Claim bit 3 is not set."]
            CLEARED = 0x0,
            #[doc = "Claim bit 3 is set."]
            R_SET_W_CLEAR = 0x01,
        }
        impl ClaimclrBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimclrBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimclrBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimclrBit3 {
                ClaimclrBit3::from_bits(val)
            }
        }
        impl From<ClaimclrBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimclrBit3) -> u8 {
                ClaimclrBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit0 {
            #[doc = "Claim bit 0 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 0 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit0 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit0 {
                ClaimsetBit0::from_bits(val)
            }
        }
        impl From<ClaimsetBit0> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit0) -> u8 {
                ClaimsetBit0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit1 {
            #[doc = "Claim bit 1 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 1 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit1 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit1 {
                ClaimsetBit1::from_bits(val)
            }
        }
        impl From<ClaimsetBit1> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit1) -> u8 {
                ClaimsetBit1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit2 {
            #[doc = "Claim bit 2 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 2 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit2 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit2 {
                ClaimsetBit2::from_bits(val)
            }
        }
        impl From<ClaimsetBit2> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit2) -> u8 {
                ClaimsetBit2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ClaimsetBit3 {
            #[doc = "Claim bit 3 is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "Claim bit 3 is implemented."]
            R_IMPLEMENTED_W_SET = 0x01,
        }
        impl ClaimsetBit3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ClaimsetBit3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ClaimsetBit3 {
            #[inline(always)]
            fn from(val: u8) -> ClaimsetBit3 {
                ClaimsetBit3::from_bits(val)
            }
        }
        impl From<ClaimsetBit3> for u8 {
            #[inline(always)]
            fn from(val: ClaimsetBit3) -> u8 {
                ClaimsetBit3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clkrelat {
            #[doc = "atclk and traceclkin are synchronous."]
            SYNCHRONOUS = 0x0,
            #[doc = "atclk and traceclkin are asynchronous."]
            ASYNCHRONOUS = 0x01,
        }
        impl Clkrelat {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clkrelat {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clkrelat {
            #[inline(always)]
            fn from(val: u8) -> Clkrelat {
                Clkrelat::from_bits(val)
            }
        }
        impl From<Clkrelat> for u8 {
            #[inline(always)]
            fn from(val: Clkrelat) -> u8 {
                Clkrelat::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin0 {
            #[doc = "Input EXTCTL0 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL0 is high."]
            HIGH = 0x01,
        }
        impl Extctlin0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin0 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin0 {
                Extctlin0::from_bits(val)
            }
        }
        impl From<Extctlin0> for u8 {
            #[inline(always)]
            fn from(val: Extctlin0) -> u8 {
                Extctlin0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin1 {
            #[doc = "Input EXTCTL1 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL1 is high."]
            HIGH = 0x01,
        }
        impl Extctlin1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin1 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin1 {
                Extctlin1::from_bits(val)
            }
        }
        impl From<Extctlin1> for u8 {
            #[inline(always)]
            fn from(val: Extctlin1) -> u8 {
                Extctlin1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin2 {
            #[doc = "Input EXTCTL2 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL2 is high."]
            HIGH = 0x01,
        }
        impl Extctlin2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin2 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin2 {
                Extctlin2::from_bits(val)
            }
        }
        impl From<Extctlin2> for u8 {
            #[inline(always)]
            fn from(val: Extctlin2) -> u8 {
                Extctlin2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin3 {
            #[doc = "Input EXTCTL3 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL3 is high."]
            HIGH = 0x01,
        }
        impl Extctlin3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin3 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin3 {
                Extctlin3::from_bits(val)
            }
        }
        impl From<Extctlin3> for u8 {
            #[inline(always)]
            fn from(val: Extctlin3) -> u8 {
                Extctlin3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin4 {
            #[doc = "Input EXTCTL4 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL4 is high."]
            HIGH = 0x01,
        }
        impl Extctlin4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin4 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin4 {
                Extctlin4::from_bits(val)
            }
        }
        impl From<Extctlin4> for u8 {
            #[inline(always)]
            fn from(val: Extctlin4) -> u8 {
                Extctlin4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin5 {
            #[doc = "Input EXTCTL5 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL5 is high."]
            HIGH = 0x01,
        }
        impl Extctlin5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin5 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin5 {
                Extctlin5::from_bits(val)
            }
        }
        impl From<Extctlin5> for u8 {
            #[inline(always)]
            fn from(val: Extctlin5) -> u8 {
                Extctlin5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin6 {
            #[doc = "Input EXTCTL6 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL6 is high."]
            HIGH = 0x01,
        }
        impl Extctlin6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin6 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin6 {
                Extctlin6::from_bits(val)
            }
        }
        impl From<Extctlin6> for u8 {
            #[inline(always)]
            fn from(val: Extctlin6) -> u8 {
                Extctlin6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlin7 {
            #[doc = "Input EXTCTL7 is low."]
            LOW = 0x0,
            #[doc = "Input EXTCTL7 is high."]
            HIGH = 0x01,
        }
        impl Extctlin7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlin7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlin7 {
            #[inline(always)]
            fn from(val: u8) -> Extctlin7 {
                Extctlin7::from_bits(val)
            }
        }
        impl From<Extctlin7> for u8 {
            #[inline(always)]
            fn from(val: Extctlin7) -> u8 {
                Extctlin7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout0 {
            #[doc = "Output EXTCTL0 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL0 is high."]
            HIGH = 0x01,
        }
        impl Extctlout0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout0 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout0 {
                Extctlout0::from_bits(val)
            }
        }
        impl From<Extctlout0> for u8 {
            #[inline(always)]
            fn from(val: Extctlout0) -> u8 {
                Extctlout0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout1 {
            #[doc = "Output EXTCTL1 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL1 is high."]
            HIGH = 0x01,
        }
        impl Extctlout1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout1 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout1 {
                Extctlout1::from_bits(val)
            }
        }
        impl From<Extctlout1> for u8 {
            #[inline(always)]
            fn from(val: Extctlout1) -> u8 {
                Extctlout1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout2 {
            #[doc = "Output EXTCTL2 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL2 is high."]
            HIGH = 0x01,
        }
        impl Extctlout2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout2 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout2 {
                Extctlout2::from_bits(val)
            }
        }
        impl From<Extctlout2> for u8 {
            #[inline(always)]
            fn from(val: Extctlout2) -> u8 {
                Extctlout2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout3 {
            #[doc = "Output EXTCTL3 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL3 is high."]
            HIGH = 0x01,
        }
        impl Extctlout3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout3 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout3 {
                Extctlout3::from_bits(val)
            }
        }
        impl From<Extctlout3> for u8 {
            #[inline(always)]
            fn from(val: Extctlout3) -> u8 {
                Extctlout3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout4 {
            #[doc = "Output EXTCTL4 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL4 is high."]
            HIGH = 0x01,
        }
        impl Extctlout4 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout4 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout4 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout4 {
                Extctlout4::from_bits(val)
            }
        }
        impl From<Extctlout4> for u8 {
            #[inline(always)]
            fn from(val: Extctlout4) -> u8 {
                Extctlout4::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout5 {
            #[doc = "Output EXTCTL5 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL5 is high."]
            HIGH = 0x01,
        }
        impl Extctlout5 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout5 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout5 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout5 {
                Extctlout5::from_bits(val)
            }
        }
        impl From<Extctlout5> for u8 {
            #[inline(always)]
            fn from(val: Extctlout5) -> u8 {
                Extctlout5::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout6 {
            #[doc = "Output EXTCTL6 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL6 is high."]
            HIGH = 0x01,
        }
        impl Extctlout6 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout6 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout6 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout6 {
                Extctlout6::from_bits(val)
            }
        }
        impl From<Extctlout6> for u8 {
            #[inline(always)]
            fn from(val: Extctlout6) -> u8 {
                Extctlout6::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Extctlout7 {
            #[doc = "Output EXTCTL7 is low."]
            LOW = 0x0,
            #[doc = "Output EXTCTL7 is high."]
            HIGH = 0x01,
        }
        impl Extctlout7 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Extctlout7 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Extctlout7 {
            #[inline(always)]
            fn from(val: u8) -> Extctlout7 {
                Extctlout7::from_bits(val)
            }
        }
        impl From<Extctlout7> for u8 {
            #[inline(always)]
            fn from(val: Extctlout7) -> u8 {
                Extctlout7::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Fifosize {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            #[doc = "FIFO size of 4 entries, that is, 16 bytes."]
            ENTRIES4 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Fifosize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Fifosize {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Fifosize {
            #[inline(always)]
            fn from(val: u8) -> Fifosize {
                Fifosize::from_bits(val)
            }
        }
        impl From<Fifosize> for u8 {
            #[inline(always)]
            fn from(val: Fifosize) -> u8 {
                Fifosize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flushin {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Flushin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flushin {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flushin {
            #[inline(always)]
            fn from(val: u8) -> Flushin {
                Flushin::from_bits(val)
            }
        }
        impl From<Flushin> for u8 {
            #[inline(always)]
            fn from(val: Flushin) -> u8 {
                Flushin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Flushinack {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Flushinack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Flushinack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Flushinack {
            #[inline(always)]
            fn from(val: u8) -> Flushinack {
                Flushinack::from_bits(val)
            }
        }
        impl From<Flushinack> for u8 {
            #[inline(always)]
            fn from(val: Flushinack) -> u8 {
                Flushinack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ftstopped {
            #[doc = "Formatter has not stopped."]
            RUNNING = 0x0,
            #[doc = "Formatter has stopped."]
            STOPPED = 0x01,
        }
        impl Ftstopped {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ftstopped {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ftstopped {
            #[inline(always)]
            fn from(val: u8) -> Ftstopped {
                Ftstopped::from_bits(val)
            }
        }
        impl From<Ftstopped> for u8 {
            #[inline(always)]
            fn from(val: Ftstopped) -> u8 {
                Ftstopped::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum IttrflinTrigin {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl IttrflinTrigin {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> IttrflinTrigin {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for IttrflinTrigin {
            #[inline(always)]
            fn from(val: u8) -> IttrflinTrigin {
                IttrflinTrigin::from_bits(val)
            }
        }
        impl From<IttrflinTrigin> for u8 {
            #[inline(always)]
            fn from(val: IttrflinTrigin) -> u8 {
                IttrflinTrigin::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Major {
            _RESERVED_0 = 0x0,
            #[doc = "Peripheral is a trace sink."]
            TRACE_SOURCE = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Major {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Major {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Major {
            #[inline(always)]
            fn from(val: u8) -> Major {
                Major::from_bits(val)
            }
        }
        impl From<Major> for u8 {
            #[inline(always)]
            fn from(val: Major) -> u8 {
                Major::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsid {
            #[inline(always)]
            fn from(val: u8) -> Nsid {
                Nsid::from_bits(val)
            }
        }
        impl From<Nsid> for u8 {
            #[inline(always)]
            fn from(val: Nsid) -> u8 {
                Nsid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Nsnid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Nsnid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Nsnid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Nsnid {
            #[inline(always)]
            fn from(val: u8) -> Nsnid {
                Nsnid::from_bits(val)
            }
        }
        impl From<Nsnid> for u8 {
            #[inline(always)]
            fn from(val: Nsnid) -> u8 {
                Nsnid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Sid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sid {
            #[inline(always)]
            fn from(val: u8) -> Sid {
                Sid::from_bits(val)
            }
        }
        impl From<Sid> for u8 {
            #[inline(always)]
            fn from(val: Sid) -> u8 {
                Sid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Snid {
            #[doc = "The feature is not implemented."]
            NOT_IMPLEMENTED = 0x0,
            #[doc = "The feature is implemented."]
            IMPLEMENTED = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
        }
        impl Snid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Snid {
                unsafe { core::mem::transmute(val & 0x03) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Snid {
            #[inline(always)]
            fn from(val: u8) -> Snid {
                Snid::from_bits(val)
            }
        }
        impl From<Snid> for u8 {
            #[inline(always)]
            fn from(val: Snid) -> u8 {
                Snid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sub {
            _RESERVED_0 = 0x0,
            #[doc = "Indicates that this component is a trace port component."]
            TRACE_PORT = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Sub {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sub {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sub {
            #[inline(always)]
            fn from(val: u8) -> Sub {
                Sub::from_bits(val)
            }
        }
        impl From<Sub> for u8 {
            #[inline(always)]
            fn from(val: Sub) -> u8 {
                Sub::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Tclkdata {
            #[doc = "Trace clock and data is supported."]
            SUPPORTED = 0x0,
            #[doc = "Trace clock and data is not supported."]
            NOT_SUPPORTED = 0x01,
        }
        impl Tclkdata {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Tclkdata {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Tclkdata {
            #[inline(always)]
            fn from(val: u8) -> Tclkdata {
                Tclkdata::from_bits(val)
            }
        }
        impl From<Tclkdata> for u8 {
            #[inline(always)]
            fn from(val: Tclkdata) -> u8 {
                Tclkdata::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Triginack {
            #[doc = "Pin is logic 0."]
            LOW = 0x0,
            #[doc = "Pin is logic 1."]
            HIGH = 0x01,
        }
        impl Triginack {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Triginack {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Triginack {
            #[inline(always)]
            fn from(val: u8) -> Triginack {
                Triginack::from_bits(val)
            }
        }
        impl From<Triginack> for u8 {
            #[inline(always)]
            fn from(val: Triginack) -> u8 {
                Triginack::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Type {
            #[doc = "This component implements a 32-bit Lock Access Register."]
            BITS32 = 0x0,
            #[doc = "This component implements an 8-bit Lock Access Register."]
            BITS8 = 0x01,
        }
        impl Type {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Type {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Type {
            #[inline(always)]
            fn from(val: u8) -> Type {
                Type::from_bits(val)
            }
        }
        impl From<Type> for u8 {
            #[inline(always)]
            fn from(val: Type) -> u8 {
                Type::to_bits(val)
            }
        }
    }
}
pub mod twim {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn tx(self) -> SubscribeDmaTx {
            unsafe { SubscribeDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaTx {}
    unsafe impl Sync for SubscribeDmaTx {}
    impl SubscribeDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Master Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twim {
        ptr: *mut u8,
    }
    unsafe impl Send for Twim {}
    unsafe impl Sync for Twim {}
    impl Twim {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction. Must be issued while the TWI master is not suspended."]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "SUSPEND task has been issued, TWI traffic is now suspended."]
        #[inline(always)]
        pub const fn events_suspended(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0128usize) as _) }
        }
        #[doc = "Byte boundary, starting to receive the last byte"]
        #[inline(always)]
        pub const fn events_lastrx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0134usize) as _) }
        }
        #[doc = "Byte boundary, starting to transmit the last byte"]
        #[inline(always)]
        pub const fn events_lasttx(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0138usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event SUSPENDED"]
        #[inline(always)]
        pub const fn publish_suspended(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a8usize) as _) }
        }
        #[doc = "Publish configuration for event LASTRX"]
        #[inline(always)]
        pub const fn publish_lastrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b4usize) as _) }
        }
        #[doc = "Publish configuration for event LASTTX"]
        #[inline(always)]
        pub const fn publish_lasttx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b8usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04c4usize) as _) }
        }
        #[doc = "Enable TWIM"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn frequency(self) -> crate::common::Reg<regs::Frequency, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0524usize) as _) }
        }
        #[doc = "Address used in the TWI transfer"]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0588usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Address used in the TWI transfer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Address used in the TWI transfer"]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "Address used in the TWI transfer"]
            #[inline(always)]
            pub fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Address {
                    address: u8,
                }
                let proxy = Address {
                    address: self.address(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    enable_0: bool,
                    enable_1: bool,
                    enable_2: bool,
                    enable_3: bool,
                    oneshot_0: super::vals::Oneshot0,
                    oneshot_1: super::vals::Oneshot1,
                    oneshot_2: super::vals::Oneshot2,
                    oneshot_3: super::vals::Oneshot3,
                }
                let proxy = Config {
                    enable_0: self.enable_0(),
                    enable_1: self.enable_1(),
                    enable_2: self.enable_2(),
                    enable_3: self.enable_3(),
                    oneshot_0: self.oneshot_0(),
                    oneshot_1: self.oneshot_1(),
                    oneshot_2: self.oneshot_2(),
                    oneshot_3: self.oneshot_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable TWIM"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIM"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIM"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[inline(always)]
            pub const fn anack(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending the address (write '1' to clear)"]
            #[inline(always)]
            pub fn set_anack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK received after sending a data byte (write '1' to clear)"]
            #[inline(always)]
            pub fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("anack", &self.anack())
                    .field("dnack", &self.dnack())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorsrc {
                    overrun: bool,
                    anack: bool,
                    dnack: bool,
                }
                let proxy = Errorsrc {
                    overrun: self.overrun(),
                    anack: self.anack(),
                    dnack: self.dnack(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "TWI frequency. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "TWI master clock frequency"]
            #[inline(always)]
            pub const fn frequency(&self) -> super::vals::Frequency {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Frequency::from_bits(val as u32)
            }
            #[doc = "TWI master clock frequency"]
            #[inline(always)]
            pub fn set_frequency(&mut self, val: super::vals::Frequency) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Frequency {
            #[inline(always)]
            fn default() -> Frequency {
                Frequency(0)
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frequency")
                    .field("frequency", &self.frequency())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Frequency {
                    frequency: super::vals::Frequency,
                }
                let proxy = Frequency {
                    frequency: self.frequency(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[inline(always)]
            pub const fn suspended(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event SUSPENDED"]
            #[inline(always)]
            pub fn set_suspended(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[inline(always)]
            pub const fn lastrx(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTRX"]
            #[inline(always)]
            pub fn set_lastrx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[inline(always)]
            pub const fn lasttx(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event LASTTX"]
            #[inline(always)]
            pub fn set_lasttx(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("suspended", &self.suspended())
                    .field("lastrx", &self.lastrx())
                    .field("lasttx", &self.lasttx())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    stopped: bool,
                    error: bool,
                    suspended: bool,
                    lastrx: bool,
                    lasttx: bool,
                    dmarxend: bool,
                    dmarxready: bool,
                    dmarxbuserror: bool,
                    dmarxmatch0: bool,
                    dmarxmatch1: bool,
                    dmarxmatch2: bool,
                    dmarxmatch3: bool,
                    dmatxend: bool,
                    dmatxready: bool,
                    dmatxbuserror: bool,
                }
                let proxy = Int {
                    stopped: self.stopped(),
                    error: self.error(),
                    suspended: self.suspended(),
                    lastrx: self.lastrx(),
                    lasttx: self.lasttx(),
                    dmarxend: self.dmarxend(),
                    dmarxready: self.dmarxready(),
                    dmarxbuserror: self.dmarxbuserror(),
                    dmarxmatch0: self.dmarxmatch0(),
                    dmarxmatch1: self.dmarxmatch1(),
                    dmarxmatch2: self.dmarxmatch2(),
                    dmarxmatch3: self.dmarxmatch3(),
                    dmatxend: self.dmatxend(),
                    dmatxready: self.dmatxready(),
                    dmatxbuserror: self.dmatxbuserror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxAmount {
                    amount: u16,
                }
                let proxy = RxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = RxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = RxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event LASTTX and task DMA.RX.START"]
            #[inline(always)]
            pub const fn lasttx_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task DMA.RX.START"]
            #[inline(always)]
            pub fn set_lasttx_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[inline(always)]
            pub const fn lasttx_suspend(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task SUSPEND"]
            #[inline(always)]
            pub fn set_lasttx_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[inline(always)]
            pub const fn lasttx_stop(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTTX and task STOP"]
            #[inline(always)]
            pub fn set_lasttx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Shortcut between event LASTRX and task DMA.TX.START"]
            #[inline(always)]
            pub const fn lastrx_dma_tx_start(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task DMA.TX.START"]
            #[inline(always)]
            pub fn set_lastrx_dma_tx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[inline(always)]
            pub const fn lastrx_stop(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event LASTRX and task STOP"]
            #[inline(always)]
            pub fn set_lastrx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("lasttx_dma_rx_start", &self.lasttx_dma_rx_start())
                    .field("lasttx_suspend", &self.lasttx_suspend())
                    .field("lasttx_stop", &self.lasttx_stop())
                    .field("lastrx_dma_tx_start", &self.lastrx_dma_tx_start())
                    .field("lastrx_stop", &self.lastrx_stop())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    lasttx_dma_rx_start: bool,
                    lasttx_suspend: bool,
                    lasttx_stop: bool,
                    lastrx_dma_tx_start: bool,
                    lastrx_stop: bool,
                    dma_rx_match0_dma_rx_enablematch1: bool,
                    dma_rx_match1_dma_rx_enablematch2: bool,
                    dma_rx_match2_dma_rx_enablematch3: bool,
                    dma_rx_match3_dma_rx_enablematch0: bool,
                    dma_rx_match0_dma_rx_disablematch0: bool,
                    dma_rx_match1_dma_rx_disablematch1: bool,
                    dma_rx_match2_dma_rx_disablematch2: bool,
                    dma_rx_match3_dma_rx_disablematch3: bool,
                }
                let proxy = Shorts {
                    lasttx_dma_rx_start: self.lasttx_dma_rx_start(),
                    lasttx_suspend: self.lasttx_suspend(),
                    lasttx_stop: self.lasttx_stop(),
                    lastrx_dma_tx_start: self.lastrx_dma_tx_start(),
                    lastrx_stop: self.lastrx_stop(),
                    dma_rx_match0_dma_rx_enablematch1: self.dma_rx_match0_dma_rx_enablematch1(),
                    dma_rx_match1_dma_rx_enablematch2: self.dma_rx_match1_dma_rx_enablematch2(),
                    dma_rx_match2_dma_rx_enablematch3: self.dma_rx_match2_dma_rx_enablematch3(),
                    dma_rx_match3_dma_rx_enablematch0: self.dma_rx_match3_dma_rx_enablematch0(),
                    dma_rx_match0_dma_rx_disablematch0: self.dma_rx_match0_dma_rx_disablematch0(),
                    dma_rx_match1_dma_rx_disablematch1: self.dma_rx_match1_dma_rx_disablematch1(),
                    dma_rx_match2_dma_rx_disablematch2: self.dma_rx_match2_dma_rx_disablematch2(),
                    dma_rx_match3_dma_rx_disablematch3: self.dma_rx_match3_dma_rx_disablematch3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxAmount {
                    amount: u16,
                }
                let proxy = TxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = TxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = TxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIM"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            #[doc = "Enable TWIM"]
            ENABLED = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Frequency(pub u32);
        impl Frequency {
            #[doc = "100 kbps"]
            pub const K100: Self = Self(0x0198_0000);
            #[doc = "250 kbps"]
            pub const K250: Self = Self(0x0400_0000);
            #[doc = "400 kbps"]
            pub const K400: Self = Self(0x0640_0000);
        }
        impl Frequency {
            pub const fn from_bits(val: u32) -> Frequency {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Frequency {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0198_0000 => f.write_str("K100"),
                    0x0400_0000 => f.write_str("K250"),
                    0x0640_0000 => f.write_str("K400"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frequency {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0198_0000 => defmt::write!(f, "K100"),
                    0x0400_0000 => defmt::write!(f, "K250"),
                    0x0640_0000 => defmt::write!(f, "K400"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Frequency {
            #[inline(always)]
            fn from(val: u32) -> Frequency {
                Frequency::from_bits(val)
            }
        }
        impl From<Frequency> for u32 {
            #[inline(always)]
            fn from(val: Frequency) -> u32 {
                Frequency::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
    }
}
pub mod twis {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for SCL signal"]
        #[inline(always)]
        pub const fn scl(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for SDA signal"]
        #[inline(always)]
        pub const fn sda(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize + n * 4usize) as _) }
        }
    }
    #[doc = "I2C compatible Two-Wire Slave Interface with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Twis {
        ptr: *mut u8,
    }
    unsafe impl Send for Twis {}
    unsafe impl Sync for Twis {}
    impl Twis {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Stop TWI transaction"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Suspend TWI transaction"]
        #[inline(always)]
        pub const fn tasks_suspend(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Resume TWI transaction"]
        #[inline(always)]
        pub const fn tasks_resume(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a write command"]
        #[inline(always)]
        pub const fn tasks_preparerx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Prepare the TWI slave to respond to a read command"]
        #[inline(always)]
        pub const fn tasks_preparetx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x24usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x30usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Subscribe configuration for task SUSPEND"]
        #[inline(always)]
        pub const fn subscribe_suspend(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x8cusize) as _) }
        }
        #[doc = "Subscribe configuration for task RESUME"]
        #[inline(always)]
        pub const fn subscribe_resume(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x90usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARERX"]
        #[inline(always)]
        pub const fn subscribe_preparerx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa0usize) as _) }
        }
        #[doc = "Subscribe configuration for task PREPARETX"]
        #[inline(always)]
        pub const fn subscribe_preparetx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xa4usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xb0usize) as _) }
        }
        #[doc = "TWI stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "TWI error"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Write command received"]
        #[inline(always)]
        pub const fn events_write(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x013cusize) as _) }
        }
        #[doc = "Read command received"]
        #[inline(always)]
        pub const fn events_read(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0140usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event WRITE"]
        #[inline(always)]
        pub const fn publish_write(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01bcusize) as _) }
        }
        #[doc = "Publish configuration for event READ"]
        #[inline(always)]
        pub const fn publish_read(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01c0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04d0usize) as _) }
        }
        #[doc = "Status register indicating which address had a match"]
        #[inline(always)]
        pub const fn match_(self) -> crate::common::Reg<regs::TwisMatch, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04d4usize) as _) }
        }
        #[doc = "Enable TWIS"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Description collection: TWI slave address n"]
        #[inline(always)]
        pub const fn address(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::Address, crate::common::RW> {
            assert!(n < 2usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0588usize + n * 4usize) as _) }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::TwisConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0594usize) as _) }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[inline(always)]
        pub const fn orc(self) -> crate::common::Reg<regs::Orc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x05c0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0600usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description collection: TWI slave address n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "TWI slave address"]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x7f;
                val as u8
            }
            #[doc = "TWI slave address"]
            #[inline(always)]
            pub fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 0usize)) | (((val as u32) & 0x7f) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Address {
                    address: u8,
                }
                let proxy = Address {
                    address: self.address(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable TWIS"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable TWIS"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable TWIS"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub const fn overflow(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "RX buffer overflow detected, and prevented"]
            #[inline(always)]
            pub fn set_overflow(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[inline(always)]
            pub const fn dnack(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "NACK sent after receiving a data byte"]
            #[inline(always)]
            pub fn set_dnack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub const fn overread(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "TX buffer over-read detected, and prevented"]
            #[inline(always)]
            pub fn set_overread(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overflow", &self.overflow())
                    .field("dnack", &self.dnack())
                    .field("overread", &self.overread())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorsrc {
                    overflow: bool,
                    dnack: bool,
                    overread: bool,
                }
                let proxy = Errorsrc {
                    overflow: self.overflow(),
                    dnack: self.dnack(),
                    overread: self.overread(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event WRITE"]
            #[inline(always)]
            pub fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event READ"]
            #[inline(always)]
            pub fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("stopped", &self.stopped())
                    .field("error", &self.error())
                    .field("write", &self.write())
                    .field("read", &self.read())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    stopped: bool,
                    error: bool,
                    write: bool,
                    read: bool,
                    dmarxend: bool,
                    dmarxready: bool,
                    dmarxbuserror: bool,
                    dmarxmatch0: bool,
                    dmarxmatch1: bool,
                    dmarxmatch2: bool,
                    dmarxmatch3: bool,
                    dmatxend: bool,
                    dmatxready: bool,
                    dmatxbuserror: bool,
                }
                let proxy = Int {
                    stopped: self.stopped(),
                    error: self.error(),
                    write: self.write(),
                    read: self.read(),
                    dmarxend: self.dmarxend(),
                    dmarxready: self.dmarxready(),
                    dmarxbuserror: self.dmarxbuserror(),
                    dmarxmatch0: self.dmarxmatch0(),
                    dmarxmatch1: self.dmarxmatch1(),
                    dmarxmatch2: self.dmarxmatch2(),
                    dmarxmatch3: self.dmarxmatch3(),
                    dmatxend: self.dmatxend(),
                    dmatxready: self.dmatxready(),
                    dmatxbuserror: self.dmatxbuserror(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct MatchConfig {
                    enable_0: bool,
                    enable_1: bool,
                    enable_2: bool,
                    enable_3: bool,
                    oneshot_0: super::vals::Oneshot0,
                    oneshot_1: super::vals::Oneshot1,
                    oneshot_2: super::vals::Oneshot2,
                    oneshot_3: super::vals::Oneshot3,
                }
                let proxy = MatchConfig {
                    enable_0: self.enable_0(),
                    enable_1: self.enable_1(),
                    enable_2: self.enable_2(),
                    enable_3: self.enable_3(),
                    oneshot_0: self.oneshot_0(),
                    oneshot_1: self.oneshot_1(),
                    oneshot_2: self.oneshot_2(),
                    oneshot_3: self.oneshot_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Orc(pub u32);
        impl Orc {
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[inline(always)]
            pub const fn orc(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Over-read character. Character sent out in case of an over-read of the transmit buffer."]
            #[inline(always)]
            pub fn set_orc(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Orc {
            #[inline(always)]
            fn default() -> Orc {
                Orc(0)
            }
        }
        impl core::fmt::Debug for Orc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Orc").field("orc", &self.orc()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Orc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Orc {
                    orc: u8,
                }
                let proxy = Orc { orc: self.orc() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxAmount {
                    amount: u16,
                }
                let proxy = RxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = RxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = RxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[inline(always)]
            pub const fn write_suspend(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event WRITE and task SUSPEND"]
            #[inline(always)]
            pub fn set_write_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[inline(always)]
            pub const fn read_suspend(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event READ and task SUSPEND"]
            #[inline(always)]
            pub fn set_read_suspend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("write_suspend", &self.write_suspend())
                    .field("read_suspend", &self.read_suspend())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    write_suspend: bool,
                    read_suspend: bool,
                    dma_rx_match0_dma_rx_enablematch1: bool,
                    dma_rx_match1_dma_rx_enablematch2: bool,
                    dma_rx_match2_dma_rx_enablematch3: bool,
                    dma_rx_match3_dma_rx_enablematch0: bool,
                    dma_rx_match0_dma_rx_disablematch0: bool,
                    dma_rx_match1_dma_rx_disablematch1: bool,
                    dma_rx_match2_dma_rx_disablematch2: bool,
                    dma_rx_match3_dma_rx_disablematch3: bool,
                }
                let proxy = Shorts {
                    write_suspend: self.write_suspend(),
                    read_suspend: self.read_suspend(),
                    dma_rx_match0_dma_rx_enablematch1: self.dma_rx_match0_dma_rx_enablematch1(),
                    dma_rx_match1_dma_rx_enablematch2: self.dma_rx_match1_dma_rx_enablematch2(),
                    dma_rx_match2_dma_rx_enablematch3: self.dma_rx_match2_dma_rx_enablematch3(),
                    dma_rx_match3_dma_rx_enablematch0: self.dma_rx_match3_dma_rx_enablematch0(),
                    dma_rx_match0_dma_rx_disablematch0: self.dma_rx_match0_dma_rx_disablematch0(),
                    dma_rx_match1_dma_rx_disablematch1: self.dma_rx_match1_dma_rx_disablematch1(),
                    dma_rx_match2_dma_rx_disablematch2: self.dma_rx_match2_dma_rx_disablematch2(),
                    dma_rx_match3_dma_rx_disablematch3: self.dma_rx_match3_dma_rx_disablematch3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration register for the address match mechanism"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TwisConfig(pub u32);
        impl TwisConfig {
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[inline(always)]
            pub const fn address0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[0\\]"]
            #[inline(always)]
            pub fn set_address0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[inline(always)]
            pub const fn address1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable address matching on ADDRESS\\[1\\]"]
            #[inline(always)]
            pub fn set_address1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for TwisConfig {
            #[inline(always)]
            fn default() -> TwisConfig {
                TwisConfig(0)
            }
        }
        impl core::fmt::Debug for TwisConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TwisConfig")
                    .field("address0", &self.address0())
                    .field("address1", &self.address1())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TwisConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TwisConfig {
                    address0: bool,
                    address1: bool,
                }
                let proxy = TwisConfig {
                    address0: self.address0(),
                    address1: self.address1(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Status register indicating which address had a match"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TwisMatch(pub u32);
        impl TwisMatch {
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[inline(always)]
            pub const fn match_(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indication of which address in ADDRESS that matched the incoming address"]
            #[inline(always)]
            pub fn set_match_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TwisMatch {
            #[inline(always)]
            fn default() -> TwisMatch {
                TwisMatch(0)
            }
        }
        impl core::fmt::Debug for TwisMatch {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TwisMatch")
                    .field("match_", &self.match_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TwisMatch {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TwisMatch {
                    match_: bool,
                }
                let proxy = TwisMatch {
                    match_: self.match_(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxAmount {
                    amount: u16,
                }
                let proxy = TxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = TxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = TxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable TWIS"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            #[doc = "Enable TWIS"]
            ENABLED = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
    }
}
pub mod uarte {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Dma {
        ptr: *mut u8,
    }
    unsafe impl Send for Dma {}
    unsafe impl Sync for Dma {}
    impl Dma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn rx(self) -> DmaRx {
            unsafe { DmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn tx(self) -> DmaTx {
            unsafe { DmaTx::from_ptr(self.ptr.add(0x38usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaRx {}
    unsafe impl Sync for DmaRx {}
    impl DmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::RxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::RxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::RxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
        #[doc = "Registers to control the behavior of the pattern matcher engine"]
        #[inline(always)]
        pub const fn match_(self) -> Match {
            unsafe { Match::from_ptr(self.ptr.add(0x24usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct DmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for DmaTx {}
    unsafe impl Sync for DmaTx {}
    impl DmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "RAM buffer start address"]
        #[inline(always)]
        pub const fn ptr(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[inline(always)]
        pub const fn maxcnt(self) -> crate::common::Reg<regs::TxMaxcnt, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[inline(always)]
        pub const fn amount(self) -> crate::common::Reg<regs::TxAmount, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[inline(always)]
        pub const fn terminateonbuserror(
            self,
        ) -> crate::common::Reg<regs::TxTerminateonbuserror, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Address of transaction that generated the last BUSERROR event."]
        #[inline(always)]
        pub const fn buserroraddress(self) -> crate::common::Reg<u32, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDma {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDma {}
    unsafe impl Sync for EventsDma {}
    impl EventsDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn rx(self) -> EventsDmaRx {
            unsafe { EventsDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn tx(self) -> EventsDmaTx {
            unsafe { EventsDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaRx {}
    unsafe impl Sync for EventsDmaRx {}
    impl EventsDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Pattern match is detected on the DMA data bus."]
        #[inline(always)]
        pub const fn match_(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral events."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct EventsDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for EventsDmaTx {}
    unsafe impl Sync for EventsDmaTx {}
    impl EventsDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Generated after all MAXCNT bytes have been transferred"]
        #[inline(always)]
        pub const fn end(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Generated when EasyDMA has buffered the .PTR and .MAXCNT registers for the channel, allowing them to be written to prepare for the next sequence."]
        #[inline(always)]
        pub const fn ready(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "An error occured during the bus transfer."]
        #[inline(always)]
        pub const fn buserror(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Registers to control the behavior of the pattern matcher engine"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Match {
        ptr: *mut u8,
    }
    unsafe impl Send for Match {}
    unsafe impl Sync for Match {}
    impl Match {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Configure individual match events"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::MatchConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description collection: The data to look for - any match will trigger the MATCH\\[n\\] event, if enabled."]
        #[inline(always)]
        pub const fn candidate(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Psel {
        ptr: *mut u8,
    }
    unsafe impl Send for Psel {}
    unsafe impl Sync for Psel {}
    impl Psel {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Pin select for TXD signal"]
        #[inline(always)]
        pub const fn txd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Pin select for CTS signal"]
        #[inline(always)]
        pub const fn cts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Pin select for RXD signal"]
        #[inline(always)]
        pub const fn rxd(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Pin select for RTS signal"]
        #[inline(always)]
        pub const fn rts(self) -> crate::common::Reg<super::shared::regs::Psel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDma {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDma {}
    unsafe impl Sync for PublishDma {}
    impl PublishDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn rx(self) -> PublishDmaRx {
            unsafe { PublishDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn tx(self) -> PublishDmaTx {
            unsafe { PublishDmaTx::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaRx {}
    unsafe impl Sync for PublishDmaRx {}
    impl PublishDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event MATCH\\[n\\]"]
        #[inline(always)]
        pub const fn match_(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0cusize + n * 4usize) as _) }
        }
    }
    #[doc = "Publish configuration for events"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct PublishDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for PublishDmaTx {}
    unsafe impl Sync for PublishDmaTx {}
    impl PublishDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Publish configuration for event END"]
        #[inline(always)]
        pub const fn end(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Publish configuration for event READY"]
        #[inline(always)]
        pub const fn ready(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Publish configuration for event BUSERROR"]
        #[inline(always)]
        pub const fn buserror(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDma {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDma {}
    unsafe impl Sync for SubscribeDma {}
    impl SubscribeDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn rx(self) -> SubscribeDmaRx {
            unsafe { SubscribeDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn tx(self) -> SubscribeDmaTx {
            unsafe { SubscribeDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaRx {}
    unsafe impl Sync for SubscribeDmaRx {}
    impl SubscribeDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task ENABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn enablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task DISABLEMATCH\\[n\\]"]
        #[inline(always)]
        pub const fn disablematch(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Subscribe configuration for tasks"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct SubscribeDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for SubscribeDmaTx {}
    unsafe impl Sync for SubscribeDmaTx {}
    impl SubscribeDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDma {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDma {}
    unsafe impl Sync for TasksDma {}
    impl TasksDma {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn rx(self) -> TasksDmaRx {
            unsafe { TasksDmaRx::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tx(self) -> TasksDmaTx {
            unsafe { TasksDmaTx::from_ptr(self.ptr.add(0x28usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaRx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaRx {}
    unsafe impl Sync for TasksDmaRx {}
    impl TasksDmaRx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Description collection: Enables the MATCH\\[n\\] event by setting the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn enablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x08usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Disables the MATCH\\[n\\] event by clearing the ENABLE\\[n\\] bit in the CONFIG register."]
        #[inline(always)]
        pub const fn disablematch(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x18usize + n * 4usize) as _) }
        }
    }
    #[doc = "Peripheral tasks."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct TasksDmaTx {
        ptr: *mut u8,
    }
    unsafe impl Send for TasksDmaTx {}
    unsafe impl Sync for TasksDmaTx {}
    impl TasksDmaTx {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Starts operation using easyDMA to load the values. See peripheral description for operation using easyDMA."]
        #[inline(always)]
        pub const fn start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stops operation using easyDMA. This does not trigger an END event."]
        #[inline(always)]
        pub const fn stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
    }
    #[doc = "UART with EasyDMA 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uarte {
        ptr: *mut u8,
    }
    unsafe impl Send for Uarte {}
    unsafe impl Sync for Uarte {}
    impl Uarte {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Flush RX FIFO into RX buffer"]
        #[inline(always)]
        pub const fn tasks_flushrx(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
        #[doc = "Peripheral tasks."]
        #[inline(always)]
        pub const fn tasks_dma(self) -> TasksDma {
            unsafe { TasksDma::from_ptr(self.ptr.add(0x28usize) as _) }
        }
        #[doc = "Subscribe configuration for task FLUSHRX"]
        #[inline(always)]
        pub const fn subscribe_flushrx(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x9cusize) as _) }
        }
        #[doc = "Subscribe configuration for tasks"]
        #[inline(always)]
        pub const fn subscribe_dma(self) -> SubscribeDma {
            unsafe { SubscribeDma::from_ptr(self.ptr.add(0xa8usize) as _) }
        }
        #[doc = "CTS is activated (set low). Clear To Send."]
        #[inline(always)]
        pub const fn events_cts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "CTS is deactivated (set high). Not Clear To Send."]
        #[inline(always)]
        pub const fn events_ncts(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Data sent from TXD"]
        #[inline(always)]
        pub const fn events_txdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x010cusize) as _) }
        }
        #[doc = "Data received in RXD (but potentially not yet transferred to Data RAM)"]
        #[inline(always)]
        pub const fn events_rxdrdy(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0110usize) as _) }
        }
        #[doc = "Error detected"]
        #[inline(always)]
        pub const fn events_error(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0114usize) as _) }
        }
        #[doc = "Receiver timeout"]
        #[inline(always)]
        pub const fn events_rxto(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0124usize) as _) }
        }
        #[doc = "Transmitter stopped"]
        #[inline(always)]
        pub const fn events_txstopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0130usize) as _) }
        }
        #[doc = "Peripheral events."]
        #[inline(always)]
        pub const fn events_dma(self) -> EventsDma {
            unsafe { EventsDma::from_ptr(self.ptr.add(0x014cusize) as _) }
        }
        #[doc = "Timed out due to bus being idle while receiving data."]
        #[inline(always)]
        pub const fn events_frametimeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0174usize) as _) }
        }
        #[doc = "Publish configuration for event CTS"]
        #[inline(always)]
        pub const fn publish_cts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event NCTS"]
        #[inline(always)]
        pub const fn publish_ncts(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Publish configuration for event TXDRDY"]
        #[inline(always)]
        pub const fn publish_txdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x018cusize) as _) }
        }
        #[doc = "Publish configuration for event RXDRDY"]
        #[inline(always)]
        pub const fn publish_rxdrdy(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0190usize) as _) }
        }
        #[doc = "Publish configuration for event ERROR"]
        #[inline(always)]
        pub const fn publish_error(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0194usize) as _) }
        }
        #[doc = "Publish configuration for event RXTO"]
        #[inline(always)]
        pub const fn publish_rxto(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01a4usize) as _) }
        }
        #[doc = "Publish configuration for event TXSTOPPED"]
        #[inline(always)]
        pub const fn publish_txstopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01b0usize) as _) }
        }
        #[doc = "Publish configuration for events"]
        #[inline(always)]
        pub const fn publish_dma(self) -> PublishDma {
            unsafe { PublishDma::from_ptr(self.ptr.add(0x01ccusize) as _) }
        }
        #[doc = "Publish configuration for event FRAMETIMEOUT"]
        #[inline(always)]
        pub const fn publish_frametimeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x01f4usize) as _) }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[inline(always)]
        pub const fn shorts(self) -> crate::common::Reg<regs::Shorts, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Error source"]
        #[inline(always)]
        pub const fn errorsrc(self) -> crate::common::Reg<regs::Errorsrc, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0480usize) as _) }
        }
        #[doc = "Enable UART"]
        #[inline(always)]
        pub const fn enable(self) -> crate::common::Reg<regs::Enable, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize) as _) }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[inline(always)]
        pub const fn baudrate(self) -> crate::common::Reg<regs::Baudrate, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0524usize) as _) }
        }
        #[doc = "Configuration of parity, hardware flow control, framesize, and packet timeout."]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::UarteConfig, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x056cusize) as _) }
        }
        #[doc = "Set the address of the UARTE for RX when used in 9 bit data frame mode."]
        #[inline(always)]
        pub const fn address(self) -> crate::common::Reg<regs::Address, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0574usize) as _) }
        }
        #[doc = "Set the number of UARTE bits to count before triggering packet timeout."]
        #[inline(always)]
        pub const fn frametimeout(
            self,
        ) -> crate::common::Reg<regs::Frametimeout, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0578usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn psel(self) -> Psel {
            unsafe { Psel::from_ptr(self.ptr.add(0x0604usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn dma(self) -> Dma {
            unsafe { Dma::from_ptr(self.ptr.add(0x0700usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Set the address of the UARTE for RX when used in 9 bit data frame mode."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Address(pub u32);
        impl Address {
            #[doc = "Set address"]
            #[inline(always)]
            pub const fn address(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0xff;
                val as u8
            }
            #[doc = "Set address"]
            #[inline(always)]
            pub fn set_address(&mut self, val: u8) {
                self.0 = (self.0 & !(0xff << 0usize)) | (((val as u32) & 0xff) << 0usize);
            }
        }
        impl Default for Address {
            #[inline(always)]
            fn default() -> Address {
                Address(0)
            }
        }
        impl core::fmt::Debug for Address {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Address")
                    .field("address", &self.address())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Address {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Address {
                    address: u8,
                }
                let proxy = Address {
                    address: self.address(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Baud rate. Accuracy depends on the HFCLK source selected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Baudrate(pub u32);
        impl Baudrate {
            #[doc = "Baud rate"]
            #[inline(always)]
            pub const fn baudrate(&self) -> super::vals::Baudrate {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Baudrate::from_bits(val as u32)
            }
            #[doc = "Baud rate"]
            #[inline(always)]
            pub fn set_baudrate(&mut self, val: super::vals::Baudrate) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Baudrate {
            #[inline(always)]
            fn default() -> Baudrate {
                Baudrate(0)
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Baudrate")
                    .field("baudrate", &self.baudrate())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Baudrate {
                    baudrate: super::vals::Baudrate,
                }
                let proxy = Baudrate {
                    baudrate: self.baudrate(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable UART"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Enable(pub u32);
        impl Enable {
            #[doc = "Enable or disable UARTE"]
            #[inline(always)]
            pub const fn enable(&self) -> super::vals::Enable {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Enable::from_bits(val as u8)
            }
            #[doc = "Enable or disable UARTE"]
            #[inline(always)]
            pub fn set_enable(&mut self, val: super::vals::Enable) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
        }
        impl Default for Enable {
            #[inline(always)]
            fn default() -> Enable {
                Enable(0)
            }
        }
        impl core::fmt::Debug for Enable {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Enable")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Enable {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Enable {
                    enable: super::vals::Enable,
                }
                let proxy = Enable {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Error source"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Errorsrc(pub u32);
        impl Errorsrc {
            #[doc = "Overrun error"]
            #[inline(always)]
            pub const fn overrun(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Overrun error"]
            #[inline(always)]
            pub fn set_overrun(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity error"]
            #[inline(always)]
            pub const fn parity(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Parity error"]
            #[inline(always)]
            pub fn set_parity(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Framing error occurred"]
            #[inline(always)]
            pub const fn framing(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Framing error occurred"]
            #[inline(always)]
            pub fn set_framing(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Break condition"]
            #[inline(always)]
            pub const fn break_(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Break condition"]
            #[inline(always)]
            pub fn set_break_(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
        }
        impl Default for Errorsrc {
            #[inline(always)]
            fn default() -> Errorsrc {
                Errorsrc(0)
            }
        }
        impl core::fmt::Debug for Errorsrc {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Errorsrc")
                    .field("overrun", &self.overrun())
                    .field("parity", &self.parity())
                    .field("framing", &self.framing())
                    .field("break_", &self.break_())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Errorsrc {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Errorsrc {
                    overrun: bool,
                    parity: bool,
                    framing: bool,
                    break_: bool,
                }
                let proxy = Errorsrc {
                    overrun: self.overrun(),
                    parity: self.parity(),
                    framing: self.framing(),
                    break_: self.break_(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Set the number of UARTE bits to count before triggering packet timeout."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Frametimeout(pub u32);
        impl Frametimeout {
            #[doc = "Number of UARTE bits before timeout."]
            #[inline(always)]
            pub const fn countertop(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x03ff;
                val as u16
            }
            #[doc = "Number of UARTE bits before timeout."]
            #[inline(always)]
            pub fn set_countertop(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 0usize)) | (((val as u32) & 0x03ff) << 0usize);
            }
        }
        impl Default for Frametimeout {
            #[inline(always)]
            fn default() -> Frametimeout {
                Frametimeout(0)
            }
        }
        impl core::fmt::Debug for Frametimeout {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Frametimeout")
                    .field("countertop", &self.countertop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Frametimeout {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Frametimeout {
                    countertop: u16,
                }
                let proxy = Frametimeout {
                    countertop: self.countertop(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event CTS"]
            #[inline(always)]
            pub const fn cts(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event CTS"]
            #[inline(always)]
            pub fn set_cts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[inline(always)]
            pub const fn ncts(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event NCTS"]
            #[inline(always)]
            pub fn set_ncts(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[inline(always)]
            pub const fn txdrdy(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXDRDY"]
            #[inline(always)]
            pub fn set_txdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[inline(always)]
            pub const fn rxdrdy(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXDRDY"]
            #[inline(always)]
            pub fn set_rxdrdy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub const fn error(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event ERROR"]
            #[inline(always)]
            pub fn set_error(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[inline(always)]
            pub const fn rxto(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event RXTO"]
            #[inline(always)]
            pub fn set_rxto(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[inline(always)]
            pub const fn txstopped(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TXSTOPPED"]
            #[inline(always)]
            pub fn set_txstopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub const fn dmarxend(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXEND"]
            #[inline(always)]
            pub fn set_dmarxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub const fn dmarxready(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXREADY"]
            #[inline(always)]
            pub fn set_dmarxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub const fn dmarxbuserror(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXBUSERROR"]
            #[inline(always)]
            pub fn set_dmarxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub const fn dmarxmatch0(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[0\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub const fn dmarxmatch1(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[1\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub const fn dmarxmatch2(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[2\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub const fn dmarxmatch3(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMARXMATCH\\[3\\]"]
            #[inline(always)]
            pub fn set_dmarxmatch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub const fn dmatxend(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXEND"]
            #[inline(always)]
            pub fn set_dmatxend(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub const fn dmatxready(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXREADY"]
            #[inline(always)]
            pub fn set_dmatxready(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub const fn dmatxbuserror(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event DMATXBUSERROR"]
            #[inline(always)]
            pub fn set_dmatxbuserror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Enable or disable interrupt for event FRAMETIMEOUT"]
            #[inline(always)]
            pub const fn frametimeout(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event FRAMETIMEOUT"]
            #[inline(always)]
            pub fn set_frametimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("cts", &self.cts())
                    .field("ncts", &self.ncts())
                    .field("txdrdy", &self.txdrdy())
                    .field("rxdrdy", &self.rxdrdy())
                    .field("error", &self.error())
                    .field("rxto", &self.rxto())
                    .field("txstopped", &self.txstopped())
                    .field("dmarxend", &self.dmarxend())
                    .field("dmarxready", &self.dmarxready())
                    .field("dmarxbuserror", &self.dmarxbuserror())
                    .field("dmarxmatch0", &self.dmarxmatch0())
                    .field("dmarxmatch1", &self.dmarxmatch1())
                    .field("dmarxmatch2", &self.dmarxmatch2())
                    .field("dmarxmatch3", &self.dmarxmatch3())
                    .field("dmatxend", &self.dmatxend())
                    .field("dmatxready", &self.dmatxready())
                    .field("dmatxbuserror", &self.dmatxbuserror())
                    .field("frametimeout", &self.frametimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    cts: bool,
                    ncts: bool,
                    txdrdy: bool,
                    rxdrdy: bool,
                    error: bool,
                    rxto: bool,
                    txstopped: bool,
                    dmarxend: bool,
                    dmarxready: bool,
                    dmarxbuserror: bool,
                    dmarxmatch0: bool,
                    dmarxmatch1: bool,
                    dmarxmatch2: bool,
                    dmarxmatch3: bool,
                    dmatxend: bool,
                    dmatxready: bool,
                    dmatxbuserror: bool,
                    frametimeout: bool,
                }
                let proxy = Int {
                    cts: self.cts(),
                    ncts: self.ncts(),
                    txdrdy: self.txdrdy(),
                    rxdrdy: self.rxdrdy(),
                    error: self.error(),
                    rxto: self.rxto(),
                    txstopped: self.txstopped(),
                    dmarxend: self.dmarxend(),
                    dmarxready: self.dmarxready(),
                    dmarxbuserror: self.dmarxbuserror(),
                    dmarxmatch0: self.dmarxmatch0(),
                    dmarxmatch1: self.dmarxmatch1(),
                    dmarxmatch2: self.dmarxmatch2(),
                    dmarxmatch3: self.dmarxmatch3(),
                    dmatxend: self.dmatxend(),
                    dmatxready: self.dmatxready(),
                    dmatxbuserror: self.dmatxbuserror(),
                    frametimeout: self.frametimeout(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configure individual match events"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct MatchConfig(pub u32);
        impl MatchConfig {
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub const fn enable_0(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 0"]
            #[inline(always)]
            pub fn set_enable_0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub const fn enable_1(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 1"]
            #[inline(always)]
            pub fn set_enable_1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub const fn enable_2(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 2"]
            #[inline(always)]
            pub fn set_enable_2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub const fn enable_3(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Enable match filter 3"]
            #[inline(always)]
            pub fn set_enable_3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_0(&self) -> super::vals::Oneshot0 {
                let val = (self.0 >> 16usize) & 0x01;
                super::vals::Oneshot0::from_bits(val as u8)
            }
            #[doc = "Configure match filter 0 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_0(&mut self, val: super::vals::Oneshot0) {
                self.0 =
                    (self.0 & !(0x01 << 16usize)) | (((val.to_bits() as u32) & 0x01) << 16usize);
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_1(&self) -> super::vals::Oneshot1 {
                let val = (self.0 >> 17usize) & 0x01;
                super::vals::Oneshot1::from_bits(val as u8)
            }
            #[doc = "Configure match filter 1 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_1(&mut self, val: super::vals::Oneshot1) {
                self.0 =
                    (self.0 & !(0x01 << 17usize)) | (((val.to_bits() as u32) & 0x01) << 17usize);
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_2(&self) -> super::vals::Oneshot2 {
                let val = (self.0 >> 18usize) & 0x01;
                super::vals::Oneshot2::from_bits(val as u8)
            }
            #[doc = "Configure match filter 2 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_2(&mut self, val: super::vals::Oneshot2) {
                self.0 =
                    (self.0 & !(0x01 << 18usize)) | (((val.to_bits() as u32) & 0x01) << 18usize);
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub const fn oneshot_3(&self) -> super::vals::Oneshot3 {
                let val = (self.0 >> 19usize) & 0x01;
                super::vals::Oneshot3::from_bits(val as u8)
            }
            #[doc = "Configure match filter 3 as one-shot or sticky"]
            #[inline(always)]
            pub fn set_oneshot_3(&mut self, val: super::vals::Oneshot3) {
                self.0 =
                    (self.0 & !(0x01 << 19usize)) | (((val.to_bits() as u32) & 0x01) << 19usize);
            }
        }
        impl Default for MatchConfig {
            #[inline(always)]
            fn default() -> MatchConfig {
                MatchConfig(0)
            }
        }
        impl core::fmt::Debug for MatchConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("MatchConfig")
                    .field("enable_0", &self.enable_0())
                    .field("enable_1", &self.enable_1())
                    .field("enable_2", &self.enable_2())
                    .field("enable_3", &self.enable_3())
                    .field("oneshot_0", &self.oneshot_0())
                    .field("oneshot_1", &self.oneshot_1())
                    .field("oneshot_2", &self.oneshot_2())
                    .field("oneshot_3", &self.oneshot_3())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for MatchConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct MatchConfig {
                    enable_0: bool,
                    enable_1: bool,
                    enable_2: bool,
                    enable_3: bool,
                    oneshot_0: super::vals::Oneshot0,
                    oneshot_1: super::vals::Oneshot1,
                    oneshot_2: super::vals::Oneshot2,
                    oneshot_3: super::vals::Oneshot3,
                }
                let proxy = MatchConfig {
                    enable_0: self.enable_0(),
                    enable_1: self.enable_1(),
                    enable_2: self.enable_2(),
                    enable_3: self.enable_3(),
                    oneshot_0: self.oneshot_0(),
                    oneshot_1: self.oneshot_1(),
                    oneshot_2: self.oneshot_2(),
                    oneshot_3: self.oneshot_3(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxAmount(pub u32);
        impl RxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxAmount {
            #[inline(always)]
            fn default() -> RxAmount {
                RxAmount(0)
            }
        }
        impl core::fmt::Debug for RxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxAmount {
                    amount: u16,
                }
                let proxy = RxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxMaxcnt(pub u32);
        impl RxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for RxMaxcnt {
            #[inline(always)]
            fn default() -> RxMaxcnt {
                RxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for RxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = RxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct RxTerminateonbuserror(pub u32);
        impl RxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for RxTerminateonbuserror {
            #[inline(always)]
            fn default() -> RxTerminateonbuserror {
                RxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for RxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("RxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for RxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct RxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = RxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Shortcuts between local events and tasks"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Shorts(pub u32);
        impl Shorts {
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.START"]
            #[inline(always)]
            pub const fn dma_rx_end_dma_rx_start(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.START"]
            #[inline(always)]
            pub fn set_dma_rx_end_dma_rx_start(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.STOP"]
            #[inline(always)]
            pub const fn dma_rx_end_dma_rx_stop(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.END and task DMA.RX.STOP"]
            #[inline(always)]
            pub fn set_dma_rx_end_dma_rx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Shortcut between event DMA.TX.END and task DMA.TX.STOP"]
            #[inline(always)]
            pub const fn dma_tx_end_dma_tx_stop(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.TX.END and task DMA.TX.STOP"]
            #[inline(always)]
            pub fn set_dma_tx_end_dma_tx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_enablematch1(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[1\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_enablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_enablematch2(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[2\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_enablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_enablematch3(&self) -> bool {
                let val = (self.0 >> 23usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[3\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_enablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 23usize)) | (((val as u32) & 0x01) << 23usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_enablematch0(&self) -> bool {
                let val = (self.0 >> 24usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.ENABLEMATCH\\[0\\] Allows daisy-chaining match events."]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_enablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 24usize)) | (((val as u32) & 0x01) << 24usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match0_dma_rx_disablematch0(&self) -> bool {
                let val = (self.0 >> 25usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match0_dma_rx_disablematch0(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 25usize)) | (((val as u32) & 0x01) << 25usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match1_dma_rx_disablematch1(&self) -> bool {
                let val = (self.0 >> 26usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match1_dma_rx_disablematch1(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 26usize)) | (((val as u32) & 0x01) << 26usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match2_dma_rx_disablematch2(&self) -> bool {
                let val = (self.0 >> 27usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match2_dma_rx_disablematch2(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 27usize)) | (((val as u32) & 0x01) << 27usize);
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub const fn dma_rx_match3_dma_rx_disablematch3(&self) -> bool {
                let val = (self.0 >> 28usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event DMA.RX.MATCH\\[n\\] and task DMA.RX.DISABLEMATCH\\[n\\]"]
            #[inline(always)]
            pub fn set_dma_rx_match3_dma_rx_disablematch3(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 28usize)) | (((val as u32) & 0x01) << 28usize);
            }
            #[doc = "Shortcut between event FRAMETIMEOUT and task DMA.RX.STOP"]
            #[inline(always)]
            pub const fn frametimeout_dma_rx_stop(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Shortcut between event FRAMETIMEOUT and task DMA.RX.STOP"]
            #[inline(always)]
            pub fn set_frametimeout_dma_rx_stop(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
        }
        impl Default for Shorts {
            #[inline(always)]
            fn default() -> Shorts {
                Shorts(0)
            }
        }
        impl core::fmt::Debug for Shorts {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Shorts")
                    .field("dma_rx_end_dma_rx_start", &self.dma_rx_end_dma_rx_start())
                    .field("dma_rx_end_dma_rx_stop", &self.dma_rx_end_dma_rx_stop())
                    .field("dma_tx_end_dma_tx_stop", &self.dma_tx_end_dma_tx_stop())
                    .field(
                        "dma_rx_match0_dma_rx_enablematch1",
                        &self.dma_rx_match0_dma_rx_enablematch1(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_enablematch2",
                        &self.dma_rx_match1_dma_rx_enablematch2(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_enablematch3",
                        &self.dma_rx_match2_dma_rx_enablematch3(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_enablematch0",
                        &self.dma_rx_match3_dma_rx_enablematch0(),
                    )
                    .field(
                        "dma_rx_match0_dma_rx_disablematch0",
                        &self.dma_rx_match0_dma_rx_disablematch0(),
                    )
                    .field(
                        "dma_rx_match1_dma_rx_disablematch1",
                        &self.dma_rx_match1_dma_rx_disablematch1(),
                    )
                    .field(
                        "dma_rx_match2_dma_rx_disablematch2",
                        &self.dma_rx_match2_dma_rx_disablematch2(),
                    )
                    .field(
                        "dma_rx_match3_dma_rx_disablematch3",
                        &self.dma_rx_match3_dma_rx_disablematch3(),
                    )
                    .field("frametimeout_dma_rx_stop", &self.frametimeout_dma_rx_stop())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Shorts {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Shorts {
                    dma_rx_end_dma_rx_start: bool,
                    dma_rx_end_dma_rx_stop: bool,
                    dma_tx_end_dma_tx_stop: bool,
                    dma_rx_match0_dma_rx_enablematch1: bool,
                    dma_rx_match1_dma_rx_enablematch2: bool,
                    dma_rx_match2_dma_rx_enablematch3: bool,
                    dma_rx_match3_dma_rx_enablematch0: bool,
                    dma_rx_match0_dma_rx_disablematch0: bool,
                    dma_rx_match1_dma_rx_disablematch1: bool,
                    dma_rx_match2_dma_rx_disablematch2: bool,
                    dma_rx_match3_dma_rx_disablematch3: bool,
                    frametimeout_dma_rx_stop: bool,
                }
                let proxy = Shorts {
                    dma_rx_end_dma_rx_start: self.dma_rx_end_dma_rx_start(),
                    dma_rx_end_dma_rx_stop: self.dma_rx_end_dma_rx_stop(),
                    dma_tx_end_dma_tx_stop: self.dma_tx_end_dma_tx_stop(),
                    dma_rx_match0_dma_rx_enablematch1: self.dma_rx_match0_dma_rx_enablematch1(),
                    dma_rx_match1_dma_rx_enablematch2: self.dma_rx_match1_dma_rx_enablematch2(),
                    dma_rx_match2_dma_rx_enablematch3: self.dma_rx_match2_dma_rx_enablematch3(),
                    dma_rx_match3_dma_rx_enablematch0: self.dma_rx_match3_dma_rx_enablematch0(),
                    dma_rx_match0_dma_rx_disablematch0: self.dma_rx_match0_dma_rx_disablematch0(),
                    dma_rx_match1_dma_rx_disablematch1: self.dma_rx_match1_dma_rx_disablematch1(),
                    dma_rx_match2_dma_rx_disablematch2: self.dma_rx_match2_dma_rx_disablematch2(),
                    dma_rx_match3_dma_rx_disablematch3: self.dma_rx_match3_dma_rx_disablematch3(),
                    frametimeout_dma_rx_stop: self.frametimeout_dma_rx_stop(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Number of bytes transferred in the last transaction, updated after the END event. Also updated after each MATCH event."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxAmount(pub u32);
        impl TxAmount {
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub const fn amount(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Number of bytes transferred in the last transaction. In case of NACK error, includes the NACK'ed byte."]
            #[inline(always)]
            pub fn set_amount(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxAmount {
            #[inline(always)]
            fn default() -> TxAmount {
                TxAmount(0)
            }
        }
        impl core::fmt::Debug for TxAmount {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxAmount")
                    .field("amount", &self.amount())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxAmount {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxAmount {
                    amount: u16,
                }
                let proxy = TxAmount {
                    amount: self.amount(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Maximum number of bytes in channel buffer"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxMaxcnt(pub u32);
        impl TxMaxcnt {
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub const fn maxcnt(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0xffff;
                val as u16
            }
            #[doc = "Maximum number of bytes in channel buffer"]
            #[inline(always)]
            pub fn set_maxcnt(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 0usize)) | (((val as u32) & 0xffff) << 0usize);
            }
        }
        impl Default for TxMaxcnt {
            #[inline(always)]
            fn default() -> TxMaxcnt {
                TxMaxcnt(0)
            }
        }
        impl core::fmt::Debug for TxMaxcnt {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxMaxcnt")
                    .field("maxcnt", &self.maxcnt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxMaxcnt {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxMaxcnt {
                    maxcnt: u16,
                }
                let proxy = TxMaxcnt {
                    maxcnt: self.maxcnt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Terminate the transaction if a BUSERROR event is detected."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct TxTerminateonbuserror(pub u32);
        impl TxTerminateonbuserror {
            #[inline(always)]
            pub const fn enable(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_enable(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for TxTerminateonbuserror {
            #[inline(always)]
            fn default() -> TxTerminateonbuserror {
                TxTerminateonbuserror(0)
            }
        }
        impl core::fmt::Debug for TxTerminateonbuserror {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("TxTerminateonbuserror")
                    .field("enable", &self.enable())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for TxTerminateonbuserror {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct TxTerminateonbuserror {
                    enable: bool,
                }
                let proxy = TxTerminateonbuserror {
                    enable: self.enable(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Configuration of parity, hardware flow control, framesize, and packet timeout."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct UarteConfig(pub u32);
        impl UarteConfig {
            #[doc = "Hardware flow control"]
            #[inline(always)]
            pub const fn hwfc(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Hardware flow control"]
            #[inline(always)]
            pub fn set_hwfc(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Parity"]
            #[inline(always)]
            pub const fn parity(&self) -> super::vals::ConfigParity {
                let val = (self.0 >> 1usize) & 0x07;
                super::vals::ConfigParity::from_bits(val as u8)
            }
            #[doc = "Parity"]
            #[inline(always)]
            pub fn set_parity(&mut self, val: super::vals::ConfigParity) {
                self.0 = (self.0 & !(0x07 << 1usize)) | (((val.to_bits() as u32) & 0x07) << 1usize);
            }
            #[doc = "Stop bits"]
            #[inline(always)]
            pub const fn stop(&self) -> super::vals::ConfigStop {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::ConfigStop::from_bits(val as u8)
            }
            #[doc = "Stop bits"]
            #[inline(always)]
            pub fn set_stop(&mut self, val: super::vals::ConfigStop) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Even or odd parity type"]
            #[inline(always)]
            pub const fn paritytype(&self) -> super::vals::Paritytype {
                let val = (self.0 >> 8usize) & 0x01;
                super::vals::Paritytype::from_bits(val as u8)
            }
            #[doc = "Even or odd parity type"]
            #[inline(always)]
            pub fn set_paritytype(&mut self, val: super::vals::Paritytype) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val.to_bits() as u32) & 0x01) << 8usize);
            }
            #[doc = "Set the data frame size"]
            #[inline(always)]
            pub const fn framesize(&self) -> super::vals::Framesize {
                let val = (self.0 >> 9usize) & 0x0f;
                super::vals::Framesize::from_bits(val as u8)
            }
            #[doc = "Set the data frame size"]
            #[inline(always)]
            pub fn set_framesize(&mut self, val: super::vals::Framesize) {
                self.0 = (self.0 & !(0x0f << 9usize)) | (((val.to_bits() as u32) & 0x0f) << 9usize);
            }
            #[doc = "Select if data is trimmed from MSB or LSB end when the data frame size is less than 8."]
            #[inline(always)]
            pub const fn endian(&self) -> super::vals::Endian {
                let val = (self.0 >> 13usize) & 0x01;
                super::vals::Endian::from_bits(val as u8)
            }
            #[doc = "Select if data is trimmed from MSB or LSB end when the data frame size is less than 8."]
            #[inline(always)]
            pub fn set_endian(&mut self, val: super::vals::Endian) {
                self.0 =
                    (self.0 & !(0x01 << 13usize)) | (((val.to_bits() as u32) & 0x01) << 13usize);
            }
            #[doc = "Enable packet timeout."]
            #[inline(always)]
            pub const fn frametimeout(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Enable packet timeout."]
            #[inline(always)]
            pub fn set_frametimeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
        }
        impl Default for UarteConfig {
            #[inline(always)]
            fn default() -> UarteConfig {
                UarteConfig(0)
            }
        }
        impl core::fmt::Debug for UarteConfig {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("UarteConfig")
                    .field("hwfc", &self.hwfc())
                    .field("parity", &self.parity())
                    .field("stop", &self.stop())
                    .field("paritytype", &self.paritytype())
                    .field("framesize", &self.framesize())
                    .field("endian", &self.endian())
                    .field("frametimeout", &self.frametimeout())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for UarteConfig {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct UarteConfig {
                    hwfc: bool,
                    parity: super::vals::ConfigParity,
                    stop: super::vals::ConfigStop,
                    paritytype: super::vals::Paritytype,
                    framesize: super::vals::Framesize,
                    endian: super::vals::Endian,
                    frametimeout: bool,
                }
                let proxy = UarteConfig {
                    hwfc: self.hwfc(),
                    parity: self.parity(),
                    stop: self.stop(),
                    paritytype: self.paritytype(),
                    framesize: self.framesize(),
                    endian: self.endian(),
                    frametimeout: self.frametimeout(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Baudrate(pub u32);
        impl Baudrate {
            #[doc = "1200 baud (actual rate: 1205) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD1200: Self = Self(0x0004_f000);
            #[doc = "2400 baud (actual rate: 2396) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD2400: Self = Self(0x0009_d000);
            #[doc = "4800 baud (actual rate: 4808) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD4800: Self = Self(0x0013_b000);
            #[doc = "9600 baud (actual rate: 9598) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD9600: Self = Self(0x0027_5000);
            #[doc = "14400 baud (actual rate: 14401) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD14400: Self = Self(0x003a_f000);
            #[doc = "19200 baud (actual rate: 19208) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD19200: Self = Self(0x004e_a000);
            #[doc = "28800 baud (actual rate: 28777) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD28800: Self = Self(0x0075_c000);
            #[doc = "31250 baud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD31250: Self = Self(0x0080_0000);
            #[doc = "38400 baud (actual rate: 38369) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD38400: Self = Self(0x009d_0000);
            #[doc = "56000 baud (actual rate: 55944) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD56000: Self = Self(0x00e5_0000);
            #[doc = "57600 baud (actual rate: 57554) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD57600: Self = Self(0x00eb_0000);
            #[doc = "76800 baud (actual rate: 76923) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD76800: Self = Self(0x013a_9000);
            #[doc = "115200 baud (actual rate: 115108) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD115200: Self = Self(0x01d6_0000);
            #[doc = "230400 baud (actual rate: 231884) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD230400: Self = Self(0x03b0_0000);
            #[doc = "250000 baud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD250000: Self = Self(0x0400_0000);
            #[doc = "460800 baud (actual rate: 457143) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD460800: Self = Self(0x0740_0000);
            #[doc = "921600 baud (actual rate: 941176) when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD921600: Self = Self(0x0f00_0000);
            #[doc = "1 megabaud when UARTE has 16 MHz peripheral clock frequency"]
            pub const BAUD1M: Self = Self(0x1000_0000);
        }
        impl Baudrate {
            pub const fn from_bits(val: u32) -> Baudrate {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Baudrate {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0004_f000 => f.write_str("BAUD1200"),
                    0x0009_d000 => f.write_str("BAUD2400"),
                    0x0013_b000 => f.write_str("BAUD4800"),
                    0x0027_5000 => f.write_str("BAUD9600"),
                    0x003a_f000 => f.write_str("BAUD14400"),
                    0x004e_a000 => f.write_str("BAUD19200"),
                    0x0075_c000 => f.write_str("BAUD28800"),
                    0x0080_0000 => f.write_str("BAUD31250"),
                    0x009d_0000 => f.write_str("BAUD38400"),
                    0x00e5_0000 => f.write_str("BAUD56000"),
                    0x00eb_0000 => f.write_str("BAUD57600"),
                    0x013a_9000 => f.write_str("BAUD76800"),
                    0x01d6_0000 => f.write_str("BAUD115200"),
                    0x03b0_0000 => f.write_str("BAUD230400"),
                    0x0400_0000 => f.write_str("BAUD250000"),
                    0x0740_0000 => f.write_str("BAUD460800"),
                    0x0f00_0000 => f.write_str("BAUD921600"),
                    0x1000_0000 => f.write_str("BAUD1M"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Baudrate {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0004_f000 => defmt::write!(f, "BAUD1200"),
                    0x0009_d000 => defmt::write!(f, "BAUD2400"),
                    0x0013_b000 => defmt::write!(f, "BAUD4800"),
                    0x0027_5000 => defmt::write!(f, "BAUD9600"),
                    0x003a_f000 => defmt::write!(f, "BAUD14400"),
                    0x004e_a000 => defmt::write!(f, "BAUD19200"),
                    0x0075_c000 => defmt::write!(f, "BAUD28800"),
                    0x0080_0000 => defmt::write!(f, "BAUD31250"),
                    0x009d_0000 => defmt::write!(f, "BAUD38400"),
                    0x00e5_0000 => defmt::write!(f, "BAUD56000"),
                    0x00eb_0000 => defmt::write!(f, "BAUD57600"),
                    0x013a_9000 => defmt::write!(f, "BAUD76800"),
                    0x01d6_0000 => defmt::write!(f, "BAUD115200"),
                    0x03b0_0000 => defmt::write!(f, "BAUD230400"),
                    0x0400_0000 => defmt::write!(f, "BAUD250000"),
                    0x0740_0000 => defmt::write!(f, "BAUD460800"),
                    0x0f00_0000 => defmt::write!(f, "BAUD921600"),
                    0x1000_0000 => defmt::write!(f, "BAUD1M"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Baudrate {
            #[inline(always)]
            fn from(val: u32) -> Baudrate {
                Baudrate::from_bits(val)
            }
        }
        impl From<Baudrate> for u32 {
            #[inline(always)]
            fn from(val: Baudrate) -> u32 {
                Baudrate::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigParity {
            #[doc = "Exclude parity bit"]
            EXCLUDED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Include even parity bit"]
            INCLUDED = 0x07,
        }
        impl ConfigParity {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigParity {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigParity {
            #[inline(always)]
            fn from(val: u8) -> ConfigParity {
                ConfigParity::from_bits(val)
            }
        }
        impl From<ConfigParity> for u8 {
            #[inline(always)]
            fn from(val: ConfigParity) -> u8 {
                ConfigParity::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum ConfigStop {
            #[doc = "One stop bit"]
            ONE = 0x0,
            #[doc = "Two stop bits"]
            TWO = 0x01,
        }
        impl ConfigStop {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> ConfigStop {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for ConfigStop {
            #[inline(always)]
            fn from(val: u8) -> ConfigStop {
                ConfigStop::from_bits(val)
            }
        }
        impl From<ConfigStop> for u8 {
            #[inline(always)]
            fn from(val: ConfigStop) -> u8 {
                ConfigStop::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Enable {
            #[doc = "Disable UARTE"]
            DISABLED = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            #[doc = "Enable UARTE"]
            ENABLED = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Enable {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Enable {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Enable {
            #[inline(always)]
            fn from(val: u8) -> Enable {
                Enable::from_bits(val)
            }
        }
        impl From<Enable> for u8 {
            #[inline(always)]
            fn from(val: Enable) -> u8 {
                Enable::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Endian {
            #[doc = "Data is trimmed from MSB end."]
            MSB = 0x0,
            #[doc = "Data is trimmed from LSB end."]
            LSB = 0x01,
        }
        impl Endian {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Endian {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Endian {
            #[inline(always)]
            fn from(val: u8) -> Endian {
                Endian::from_bits(val)
            }
        }
        impl From<Endian> for u8 {
            #[inline(always)]
            fn from(val: Endian) -> u8 {
                Endian::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Framesize {
            _RESERVED_0 = 0x0,
            _RESERVED_1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            #[doc = "4 bit data frame size."]
            _4BIT = 0x04,
            #[doc = "5 bit data frame size."]
            _5BIT = 0x05,
            #[doc = "6 bit data frame size."]
            _6BIT = 0x06,
            #[doc = "7 bit data frame size."]
            _7BIT = 0x07,
            #[doc = "8 bit data frame size."]
            _8BIT = 0x08,
            #[doc = "9 bit data frame size. 9th bit is treated as address bit."]
            _9BIT = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            _RESERVED_f = 0x0f,
        }
        impl Framesize {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Framesize {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Framesize {
            #[inline(always)]
            fn from(val: u8) -> Framesize {
                Framesize::from_bits(val)
            }
        }
        impl From<Framesize> for u8 {
            #[inline(always)]
            fn from(val: Framesize) -> u8 {
                Framesize::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot0 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot0 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot0 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot0 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot0 {
                Oneshot0::from_bits(val)
            }
        }
        impl From<Oneshot0> for u8 {
            #[inline(always)]
            fn from(val: Oneshot0) -> u8 {
                Oneshot0::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot1 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot1 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot1 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot1 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot1 {
                Oneshot1::from_bits(val)
            }
        }
        impl From<Oneshot1> for u8 {
            #[inline(always)]
            fn from(val: Oneshot1) -> u8 {
                Oneshot1::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot2 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot2 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot2 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot2 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot2 {
                Oneshot2::from_bits(val)
            }
        }
        impl From<Oneshot2> for u8 {
            #[inline(always)]
            fn from(val: Oneshot2) -> u8 {
                Oneshot2::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Oneshot3 {
            #[doc = "Match filter stays enabled until disabled by task"]
            CONTINUOUS = 0x0,
            #[doc = "Match filter stays enabled until next data word is received"]
            ONESHOT = 0x01,
        }
        impl Oneshot3 {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Oneshot3 {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Oneshot3 {
            #[inline(always)]
            fn from(val: u8) -> Oneshot3 {
                Oneshot3::from_bits(val)
            }
        }
        impl From<Oneshot3> for u8 {
            #[inline(always)]
            fn from(val: Oneshot3) -> u8 {
                Oneshot3::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Paritytype {
            #[doc = "Even parity"]
            EVEN = 0x0,
            #[doc = "Odd parity"]
            ODD = 0x01,
        }
        impl Paritytype {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Paritytype {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Paritytype {
            #[inline(always)]
            fn from(val: u8) -> Paritytype {
                Paritytype::from_bits(val)
            }
        }
        impl From<Paritytype> for u8 {
            #[inline(always)]
            fn from(val: Paritytype) -> u8 {
                Paritytype::to_bits(val)
            }
        }
    }
}
pub mod uicr {
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Approtect {
        ptr: *mut u8,
    }
    unsafe impl Send for Approtect {}
    unsafe impl Sync for Approtect {}
    impl Approtect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::ApprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::ApprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Authopkey {
        ptr: *mut u8,
    }
    unsafe impl Send for Authopkey {}
    unsafe impl Sync for Authopkey {}
    impl Authopkey {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: First 256 bits of SHA2-512 digest over RoT authenticated operation public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn digest(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Revocation status for RoT authenticated operation public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn revoke(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::AuthopkeyRevoke, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Auxapprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Auxapprotect {}
    unsafe impl Sync for Auxapprotect {}
    impl Auxapprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::AuxapprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::AuxapprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Erase Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Eraseprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Eraseprotect {}
    unsafe impl Sync for Eraseprotect {}
    impl Eraseprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Erase protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::EraseprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Erase protection"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::EraseprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Pubkey {
        ptr: *mut u8,
    }
    unsafe impl Send for Pubkey {}
    unsafe impl Sync for Pubkey {}
    impl Pubkey {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: First 256 bits of SHA2-512 digest over RoT public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn digest(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Revocation status for RoT public key generation \\[n\\]."]
        #[inline(always)]
        pub const fn revoke(
            self,
            n: usize,
        ) -> crate::common::Reg<regs::PubkeyRevoke, crate::common::RW> {
            assert!(n < 3usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x20usize + n * 4usize) as _) }
        }
    }
    #[doc = "Assets installed to establish initial Root of Trust in the device."]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Rot {
        ptr: *mut u8,
    }
    unsafe impl Send for Rot {}
    unsafe impl Sync for Rot {}
    impl Rot {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn pubkey(self, n: usize) -> Pubkey {
            assert!(n < 4usize);
            unsafe { Pubkey::from_ptr(self.ptr.add(0x0usize + n * 44usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn authopkey(self, n: usize) -> Authopkey {
            assert!(n < 4usize);
            unsafe { Authopkey::from_ptr(self.ptr.add(0xb0usize + n * 44usize) as _) }
        }
    }
    #[doc = "Access Port Protection Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Secureapprotect {
        ptr: *mut u8,
    }
    unsafe impl Send for Secureapprotect {}
    unsafe impl Sync for Secureapprotect {}
    impl Secureapprotect {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description cluster: Access port protection"]
        #[inline(always)]
        pub const fn protect0(
            self,
        ) -> crate::common::Reg<regs::SecureapprotectProtect0, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[inline(always)]
        pub const fn protect1(
            self,
        ) -> crate::common::Reg<regs::SecureapprotectProtect1, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x1cusize) as _) }
        }
    }
    #[doc = "User Information Configuration Registers"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Uicr {
        ptr: *mut u8,
    }
    unsafe impl Send for Uicr {}
    unsafe impl Sync for Uicr {}
    impl Uicr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn approtect(self, n: usize) -> Approtect {
            assert!(n < 1usize);
            unsafe { Approtect::from_ptr(self.ptr.add(0x0usize + n * 32usize) as _) }
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn secureapprotect(self, n: usize) -> Secureapprotect {
            assert!(n < 1usize);
            unsafe { Secureapprotect::from_ptr(self.ptr.add(0x20usize + n * 32usize) as _) }
        }
        #[doc = "Access Port Protection Registers"]
        #[inline(always)]
        pub const fn auxapprotect(self, n: usize) -> Auxapprotect {
            assert!(n < 1usize);
            unsafe { Auxapprotect::from_ptr(self.ptr.add(0x40usize + n * 32usize) as _) }
        }
        #[doc = "Erase Protection Registers"]
        #[inline(always)]
        pub const fn eraseprotect(self, n: usize) -> Eraseprotect {
            assert!(n < 1usize);
            unsafe { Eraseprotect::from_ptr(self.ptr.add(0x60usize + n * 32usize) as _) }
        }
        #[doc = "Immutable boot region configuration."]
        #[inline(always)]
        pub const fn bootconf(self) -> crate::common::Reg<regs::Bootconf, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn user(self) -> User {
            unsafe { User::from_ptr(self.ptr.add(0x0200usize) as _) }
        }
        #[doc = "Description collection: One time programmable memory"]
        #[inline(always)]
        pub const fn otp(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 320usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0500usize + n * 4usize) as _) }
        }
    }
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct User {
        ptr: *mut u8,
    }
    unsafe impl Send for User {}
    unsafe impl Sync for User {}
    impl User {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Assets installed to establish initial Root of Trust in the device."]
        #[inline(always)]
        pub const fn rot(self) -> Rot {
            unsafe { Rot::from_ptr(self.ptr.add(0x0usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApprotectProtect0(pub u32);
        impl ApprotectProtect0 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::ApprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ApprotectProtect0 {
            #[inline(always)]
            fn default() -> ApprotectProtect0 {
                ApprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for ApprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ApprotectProtect0 {
                    pall: super::vals::ApprotectProtect0Pall,
                }
                let proxy = ApprotectProtect0 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct ApprotectProtect1(pub u32);
        impl ApprotectProtect1 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::ApprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::ApprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::ApprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for ApprotectProtect1 {
            #[inline(always)]
            fn default() -> ApprotectProtect1 {
                ApprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for ApprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("ApprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct ApprotectProtect1 {
                    pall: super::vals::ApprotectProtect1Pall,
                }
                let proxy = ApprotectProtect1 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Revocation status for RoT authenticated operation public key generation \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuthopkeyRevoke(pub u32);
        impl AuthopkeyRevoke {
            #[doc = "Revocation status."]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::AuthopkeyRevokeStatus {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuthopkeyRevokeStatus::from_bits(val as u32)
            }
            #[doc = "Revocation status."]
            #[inline(always)]
            pub fn set_status(&mut self, val: super::vals::AuthopkeyRevokeStatus) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuthopkeyRevoke {
            #[inline(always)]
            fn default() -> AuthopkeyRevoke {
                AuthopkeyRevoke(0)
            }
        }
        impl core::fmt::Debug for AuthopkeyRevoke {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuthopkeyRevoke")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuthopkeyRevoke {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct AuthopkeyRevoke {
                    status: super::vals::AuthopkeyRevokeStatus,
                }
                let proxy = AuthopkeyRevoke {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxapprotectProtect0(pub u32);
        impl AuxapprotectProtect0 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::AuxapprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuxapprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::AuxapprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuxapprotectProtect0 {
            #[inline(always)]
            fn default() -> AuxapprotectProtect0 {
                AuxapprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxapprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct AuxapprotectProtect0 {
                    pall: super::vals::AuxapprotectProtect0Pall,
                }
                let proxy = AuxapprotectProtect0 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct AuxapprotectProtect1(pub u32);
        impl AuxapprotectProtect1 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::AuxapprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::AuxapprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::AuxapprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for AuxapprotectProtect1 {
            #[inline(always)]
            fn default() -> AuxapprotectProtect1 {
                AuxapprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("AuxapprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct AuxapprotectProtect1 {
                    pall: super::vals::AuxapprotectProtect1Pall,
                }
                let proxy = AuxapprotectProtect1 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Immutable boot region configuration."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Bootconf(pub u32);
        impl Bootconf {
            #[doc = "Read access"]
            #[inline(always)]
            pub const fn read(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Read access"]
            #[inline(always)]
            pub fn set_read(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub const fn write(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write access"]
            #[inline(always)]
            pub fn set_write(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub const fn execute(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[doc = "Execute access"]
            #[inline(always)]
            pub fn set_execute(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub const fn secure(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[doc = "Secure access"]
            #[inline(always)]
            pub fn set_secure(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub const fn writeonce(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Write-once"]
            #[inline(always)]
            pub fn set_writeonce(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Enable lock of configuration register"]
            #[inline(always)]
            pub const fn lock(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "Enable lock of configuration register"]
            #[inline(always)]
            pub fn set_lock(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Immutable boot region size"]
            #[inline(always)]
            pub const fn size(&self) -> u8 {
                let val = (self.0 >> 16usize) & 0x1f;
                val as u8
            }
            #[doc = "Immutable boot region size"]
            #[inline(always)]
            pub fn set_size(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 16usize)) | (((val as u32) & 0x1f) << 16usize);
            }
        }
        impl Default for Bootconf {
            #[inline(always)]
            fn default() -> Bootconf {
                Bootconf(0)
            }
        }
        impl core::fmt::Debug for Bootconf {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Bootconf")
                    .field("read", &self.read())
                    .field("write", &self.write())
                    .field("execute", &self.execute())
                    .field("secure", &self.secure())
                    .field("writeonce", &self.writeonce())
                    .field("lock", &self.lock())
                    .field("size", &self.size())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Bootconf {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Bootconf {
                    read: bool,
                    write: bool,
                    execute: bool,
                    secure: bool,
                    writeonce: bool,
                    lock: bool,
                    size: u8,
                }
                let proxy = Bootconf {
                    read: self.read(),
                    write: self.write(),
                    execute: self.execute(),
                    secure: self.secure(),
                    writeonce: self.writeonce(),
                    lock: self.lock(),
                    size: self.size(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectProtect0(pub u32);
        impl EraseprotectProtect0 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::EraseprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EraseprotectProtect0 {
            #[inline(always)]
            fn default() -> EraseprotectProtect0 {
                EraseprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for EraseprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct EraseprotectProtect0 {
                    pall: super::vals::EraseprotectProtect0Pall,
                }
                let proxy = EraseprotectProtect0 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Erase protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct EraseprotectProtect1(pub u32);
        impl EraseprotectProtect1 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::EraseprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::EraseprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::EraseprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for EraseprotectProtect1 {
            #[inline(always)]
            fn default() -> EraseprotectProtect1 {
                EraseprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for EraseprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("EraseprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct EraseprotectProtect1 {
                    pall: super::vals::EraseprotectProtect1Pall,
                }
                let proxy = EraseprotectProtect1 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Revocation status for RoT public key generation \\[n\\]."]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct PubkeyRevoke(pub u32);
        impl PubkeyRevoke {
            #[doc = "Revocation status."]
            #[inline(always)]
            pub const fn status(&self) -> super::vals::PubkeyRevokeStatus {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::PubkeyRevokeStatus::from_bits(val as u32)
            }
            #[doc = "Revocation status."]
            #[inline(always)]
            pub fn set_status(&mut self, val: super::vals::PubkeyRevokeStatus) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for PubkeyRevoke {
            #[inline(always)]
            fn default() -> PubkeyRevoke {
                PubkeyRevoke(0)
            }
        }
        impl core::fmt::Debug for PubkeyRevoke {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("PubkeyRevoke")
                    .field("status", &self.status())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PubkeyRevoke {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct PubkeyRevoke {
                    status: super::vals::PubkeyRevokeStatus,
                }
                let proxy = PubkeyRevoke {
                    status: self.status(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Access port protection"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SecureapprotectProtect0(pub u32);
        impl SecureapprotectProtect0 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectProtect0Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectProtect0Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::SecureapprotectProtect0Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SecureapprotectProtect0 {
            #[inline(always)]
            fn default() -> SecureapprotectProtect0 {
                SecureapprotectProtect0(0)
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect0 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SecureapprotectProtect0")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect0 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SecureapprotectProtect0 {
                    pall: super::vals::SecureapprotectProtect0Pall,
                }
                let proxy = SecureapprotectProtect0 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description cluster: Access port protection register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct SecureapprotectProtect1(pub u32);
        impl SecureapprotectProtect1 {
            #[inline(always)]
            pub const fn pall(&self) -> super::vals::SecureapprotectProtect1Pall {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::SecureapprotectProtect1Pall::from_bits(val as u32)
            }
            #[inline(always)]
            pub fn set_pall(&mut self, val: super::vals::SecureapprotectProtect1Pall) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for SecureapprotectProtect1 {
            #[inline(always)]
            fn default() -> SecureapprotectProtect1 {
                SecureapprotectProtect1(0)
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect1 {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("SecureapprotectProtect1")
                    .field("pall", &self.pall())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect1 {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct SecureapprotectProtect1 {
                    pall: super::vals::SecureapprotectProtect1Pall,
                }
                let proxy = SecureapprotectProtect1 { pall: self.pall() };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectProtect0Pall(pub u32);
        impl ApprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN DBGEN and NIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> ApprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectProtect0Pall {
                ApprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<ApprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectProtect0Pall) -> u32 {
                ApprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct ApprotectProtect1Pall(pub u32);
        impl ApprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN DBGEN and NIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl ApprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> ApprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for ApprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for ApprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for ApprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> ApprotectProtect1Pall {
                ApprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<ApprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: ApprotectProtect1Pall) -> u32 {
                ApprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuthopkeyRevokeStatus(pub u32);
        impl AuthopkeyRevokeStatus {
            #[doc = "Key not revoked."]
            pub const NOT_REVOKED: Self = Self(0xffff_ffff);
        }
        impl AuthopkeyRevokeStatus {
            pub const fn from_bits(val: u32) -> AuthopkeyRevokeStatus {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuthopkeyRevokeStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("NOT_REVOKED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuthopkeyRevokeStatus {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "NOT_REVOKED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuthopkeyRevokeStatus {
            #[inline(always)]
            fn from(val: u32) -> AuthopkeyRevokeStatus {
                AuthopkeyRevokeStatus::from_bits(val)
            }
        }
        impl From<AuthopkeyRevokeStatus> for u32 {
            #[inline(always)]
            fn from(val: AuthopkeyRevokeStatus) -> u32 {
                AuthopkeyRevokeStatus::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuxapprotectProtect0Pall(pub u32);
        impl AuxapprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.AP DBGEN and SPIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl AuxapprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> AuxapprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuxapprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> AuxapprotectProtect0Pall {
                AuxapprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<AuxapprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: AuxapprotectProtect0Pall) -> u32 {
                AuxapprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct AuxapprotectProtect1Pall(pub u32);
        impl AuxapprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.AP DBGEN and SPIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl AuxapprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> AuxapprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for AuxapprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for AuxapprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for AuxapprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> AuxapprotectProtect1Pall {
                AuxapprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<AuxapprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: AuxapprotectProtect1Pall) -> u32 {
                AuxapprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectProtect0Pall(pub u32);
        impl EraseprotectProtect0Pall {
            #[doc = "The device can be erased using the CTRL-AP Erase all function and TAMPC PROTECT.ERASEPROTECT signal protector is unlocked."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl EraseprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> EraseprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectProtect0Pall {
                EraseprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<EraseprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectProtect0Pall) -> u32 {
                EraseprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct EraseprotectProtect1Pall(pub u32);
        impl EraseprotectProtect1Pall {
            #[doc = "The device canbe erased using the CTRL-AP Erase all function and TAMPC PROTECT.ERASEPROTECT signal protector is unlocked."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl EraseprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> EraseprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for EraseprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for EraseprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for EraseprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> EraseprotectProtect1Pall {
                EraseprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<EraseprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: EraseprotectProtect1Pall) -> u32 {
                EraseprotectProtect1Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct PubkeyRevokeStatus(pub u32);
        impl PubkeyRevokeStatus {
            #[doc = "Key not revoked."]
            pub const NOT_REVOKED: Self = Self(0xffff_ffff);
        }
        impl PubkeyRevokeStatus {
            pub const fn from_bits(val: u32) -> PubkeyRevokeStatus {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for PubkeyRevokeStatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("NOT_REVOKED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for PubkeyRevokeStatus {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "NOT_REVOKED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for PubkeyRevokeStatus {
            #[inline(always)]
            fn from(val: u32) -> PubkeyRevokeStatus {
                PubkeyRevokeStatus::from_bits(val)
            }
        }
        impl From<PubkeyRevokeStatus> for u32 {
            #[inline(always)]
            fn from(val: PubkeyRevokeStatus) -> u32 {
                PubkeyRevokeStatus::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectProtect0Pall(pub u32);
        impl SecureapprotectProtect0Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN SPIDEN and SPNIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectProtect0Pall {
            pub const fn from_bits(val: u32) -> SecureapprotectProtect0Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect0Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect0Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectProtect0Pall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectProtect0Pall {
                SecureapprotectProtect0Pall::from_bits(val)
            }
        }
        impl From<SecureapprotectProtect0Pall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectProtect0Pall) -> u32 {
                SecureapprotectProtect0Pall::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct SecureapprotectProtect1Pall(pub u32);
        impl SecureapprotectProtect1Pall {
            #[doc = "Leaves TAMPC PROTECT.DOMAIN SPIDEN and SPNIDEN signal protectors unlocked and under CPU control."]
            pub const UNPROTECTED: Self = Self(0xffff_ffff);
        }
        impl SecureapprotectProtect1Pall {
            pub const fn from_bits(val: u32) -> SecureapprotectProtect1Pall {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for SecureapprotectProtect1Pall {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0xffff_ffff => f.write_str("UNPROTECTED"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for SecureapprotectProtect1Pall {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0xffff_ffff => defmt::write!(f, "UNPROTECTED"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for SecureapprotectProtect1Pall {
            #[inline(always)]
            fn from(val: u32) -> SecureapprotectProtect1Pall {
                SecureapprotectProtect1Pall::from_bits(val)
            }
        }
        impl From<SecureapprotectProtect1Pall> for u32 {
            #[inline(always)]
            fn from(val: SecureapprotectProtect1Pall) -> u32 {
                SecureapprotectProtect1Pall::to_bits(val)
            }
        }
    }
}
pub mod vpr {
    #[doc = "Unspecified"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Debugif {
        ptr: *mut u8,
    }
    unsafe impl Send for Debugif {}
    unsafe impl Sync for Debugif {}
    impl Debugif {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Abstract Data 0. Read/write data for argument 0"]
        #[inline(always)]
        pub const fn data0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x10usize) as _) }
        }
        #[doc = "Abstract Data 1. Read/write data for argument 1"]
        #[inline(always)]
        pub const fn data1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x14usize) as _) }
        }
        #[doc = "Debug Module Control"]
        #[inline(always)]
        pub const fn dmcontrol(self) -> crate::common::Reg<regs::Dmcontrol, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x40usize) as _) }
        }
        #[doc = "Debug Module Status"]
        #[inline(always)]
        pub const fn dmstatus(self) -> crate::common::Reg<regs::Dmstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x44usize) as _) }
        }
        #[doc = "Hart Information"]
        #[inline(always)]
        pub const fn hartinfo(self) -> crate::common::Reg<regs::Hartinfo, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x48usize) as _) }
        }
        #[doc = "Halt Summary 1"]
        #[inline(always)]
        pub const fn haltsum1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x4cusize) as _) }
        }
        #[doc = "Hart Array Window Select"]
        #[inline(always)]
        pub const fn hawindowsel(self) -> crate::common::Reg<regs::Hawindowsel, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x50usize) as _) }
        }
        #[doc = "Hart Array Window"]
        #[inline(always)]
        pub const fn hawindow(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x54usize) as _) }
        }
        #[doc = "Abstract Control and Status"]
        #[inline(always)]
        pub const fn abstractcs(self) -> crate::common::Reg<regs::Abstractcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x58usize) as _) }
        }
        #[doc = "Abstract command"]
        #[inline(always)]
        pub const fn abstractcmd(self) -> crate::common::Reg<regs::Abstractcmd, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x5cusize) as _) }
        }
        #[doc = "Abstract Command Autoexec"]
        #[inline(always)]
        pub const fn abstractauto(
            self,
        ) -> crate::common::Reg<regs::Abstractauto, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x60usize) as _) }
        }
        #[doc = "Description collection: Configuration String Pointer \\[n\\]"]
        #[inline(always)]
        pub const fn confstrptr(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x64usize + n * 4usize) as _) }
        }
        #[doc = "Next Debug Module"]
        #[inline(always)]
        pub const fn nextdm(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x74usize) as _) }
        }
        #[doc = "Description collection: Program Buffer \\[n\\]"]
        #[inline(always)]
        pub const fn progbuf(self, n: usize) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 16usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Authentication Data"]
        #[inline(always)]
        pub const fn authdata(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xc0usize) as _) }
        }
        #[doc = "Halt Summary 2"]
        #[inline(always)]
        pub const fn haltsum2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd0usize) as _) }
        }
        #[doc = "Halt Summary 3"]
        #[inline(always)]
        pub const fn haltsum3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xd4usize) as _) }
        }
        #[doc = "System Bus Addres 127:96"]
        #[inline(always)]
        pub const fn sbaddress3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xdcusize) as _) }
        }
        #[doc = "System Bus Access Control and Status"]
        #[inline(always)]
        pub const fn sbcs(self) -> crate::common::Reg<regs::Sbcs, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe0usize) as _) }
        }
        #[doc = "System Bus Addres 31:0"]
        #[inline(always)]
        pub const fn sbaddress0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe4usize) as _) }
        }
        #[doc = "System Bus Addres 63:32"]
        #[inline(always)]
        pub const fn sbaddress1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xe8usize) as _) }
        }
        #[doc = "System Bus Addres 95:64"]
        #[inline(always)]
        pub const fn sbaddress2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xecusize) as _) }
        }
        #[doc = "System Bus Data 31:0"]
        #[inline(always)]
        pub const fn sbdata0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf0usize) as _) }
        }
        #[doc = "System Bus Data 63:32"]
        #[inline(always)]
        pub const fn sbdata1(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf4usize) as _) }
        }
        #[doc = "System Bus Data 95:64"]
        #[inline(always)]
        pub const fn sbdata2(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xf8usize) as _) }
        }
        #[doc = "System Bus Data 127:96"]
        #[inline(always)]
        pub const fn sbdata3(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0xfcusize) as _) }
        }
        #[doc = "Halt summary 0"]
        #[inline(always)]
        pub const fn haltsum0(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
    }
    #[doc = "VPR peripheral registers 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Vpr {
        ptr: *mut u8,
    }
    unsafe impl Send for Vpr {}
    unsafe impl Sync for Vpr {}
    impl Vpr {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Description collection: VPR task \\[n\\] register"]
        #[inline(always)]
        pub const fn tasks_trigger(self, n: usize) -> crate::common::Reg<u32, crate::common::W> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Subscribe configuration for task TASKS_TRIGGER\\[n\\]"]
        #[inline(always)]
        pub const fn subscribe_trigger(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: VPR event \\[n\\] register"]
        #[inline(always)]
        pub const fn events_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<u32, crate::common::RW> {
            assert!(n < 7usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize + n * 4usize) as _) }
        }
        #[doc = "Description collection: Publish configuration for event EVENTS_TRIGGERED\\[n\\]"]
        #[inline(always)]
        pub const fn publish_triggered(
            self,
            n: usize,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            assert!(n < 4usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize + n * 4usize) as _) }
        }
        #[doc = "Enable or disable interrupt"]
        #[inline(always)]
        pub const fn inten(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0300usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Pending interrupts"]
        #[inline(always)]
        pub const fn intpend(self) -> crate::common::Reg<regs::Int, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x030cusize) as _) }
        }
        #[doc = "Unspecified"]
        #[inline(always)]
        pub const fn debugif(self) -> Debugif {
            unsafe { Debugif::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "State of the CPU after a core reset"]
        #[inline(always)]
        pub const fn cpurun(self) -> crate::common::Reg<regs::Cpurun, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0800usize) as _) }
        }
        #[doc = "Initial value of the PC at CPU start."]
        #[inline(always)]
        pub const fn initpc(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0808usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Abstract Command Autoexec"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractauto(pub u32);
        impl Abstractauto {
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding data word cause the command in command to be executed again."]
            #[inline(always)]
            pub const fn autoexecdata(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding data word cause the command in command to be executed again."]
            #[inline(always)]
            pub fn set_autoexecdata(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding progbuf word cause the command in command to be executed again."]
            #[inline(always)]
            pub const fn autoexecprogbuf(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0xffff;
                val as u16
            }
            #[doc = "When a bit in this field is 1, read or write accesses to the corresponding progbuf word cause the command in command to be executed again."]
            #[inline(always)]
            pub fn set_autoexecprogbuf(&mut self, val: u16) {
                self.0 = (self.0 & !(0xffff << 16usize)) | (((val as u32) & 0xffff) << 16usize);
            }
        }
        impl Default for Abstractauto {
            #[inline(always)]
            fn default() -> Abstractauto {
                Abstractauto(0)
            }
        }
        impl core::fmt::Debug for Abstractauto {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractauto")
                    .field("autoexecdata", &self.autoexecdata())
                    .field("autoexecprogbuf", &self.autoexecprogbuf())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractauto {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Abstractauto {
                    autoexecdata: u16,
                    autoexecprogbuf: u16,
                }
                let proxy = Abstractauto {
                    autoexecdata: self.autoexecdata(),
                    autoexecprogbuf: self.autoexecprogbuf(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Abstract command"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractcmd(pub u32);
        impl Abstractcmd {
            #[doc = "This Field is interpreted in a command specific manner, described for each abstract command."]
            #[inline(always)]
            pub const fn control(&self) -> u32 {
                let val = (self.0 >> 0usize) & 0x00ff_ffff;
                val as u32
            }
            #[doc = "This Field is interpreted in a command specific manner, described for each abstract command."]
            #[inline(always)]
            pub fn set_control(&mut self, val: u32) {
                self.0 =
                    (self.0 & !(0x00ff_ffff << 0usize)) | (((val as u32) & 0x00ff_ffff) << 0usize);
            }
            #[doc = "The type determines the overall functionality of this abstract command."]
            #[inline(always)]
            pub const fn cmdtype(&self) -> super::vals::Cmdtype {
                let val = (self.0 >> 24usize) & 0xff;
                super::vals::Cmdtype::from_bits(val as u8)
            }
            #[doc = "The type determines the overall functionality of this abstract command."]
            #[inline(always)]
            pub fn set_cmdtype(&mut self, val: super::vals::Cmdtype) {
                self.0 =
                    (self.0 & !(0xff << 24usize)) | (((val.to_bits() as u32) & 0xff) << 24usize);
            }
        }
        impl Default for Abstractcmd {
            #[inline(always)]
            fn default() -> Abstractcmd {
                Abstractcmd(0)
            }
        }
        impl core::fmt::Debug for Abstractcmd {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractcmd")
                    .field("control", &self.control())
                    .field("cmdtype", &self.cmdtype())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractcmd {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Abstractcmd {
                    control: u32,
                    cmdtype: super::vals::Cmdtype,
                }
                let proxy = Abstractcmd {
                    control: self.control(),
                    cmdtype: self.cmdtype(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Abstract Control and Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Abstractcs(pub u32);
        impl Abstractcs {
            #[doc = "Number of data registers that are implemented as part of the abstract command interface. Valid sizes are 1..12."]
            #[inline(always)]
            pub const fn datacount(&self) -> u8 {
                let val = (self.0 >> 0usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of data registers that are implemented as part of the abstract command interface. Valid sizes are 1..12."]
            #[inline(always)]
            pub fn set_datacount(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val as u32) & 0x0f) << 0usize);
            }
            #[doc = "Command error when the abstract command fails."]
            #[inline(always)]
            pub const fn cmderr(&self) -> super::vals::Cmderr {
                let val = (self.0 >> 8usize) & 0x07;
                super::vals::Cmderr::from_bits(val as u8)
            }
            #[doc = "Command error when the abstract command fails."]
            #[inline(always)]
            pub fn set_cmderr(&mut self, val: super::vals::Cmderr) {
                self.0 = (self.0 & !(0x07 << 8usize)) | (((val.to_bits() as u32) & 0x07) << 8usize);
            }
            #[doc = "Abstract command execution status."]
            #[inline(always)]
            pub const fn busy(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Abstract command execution status."]
            #[inline(always)]
            pub fn set_busy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 1."]
            #[inline(always)]
            pub const fn progbufsize(&self) -> u8 {
                let val = (self.0 >> 24usize) & 0x1f;
                val as u8
            }
            #[doc = "Size of the Program Buffer, in 32-bit words. Valid sizes are 0 - 1."]
            #[inline(always)]
            pub fn set_progbufsize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x1f << 24usize)) | (((val as u32) & 0x1f) << 24usize);
            }
        }
        impl Default for Abstractcs {
            #[inline(always)]
            fn default() -> Abstractcs {
                Abstractcs(0)
            }
        }
        impl core::fmt::Debug for Abstractcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Abstractcs")
                    .field("datacount", &self.datacount())
                    .field("cmderr", &self.cmderr())
                    .field("busy", &self.busy())
                    .field("progbufsize", &self.progbufsize())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Abstractcs {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Abstractcs {
                    datacount: u8,
                    cmderr: super::vals::Cmderr,
                    busy: bool,
                    progbufsize: u8,
                }
                let proxy = Abstractcs {
                    datacount: self.datacount(),
                    cmderr: self.cmderr(),
                    busy: self.busy(),
                    progbufsize: self.progbufsize(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "State of the CPU after a core reset"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Cpurun(pub u32);
        impl Cpurun {
            #[doc = "Controls CPU running state after a core reset."]
            #[inline(always)]
            pub const fn en(&self) -> super::vals::CpurunEn {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::CpurunEn::from_bits(val as u8)
            }
            #[doc = "Controls CPU running state after a core reset."]
            #[inline(always)]
            pub fn set_en(&mut self, val: super::vals::CpurunEn) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Cpurun {
            #[inline(always)]
            fn default() -> Cpurun {
                Cpurun(0)
            }
        }
        impl core::fmt::Debug for Cpurun {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Cpurun").field("en", &self.en()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cpurun {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Cpurun {
                    en: super::vals::CpurunEn,
                }
                let proxy = Cpurun { en: self.en() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Debug Module Control"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dmcontrol(pub u32);
        impl Dmcontrol {
            #[doc = "Reset signal for the debug module."]
            #[inline(always)]
            pub const fn dmactive(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Reset signal for the debug module."]
            #[inline(always)]
            pub fn set_dmactive(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Reset signal output from the debug module to the system."]
            #[inline(always)]
            pub const fn ndmreset(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Reset signal output from the debug module to the system."]
            #[inline(always)]
            pub fn set_ndmreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[doc = "Clear the halt on reset request."]
            #[inline(always)]
            pub const fn clrresethaltreq(&self) -> super::vals::Clrresethaltreq {
                let val = (self.0 >> 2usize) & 0x01;
                super::vals::Clrresethaltreq::from_bits(val as u8)
            }
            #[doc = "Clear the halt on reset request."]
            #[inline(always)]
            pub fn set_clrresethaltreq(&mut self, val: super::vals::Clrresethaltreq) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val.to_bits() as u32) & 0x01) << 2usize);
            }
            #[doc = "Set the halt on reset request."]
            #[inline(always)]
            pub const fn setresethaltreq(&self) -> super::vals::Setresethaltreq {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Setresethaltreq::from_bits(val as u8)
            }
            #[doc = "Set the halt on reset request."]
            #[inline(always)]
            pub fn set_setresethaltreq(&mut self, val: super::vals::Setresethaltreq) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "The high 10 bits of hartsel."]
            #[inline(always)]
            pub const fn hartselhi(&self) -> u16 {
                let val = (self.0 >> 6usize) & 0x03ff;
                val as u16
            }
            #[doc = "The high 10 bits of hartsel."]
            #[inline(always)]
            pub fn set_hartselhi(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 6usize)) | (((val as u32) & 0x03ff) << 6usize);
            }
            #[doc = "The low 10 bits of hartsel."]
            #[inline(always)]
            pub const fn hartsello(&self) -> u16 {
                let val = (self.0 >> 16usize) & 0x03ff;
                val as u16
            }
            #[doc = "The low 10 bits of hartsel."]
            #[inline(always)]
            pub fn set_hartsello(&mut self, val: u16) {
                self.0 = (self.0 & !(0x03ff << 16usize)) | (((val as u32) & 0x03ff) << 16usize);
            }
            #[doc = "Definition of currently selected harts."]
            #[inline(always)]
            pub const fn hasel(&self) -> super::vals::Hasel {
                let val = (self.0 >> 26usize) & 0x01;
                super::vals::Hasel::from_bits(val as u8)
            }
            #[doc = "Definition of currently selected harts."]
            #[inline(always)]
            pub fn set_hasel(&mut self, val: super::vals::Hasel) {
                self.0 =
                    (self.0 & !(0x01 << 26usize)) | (((val.to_bits() as u32) & 0x01) << 26usize);
            }
            #[doc = "Clear the havereset."]
            #[inline(always)]
            pub const fn ackhavereset(&self) -> super::vals::Ackhavereset {
                let val = (self.0 >> 28usize) & 0x01;
                super::vals::Ackhavereset::from_bits(val as u8)
            }
            #[doc = "Clear the havereset."]
            #[inline(always)]
            pub fn set_ackhavereset(&mut self, val: super::vals::Ackhavereset) {
                self.0 =
                    (self.0 & !(0x01 << 28usize)) | (((val.to_bits() as u32) & 0x01) << 28usize);
            }
            #[doc = "Reset harts."]
            #[inline(always)]
            pub const fn hartreset(&self) -> bool {
                let val = (self.0 >> 29usize) & 0x01;
                val != 0
            }
            #[doc = "Reset harts."]
            #[inline(always)]
            pub fn set_hartreset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 29usize)) | (((val as u32) & 0x01) << 29usize);
            }
            #[doc = "Resume currently selected harts."]
            #[inline(always)]
            pub const fn resumereq(&self) -> super::vals::Resumereq {
                let val = (self.0 >> 30usize) & 0x01;
                super::vals::Resumereq::from_bits(val as u8)
            }
            #[doc = "Resume currently selected harts."]
            #[inline(always)]
            pub fn set_resumereq(&mut self, val: super::vals::Resumereq) {
                self.0 =
                    (self.0 & !(0x01 << 30usize)) | (((val.to_bits() as u32) & 0x01) << 30usize);
            }
            #[doc = "Halt currently selected harts."]
            #[inline(always)]
            pub const fn haltreq(&self) -> super::vals::Haltreq {
                let val = (self.0 >> 31usize) & 0x01;
                super::vals::Haltreq::from_bits(val as u8)
            }
            #[doc = "Halt currently selected harts."]
            #[inline(always)]
            pub fn set_haltreq(&mut self, val: super::vals::Haltreq) {
                self.0 =
                    (self.0 & !(0x01 << 31usize)) | (((val.to_bits() as u32) & 0x01) << 31usize);
            }
        }
        impl Default for Dmcontrol {
            #[inline(always)]
            fn default() -> Dmcontrol {
                Dmcontrol(0)
            }
        }
        impl core::fmt::Debug for Dmcontrol {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dmcontrol")
                    .field("dmactive", &self.dmactive())
                    .field("ndmreset", &self.ndmreset())
                    .field("clrresethaltreq", &self.clrresethaltreq())
                    .field("setresethaltreq", &self.setresethaltreq())
                    .field("hartselhi", &self.hartselhi())
                    .field("hartsello", &self.hartsello())
                    .field("hasel", &self.hasel())
                    .field("ackhavereset", &self.ackhavereset())
                    .field("hartreset", &self.hartreset())
                    .field("resumereq", &self.resumereq())
                    .field("haltreq", &self.haltreq())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dmcontrol {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dmcontrol {
                    dmactive: bool,
                    ndmreset: bool,
                    clrresethaltreq: super::vals::Clrresethaltreq,
                    setresethaltreq: super::vals::Setresethaltreq,
                    hartselhi: u16,
                    hartsello: u16,
                    hasel: super::vals::Hasel,
                    ackhavereset: super::vals::Ackhavereset,
                    hartreset: bool,
                    resumereq: super::vals::Resumereq,
                    haltreq: super::vals::Haltreq,
                }
                let proxy = Dmcontrol {
                    dmactive: self.dmactive(),
                    ndmreset: self.ndmreset(),
                    clrresethaltreq: self.clrresethaltreq(),
                    setresethaltreq: self.setresethaltreq(),
                    hartselhi: self.hartselhi(),
                    hartsello: self.hartsello(),
                    hasel: self.hasel(),
                    ackhavereset: self.ackhavereset(),
                    hartreset: self.hartreset(),
                    resumereq: self.resumereq(),
                    haltreq: self.haltreq(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Debug Module Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Dmstatus(pub u32);
        impl Dmstatus {
            #[doc = "Version of the debug module."]
            #[inline(always)]
            pub const fn version(&self) -> super::vals::Version {
                let val = (self.0 >> 0usize) & 0x0f;
                super::vals::Version::from_bits(val as u8)
            }
            #[doc = "Version of the debug module."]
            #[inline(always)]
            pub fn set_version(&mut self, val: super::vals::Version) {
                self.0 = (self.0 & !(0x0f << 0usize)) | (((val.to_bits() as u32) & 0x0f) << 0usize);
            }
            #[doc = "Configuration string."]
            #[inline(always)]
            pub const fn confstrptrvalid(&self) -> super::vals::Confstrptrvalid {
                let val = (self.0 >> 4usize) & 0x01;
                super::vals::Confstrptrvalid::from_bits(val as u8)
            }
            #[doc = "Configuration string."]
            #[inline(always)]
            pub fn set_confstrptrvalid(&mut self, val: super::vals::Confstrptrvalid) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val.to_bits() as u32) & 0x01) << 4usize);
            }
            #[doc = "Halt-on-reset support status."]
            #[inline(always)]
            pub const fn hasresethaltreq(&self) -> bool {
                let val = (self.0 >> 5usize) & 0x01;
                val != 0
            }
            #[doc = "Halt-on-reset support status."]
            #[inline(always)]
            pub fn set_hasresethaltreq(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 5usize)) | (((val as u32) & 0x01) << 5usize);
            }
            #[doc = "Authentication busy status."]
            #[inline(always)]
            pub const fn authbusy(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Authentication busy status."]
            #[inline(always)]
            pub fn set_authbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
            #[doc = "Authentication status."]
            #[inline(always)]
            pub const fn authenticated(&self) -> bool {
                let val = (self.0 >> 7usize) & 0x01;
                val != 0
            }
            #[doc = "Authentication status."]
            #[inline(always)]
            pub fn set_authenticated(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 7usize)) | (((val as u32) & 0x01) << 7usize);
            }
            #[doc = "Any currently selected harts halted status."]
            #[inline(always)]
            pub const fn anyhalted(&self) -> bool {
                let val = (self.0 >> 8usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts halted status."]
            #[inline(always)]
            pub fn set_anyhalted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 8usize)) | (((val as u32) & 0x01) << 8usize);
            }
            #[doc = "All currently selected harts halted status."]
            #[inline(always)]
            pub const fn allhalted(&self) -> bool {
                let val = (self.0 >> 9usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts halted status."]
            #[inline(always)]
            pub fn set_allhalted(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 9usize)) | (((val as u32) & 0x01) << 9usize);
            }
            #[doc = "Any currently selected harts running status."]
            #[inline(always)]
            pub const fn anyrunning(&self) -> bool {
                let val = (self.0 >> 10usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts running status."]
            #[inline(always)]
            pub fn set_anyrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 10usize)) | (((val as u32) & 0x01) << 10usize);
            }
            #[doc = "All currently selected harts running status."]
            #[inline(always)]
            pub const fn allrunning(&self) -> bool {
                let val = (self.0 >> 11usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts running status."]
            #[inline(always)]
            pub fn set_allrunning(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 11usize)) | (((val as u32) & 0x01) << 11usize);
            }
            #[doc = "Any currently selected harts unavailable status."]
            #[inline(always)]
            pub const fn anyunavail(&self) -> bool {
                let val = (self.0 >> 12usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts unavailable status."]
            #[inline(always)]
            pub fn set_anyunavail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 12usize)) | (((val as u32) & 0x01) << 12usize);
            }
            #[doc = "All currently selected harts unavailable status."]
            #[inline(always)]
            pub const fn allunavail(&self) -> bool {
                let val = (self.0 >> 13usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts unavailable status."]
            #[inline(always)]
            pub fn set_allunavail(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 13usize)) | (((val as u32) & 0x01) << 13usize);
            }
            #[doc = "Any currently selected harts nonexistent status."]
            #[inline(always)]
            pub const fn anynonexistent(&self) -> bool {
                let val = (self.0 >> 14usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts nonexistent status."]
            #[inline(always)]
            pub fn set_anynonexistent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 14usize)) | (((val as u32) & 0x01) << 14usize);
            }
            #[doc = "All currently selected harts nonexistent status."]
            #[inline(always)]
            pub const fn allnonexistent(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts nonexistent status."]
            #[inline(always)]
            pub fn set_allnonexistent(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[doc = "Any currently selected harts acknowledged last resume request."]
            #[inline(always)]
            pub const fn anyresumeack(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts acknowledged last resume request."]
            #[inline(always)]
            pub fn set_anyresumeack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "All currently selected harts acknowledged last resume"]
            #[inline(always)]
            pub const fn allresumeack(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts acknowledged last resume"]
            #[inline(always)]
            pub fn set_allresumeack(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Any currently selected harts have been reset and reset is not acknowledged."]
            #[inline(always)]
            pub const fn anyhavereset(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Any currently selected harts have been reset and reset is not acknowledged."]
            #[inline(always)]
            pub fn set_anyhavereset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "All currently selected harts have been reset and reset is not acknowledge"]
            #[inline(always)]
            pub const fn allhavereset(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "All currently selected harts have been reset and reset is not acknowledge"]
            #[inline(always)]
            pub fn set_allhavereset(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Implicit ebreak instruction at the non-existent word immediately after the Program Buffer."]
            #[inline(always)]
            pub const fn impebreak(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Implicit ebreak instruction at the non-existent word immediately after the Program Buffer."]
            #[inline(always)]
            pub fn set_impebreak(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Dmstatus {
            #[inline(always)]
            fn default() -> Dmstatus {
                Dmstatus(0)
            }
        }
        impl core::fmt::Debug for Dmstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Dmstatus")
                    .field("version", &self.version())
                    .field("confstrptrvalid", &self.confstrptrvalid())
                    .field("hasresethaltreq", &self.hasresethaltreq())
                    .field("authbusy", &self.authbusy())
                    .field("authenticated", &self.authenticated())
                    .field("anyhalted", &self.anyhalted())
                    .field("allhalted", &self.allhalted())
                    .field("anyrunning", &self.anyrunning())
                    .field("allrunning", &self.allrunning())
                    .field("anyunavail", &self.anyunavail())
                    .field("allunavail", &self.allunavail())
                    .field("anynonexistent", &self.anynonexistent())
                    .field("allnonexistent", &self.allnonexistent())
                    .field("anyresumeack", &self.anyresumeack())
                    .field("allresumeack", &self.allresumeack())
                    .field("anyhavereset", &self.anyhavereset())
                    .field("allhavereset", &self.allhavereset())
                    .field("impebreak", &self.impebreak())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Dmstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Dmstatus {
                    version: super::vals::Version,
                    confstrptrvalid: super::vals::Confstrptrvalid,
                    hasresethaltreq: bool,
                    authbusy: bool,
                    authenticated: bool,
                    anyhalted: bool,
                    allhalted: bool,
                    anyrunning: bool,
                    allrunning: bool,
                    anyunavail: bool,
                    allunavail: bool,
                    anynonexistent: bool,
                    allnonexistent: bool,
                    anyresumeack: bool,
                    allresumeack: bool,
                    anyhavereset: bool,
                    allhavereset: bool,
                    impebreak: bool,
                }
                let proxy = Dmstatus {
                    version: self.version(),
                    confstrptrvalid: self.confstrptrvalid(),
                    hasresethaltreq: self.hasresethaltreq(),
                    authbusy: self.authbusy(),
                    authenticated: self.authenticated(),
                    anyhalted: self.anyhalted(),
                    allhalted: self.allhalted(),
                    anyrunning: self.anyrunning(),
                    allrunning: self.allrunning(),
                    anyunavail: self.anyunavail(),
                    allunavail: self.allunavail(),
                    anynonexistent: self.anynonexistent(),
                    allnonexistent: self.allnonexistent(),
                    anyresumeack: self.anyresumeack(),
                    allresumeack: self.allresumeack(),
                    anyhavereset: self.anyhavereset(),
                    allhavereset: self.allhavereset(),
                    impebreak: self.impebreak(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Hart Information"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hartinfo(pub u32);
        impl Hartinfo {
            #[doc = "Data Address"]
            #[inline(always)]
            pub const fn dataaddr(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x0fff;
                val as u16
            }
            #[doc = "Data Address"]
            #[inline(always)]
            pub fn set_dataaddr(&mut self, val: u16) {
                self.0 = (self.0 & !(0x0fff << 0usize)) | (((val as u32) & 0x0fff) << 0usize);
            }
            #[doc = "Data Size"]
            #[inline(always)]
            pub const fn datasize(&self) -> u8 {
                let val = (self.0 >> 12usize) & 0x0f;
                val as u8
            }
            #[doc = "Data Size"]
            #[inline(always)]
            pub fn set_datasize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 12usize)) | (((val as u32) & 0x0f) << 12usize);
            }
            #[doc = "Data Access"]
            #[inline(always)]
            pub const fn dataaccess(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Data Access"]
            #[inline(always)]
            pub fn set_dataaccess(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Number of dscratch registers"]
            #[inline(always)]
            pub const fn nscratch(&self) -> u8 {
                let val = (self.0 >> 20usize) & 0x0f;
                val as u8
            }
            #[doc = "Number of dscratch registers"]
            #[inline(always)]
            pub fn set_nscratch(&mut self, val: u8) {
                self.0 = (self.0 & !(0x0f << 20usize)) | (((val as u32) & 0x0f) << 20usize);
            }
        }
        impl Default for Hartinfo {
            #[inline(always)]
            fn default() -> Hartinfo {
                Hartinfo(0)
            }
        }
        impl core::fmt::Debug for Hartinfo {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hartinfo")
                    .field("dataaddr", &self.dataaddr())
                    .field("datasize", &self.datasize())
                    .field("dataaccess", &self.dataaccess())
                    .field("nscratch", &self.nscratch())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hartinfo {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Hartinfo {
                    dataaddr: u16,
                    datasize: u8,
                    dataaccess: bool,
                    nscratch: u8,
                }
                let proxy = Hartinfo {
                    dataaddr: self.dataaddr(),
                    datasize: self.datasize(),
                    dataaccess: self.dataaccess(),
                    nscratch: self.nscratch(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Hart Array Window Select"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Hawindowsel(pub u32);
        impl Hawindowsel {
            #[doc = "The high bits of this field may be tied to 0, depending on how large the array mask register is. E.g. on a system with 48 harts only bit 0 of this field may actually be writable."]
            #[inline(always)]
            pub const fn hawindowsel(&self) -> u16 {
                let val = (self.0 >> 0usize) & 0x7fff;
                val as u16
            }
            #[doc = "The high bits of this field may be tied to 0, depending on how large the array mask register is. E.g. on a system with 48 harts only bit 0 of this field may actually be writable."]
            #[inline(always)]
            pub fn set_hawindowsel(&mut self, val: u16) {
                self.0 = (self.0 & !(0x7fff << 0usize)) | (((val as u32) & 0x7fff) << 0usize);
            }
        }
        impl Default for Hawindowsel {
            #[inline(always)]
            fn default() -> Hawindowsel {
                Hawindowsel(0)
            }
        }
        impl core::fmt::Debug for Hawindowsel {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Hawindowsel")
                    .field("hawindowsel", &self.hawindowsel())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Hawindowsel {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Hawindowsel {
                    hawindowsel: u16,
                }
                let proxy = Hawindowsel {
                    hawindowsel: self.hawindowsel(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable or disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[16\\]"]
            #[inline(always)]
            pub const fn triggered16(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[16\\]"]
            #[inline(always)]
            pub fn set_triggered16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[17\\]"]
            #[inline(always)]
            pub const fn triggered17(&self) -> bool {
                let val = (self.0 >> 17usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[17\\]"]
            #[inline(always)]
            pub fn set_triggered17(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 17usize)) | (((val as u32) & 0x01) << 17usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[18\\]"]
            #[inline(always)]
            pub const fn triggered18(&self) -> bool {
                let val = (self.0 >> 18usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[18\\]"]
            #[inline(always)]
            pub fn set_triggered18(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 18usize)) | (((val as u32) & 0x01) << 18usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[19\\]"]
            #[inline(always)]
            pub const fn triggered19(&self) -> bool {
                let val = (self.0 >> 19usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[19\\]"]
            #[inline(always)]
            pub fn set_triggered19(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 19usize)) | (((val as u32) & 0x01) << 19usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[20\\]"]
            #[inline(always)]
            pub const fn triggered20(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[20\\]"]
            #[inline(always)]
            pub fn set_triggered20(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[21\\]"]
            #[inline(always)]
            pub const fn triggered21(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[21\\]"]
            #[inline(always)]
            pub fn set_triggered21(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[22\\]"]
            #[inline(always)]
            pub const fn triggered22(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable interrupt for event TRIGGERED\\[22\\]"]
            #[inline(always)]
            pub fn set_triggered22(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("triggered16", &self.triggered16())
                    .field("triggered17", &self.triggered17())
                    .field("triggered18", &self.triggered18())
                    .field("triggered19", &self.triggered19())
                    .field("triggered20", &self.triggered20())
                    .field("triggered21", &self.triggered21())
                    .field("triggered22", &self.triggered22())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    triggered16: bool,
                    triggered17: bool,
                    triggered18: bool,
                    triggered19: bool,
                    triggered20: bool,
                    triggered21: bool,
                    triggered22: bool,
                }
                let proxy = Int {
                    triggered16: self.triggered16(),
                    triggered17: self.triggered17(),
                    triggered18: self.triggered18(),
                    triggered19: self.triggered19(),
                    triggered20: self.triggered20(),
                    triggered21: self.triggered21(),
                    triggered22: self.triggered22(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "System Bus Access Control and Status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Sbcs(pub u32);
        impl Sbcs {
            #[inline(always)]
            pub const fn sbaccess8(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbaccess8(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[inline(always)]
            pub const fn sbaccess16(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbaccess16(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
            #[inline(always)]
            pub const fn sbaccess32(&self) -> bool {
                let val = (self.0 >> 2usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbaccess32(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 2usize)) | (((val as u32) & 0x01) << 2usize);
            }
            #[inline(always)]
            pub const fn sbaccess64(&self) -> bool {
                let val = (self.0 >> 3usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbaccess64(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val as u32) & 0x01) << 3usize);
            }
            #[inline(always)]
            pub const fn sbaccess128(&self) -> bool {
                let val = (self.0 >> 4usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbaccess128(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 4usize)) | (((val as u32) & 0x01) << 4usize);
            }
            #[doc = "Width of system bus addresses in bits. (0 indicates there is no bus access support.)"]
            #[inline(always)]
            pub const fn sbasize(&self) -> u8 {
                let val = (self.0 >> 5usize) & 0x7f;
                val as u8
            }
            #[doc = "Width of system bus addresses in bits. (0 indicates there is no bus access support.)"]
            #[inline(always)]
            pub fn set_sbasize(&mut self, val: u8) {
                self.0 = (self.0 & !(0x7f << 5usize)) | (((val as u32) & 0x7f) << 5usize);
            }
            #[inline(always)]
            pub const fn sberror(&self) -> super::vals::Sberror {
                let val = (self.0 >> 12usize) & 0x07;
                super::vals::Sberror::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_sberror(&mut self, val: super::vals::Sberror) {
                self.0 =
                    (self.0 & !(0x07 << 12usize)) | (((val.to_bits() as u32) & 0x07) << 12usize);
            }
            #[inline(always)]
            pub const fn sbreadondata(&self) -> bool {
                let val = (self.0 >> 15usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbreadondata(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 15usize)) | (((val as u32) & 0x01) << 15usize);
            }
            #[inline(always)]
            pub const fn sbautoincrement(&self) -> bool {
                let val = (self.0 >> 16usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbautoincrement(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 16usize)) | (((val as u32) & 0x01) << 16usize);
            }
            #[inline(always)]
            pub const fn sbaccess(&self) -> super::vals::Sbaccess {
                let val = (self.0 >> 17usize) & 0x07;
                super::vals::Sbaccess::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_sbaccess(&mut self, val: super::vals::Sbaccess) {
                self.0 =
                    (self.0 & !(0x07 << 17usize)) | (((val.to_bits() as u32) & 0x07) << 17usize);
            }
            #[inline(always)]
            pub const fn sbreadonaddr(&self) -> bool {
                let val = (self.0 >> 20usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbreadonaddr(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 20usize)) | (((val as u32) & 0x01) << 20usize);
            }
            #[inline(always)]
            pub const fn sbbusy(&self) -> bool {
                let val = (self.0 >> 21usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbbusy(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 21usize)) | (((val as u32) & 0x01) << 21usize);
            }
            #[inline(always)]
            pub const fn sbbusyerror(&self) -> bool {
                let val = (self.0 >> 22usize) & 0x01;
                val != 0
            }
            #[inline(always)]
            pub fn set_sbbusyerror(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 22usize)) | (((val as u32) & 0x01) << 22usize);
            }
            #[inline(always)]
            pub const fn sbversion(&self) -> super::vals::Sbversion {
                let val = (self.0 >> 29usize) & 0x07;
                super::vals::Sbversion::from_bits(val as u8)
            }
            #[inline(always)]
            pub fn set_sbversion(&mut self, val: super::vals::Sbversion) {
                self.0 =
                    (self.0 & !(0x07 << 29usize)) | (((val.to_bits() as u32) & 0x07) << 29usize);
            }
        }
        impl Default for Sbcs {
            #[inline(always)]
            fn default() -> Sbcs {
                Sbcs(0)
            }
        }
        impl core::fmt::Debug for Sbcs {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Sbcs")
                    .field("sbaccess8", &self.sbaccess8())
                    .field("sbaccess16", &self.sbaccess16())
                    .field("sbaccess32", &self.sbaccess32())
                    .field("sbaccess64", &self.sbaccess64())
                    .field("sbaccess128", &self.sbaccess128())
                    .field("sbasize", &self.sbasize())
                    .field("sberror", &self.sberror())
                    .field("sbreadondata", &self.sbreadondata())
                    .field("sbautoincrement", &self.sbautoincrement())
                    .field("sbaccess", &self.sbaccess())
                    .field("sbreadonaddr", &self.sbreadonaddr())
                    .field("sbbusy", &self.sbbusy())
                    .field("sbbusyerror", &self.sbbusyerror())
                    .field("sbversion", &self.sbversion())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Sbcs {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Sbcs {
                    sbaccess8: bool,
                    sbaccess16: bool,
                    sbaccess32: bool,
                    sbaccess64: bool,
                    sbaccess128: bool,
                    sbasize: u8,
                    sberror: super::vals::Sberror,
                    sbreadondata: bool,
                    sbautoincrement: bool,
                    sbaccess: super::vals::Sbaccess,
                    sbreadonaddr: bool,
                    sbbusy: bool,
                    sbbusyerror: bool,
                    sbversion: super::vals::Sbversion,
                }
                let proxy = Sbcs {
                    sbaccess8: self.sbaccess8(),
                    sbaccess16: self.sbaccess16(),
                    sbaccess32: self.sbaccess32(),
                    sbaccess64: self.sbaccess64(),
                    sbaccess128: self.sbaccess128(),
                    sbasize: self.sbasize(),
                    sberror: self.sberror(),
                    sbreadondata: self.sbreadondata(),
                    sbautoincrement: self.sbautoincrement(),
                    sbaccess: self.sbaccess(),
                    sbreadonaddr: self.sbreadonaddr(),
                    sbbusy: self.sbbusy(),
                    sbbusyerror: self.sbbusyerror(),
                    sbversion: self.sbversion(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Ackhavereset {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Clears the havereset for selected harts."]
            CLEAR = 0x01,
        }
        impl Ackhavereset {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Ackhavereset {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Ackhavereset {
            #[inline(always)]
            fn from(val: u8) -> Ackhavereset {
                Ackhavereset::from_bits(val)
            }
        }
        impl From<Ackhavereset> for u8 {
            #[inline(always)]
            fn from(val: Ackhavereset) -> u8 {
                Ackhavereset::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Clrresethaltreq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Clears the halt on reset request"]
            CLEAR = 0x01,
        }
        impl Clrresethaltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Clrresethaltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Clrresethaltreq {
            #[inline(always)]
            fn from(val: u8) -> Clrresethaltreq {
                Clrresethaltreq::from_bits(val)
            }
        }
        impl From<Clrresethaltreq> for u8 {
            #[inline(always)]
            fn from(val: Clrresethaltreq) -> u8 {
                Clrresethaltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Cmderr {
            #[doc = "No error."]
            NO_ERROR = 0x0,
            #[doc = "An abstract command was executing while command, abstractcs, or abstractauto was written, or when one of the data or progbuf registers was read or written. This status is only written if cmderr contains 0"]
            BUSY = 0x01,
            #[doc = "The requested command is notsupported, regardless of whether the hart is running or not."]
            NOT_SUPPORTED = 0x02,
            #[doc = "An exception occurred while executing the command (e.g. while executing theProgram Buffer)."]
            EXCEPTION = 0x03,
            #[doc = "The abstract command couldn't execute because the hart wasn't in the required state (running/halted). or unavailable."]
            HALT_RESUME = 0x04,
            #[doc = "The abstract command failed due to abus error (e.g. alignment, access size, or timeout)."]
            BUS = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "The command failed for another reason."]
            OTHER = 0x07,
        }
        impl Cmderr {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Cmderr {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Cmderr {
            #[inline(always)]
            fn from(val: u8) -> Cmderr {
                Cmderr::from_bits(val)
            }
        }
        impl From<Cmderr> for u8 {
            #[inline(always)]
            fn from(val: Cmderr) -> u8 {
                Cmderr::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Cmdtype(pub u8);
        impl Cmdtype {
            #[doc = "Register Access Command"]
            pub const REGACCESS: Self = Self(0x0);
            #[doc = "Quick Access Command"]
            pub const QUICKACCESS: Self = Self(0x01);
            #[doc = "Memory Access Command"]
            pub const MEMACCESS: Self = Self(0x02);
        }
        impl Cmdtype {
            pub const fn from_bits(val: u8) -> Cmdtype {
                Self(val & 0xff)
            }
            pub const fn to_bits(self) -> u8 {
                self.0
            }
        }
        impl core::fmt::Debug for Cmdtype {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x0 => f.write_str("REGACCESS"),
                    0x01 => f.write_str("QUICKACCESS"),
                    0x02 => f.write_str("MEMACCESS"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Cmdtype {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x0 => defmt::write!(f, "REGACCESS"),
                    0x01 => defmt::write!(f, "QUICKACCESS"),
                    0x02 => defmt::write!(f, "MEMACCESS"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u8> for Cmdtype {
            #[inline(always)]
            fn from(val: u8) -> Cmdtype {
                Cmdtype::from_bits(val)
            }
        }
        impl From<Cmdtype> for u8 {
            #[inline(always)]
            fn from(val: Cmdtype) -> u8 {
                Cmdtype::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Confstrptrvalid {
            #[doc = "The confstrptr0..confstrptr3 holds information which is not relevant to the configuration string."]
            NOT_RELEVANT = 0x0,
            #[doc = "The confstrptr0..confstrptr3 holds the address of the configuration string."]
            ADDRESS = 0x01,
        }
        impl Confstrptrvalid {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Confstrptrvalid {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Confstrptrvalid {
            #[inline(always)]
            fn from(val: u8) -> Confstrptrvalid {
                Confstrptrvalid::from_bits(val)
            }
        }
        impl From<Confstrptrvalid> for u8 {
            #[inline(always)]
            fn from(val: Confstrptrvalid) -> u8 {
                Confstrptrvalid::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum CpurunEn {
            #[doc = "CPU stopped. If this is the CPU state after a core reset, setting this bit will change the CPU state to CPU running."]
            STOPPED = 0x0,
            #[doc = "CPU running. If this is the CPU state after a core reset, clearing this bit will change the CPU state to CPU stopped after a core reset."]
            RUNNING = 0x01,
        }
        impl CpurunEn {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> CpurunEn {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for CpurunEn {
            #[inline(always)]
            fn from(val: u8) -> CpurunEn {
                CpurunEn::from_bits(val)
            }
        }
        impl From<CpurunEn> for u8 {
            #[inline(always)]
            fn from(val: CpurunEn) -> u8 {
                CpurunEn::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Haltreq {
            #[doc = "Clears halt request bit for all currently selected harts."]
            CLEAR = 0x0,
            #[doc = "Currently selected harts halted."]
            HALT = 0x01,
        }
        impl Haltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Haltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Haltreq {
            #[inline(always)]
            fn from(val: u8) -> Haltreq {
                Haltreq::from_bits(val)
            }
        }
        impl From<Haltreq> for u8 {
            #[inline(always)]
            fn from(val: Haltreq) -> u8 {
                Haltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Hasel {
            #[doc = "Single hart selected."]
            SINGLE = 0x0,
            #[doc = "Multiple harts selected"]
            MULTIPLE = 0x01,
        }
        impl Hasel {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Hasel {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Hasel {
            #[inline(always)]
            fn from(val: u8) -> Hasel {
                Hasel::from_bits(val)
            }
        }
        impl From<Hasel> for u8 {
            #[inline(always)]
            fn from(val: Hasel) -> u8 {
                Hasel::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Resumereq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Currently selected harts resumed."]
            RESUMED = 0x01,
        }
        impl Resumereq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Resumereq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Resumereq {
            #[inline(always)]
            fn from(val: u8) -> Resumereq {
                Resumereq::from_bits(val)
            }
        }
        impl From<Resumereq> for u8 {
            #[inline(always)]
            fn from(val: Resumereq) -> u8 {
                Resumereq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sbaccess {
            #[doc = "8-bit."]
            SIZE8 = 0x0,
            #[doc = "16-bit."]
            SIZE16 = 0x01,
            #[doc = "32-bit."]
            SIZE32 = 0x02,
            #[doc = "64-bit."]
            SIZE64 = 0x03,
            #[doc = "128-bit."]
            SIZE128 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sbaccess {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sbaccess {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sbaccess {
            #[inline(always)]
            fn from(val: u8) -> Sbaccess {
                Sbaccess::from_bits(val)
            }
        }
        impl From<Sbaccess> for u8 {
            #[inline(always)]
            fn from(val: Sbaccess) -> u8 {
                Sbaccess::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sberror {
            #[doc = "There was no bus error."]
            NORMAL = 0x0,
            #[doc = "There was a timeout."]
            TIMEOUT = 0x01,
            #[doc = "A bad address was accessed."]
            ADDRESS = 0x02,
            #[doc = "There was an alignment error."]
            ALIGNMENT = 0x03,
            #[doc = "An access of unsupported size was requested."]
            SIZE = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            #[doc = "Other."]
            OTHER = 0x07,
        }
        impl Sberror {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sberror {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sberror {
            #[inline(always)]
            fn from(val: u8) -> Sberror {
                Sberror::from_bits(val)
            }
        }
        impl From<Sberror> for u8 {
            #[inline(always)]
            fn from(val: Sberror) -> u8 {
                Sberror::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sbversion {
            #[doc = "The System Bus interface conforms to mainline drafts of thia RISC-V External Debug Support spec older than 1 January, 2018."]
            VERSION0 = 0x0,
            #[doc = "The System Bus interface conforms to RISC-V External Debug Support version 0.14.0-DRAFT. Other values are reserved for future versions."]
            VERSION1 = 0x01,
            _RESERVED_2 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
        }
        impl Sbversion {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sbversion {
                unsafe { core::mem::transmute(val & 0x07) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sbversion {
            #[inline(always)]
            fn from(val: u8) -> Sbversion {
                Sbversion::from_bits(val)
            }
        }
        impl From<Sbversion> for u8 {
            #[inline(always)]
            fn from(val: Sbversion) -> u8 {
                Sbversion::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Setresethaltreq {
            #[doc = "No operation when written 0."]
            NO_OPERATION = 0x0,
            #[doc = "Sets the halt on reset request"]
            CLEAR = 0x01,
        }
        impl Setresethaltreq {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Setresethaltreq {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Setresethaltreq {
            #[inline(always)]
            fn from(val: u8) -> Setresethaltreq {
                Setresethaltreq::from_bits(val)
            }
        }
        impl From<Setresethaltreq> for u8 {
            #[inline(always)]
            fn from(val: Setresethaltreq) -> u8 {
                Setresethaltreq::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Version {
            #[doc = "Debug module not present."]
            NOT_PRESENT = 0x0,
            #[doc = "There is a Debug Module and it conforms to version 0.11 of this specifcation."]
            V011 = 0x01,
            #[doc = "There is a Debug Module and it conforms to version 0.13 of this specifcation."]
            V013 = 0x02,
            _RESERVED_3 = 0x03,
            _RESERVED_4 = 0x04,
            _RESERVED_5 = 0x05,
            _RESERVED_6 = 0x06,
            _RESERVED_7 = 0x07,
            _RESERVED_8 = 0x08,
            _RESERVED_9 = 0x09,
            _RESERVED_a = 0x0a,
            _RESERVED_b = 0x0b,
            _RESERVED_c = 0x0c,
            _RESERVED_d = 0x0d,
            _RESERVED_e = 0x0e,
            #[doc = "There is a Debug Module but it does not conform to any available version of the spec."]
            NON_CONFORM = 0x0f,
        }
        impl Version {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Version {
                unsafe { core::mem::transmute(val & 0x0f) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Version {
            #[inline(always)]
            fn from(val: u8) -> Version {
                Version::from_bits(val)
            }
        }
        impl From<Version> for u8 {
            #[inline(always)]
            fn from(val: Version) -> u8 {
                Version::to_bits(val)
            }
        }
    }
}
pub mod wdt {
    #[doc = "Watchdog Timer 0"]
    #[derive(Copy, Clone, Eq, PartialEq)]
    pub struct Wdt {
        ptr: *mut u8,
    }
    unsafe impl Send for Wdt {}
    unsafe impl Sync for Wdt {}
    impl Wdt {
        #[inline(always)]
        pub const unsafe fn from_ptr(ptr: *mut ()) -> Self {
            Self { ptr: ptr as _ }
        }
        #[inline(always)]
        pub const fn as_ptr(&self) -> *mut () {
            self.ptr as _
        }
        #[doc = "Start WDT"]
        #[inline(always)]
        pub const fn tasks_start(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0usize) as _) }
        }
        #[doc = "Stop WDT"]
        #[inline(always)]
        pub const fn tasks_stop(self) -> crate::common::Reg<u32, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x04usize) as _) }
        }
        #[doc = "Subscribe configuration for task START"]
        #[inline(always)]
        pub const fn subscribe_start(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x80usize) as _) }
        }
        #[doc = "Subscribe configuration for task STOP"]
        #[inline(always)]
        pub const fn subscribe_stop(
            self,
        ) -> crate::common::Reg<super::shared::regs::Subscribe, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x84usize) as _) }
        }
        #[doc = "Watchdog timeout"]
        #[inline(always)]
        pub const fn events_timeout(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0100usize) as _) }
        }
        #[doc = "Watchdog stopped"]
        #[inline(always)]
        pub const fn events_stopped(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0104usize) as _) }
        }
        #[doc = "Publish configuration for event TIMEOUT"]
        #[inline(always)]
        pub const fn publish_timeout(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0180usize) as _) }
        }
        #[doc = "Publish configuration for event STOPPED"]
        #[inline(always)]
        pub const fn publish_stopped(
            self,
        ) -> crate::common::Reg<super::shared::regs::Publish, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0184usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn intenset(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0304usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn intenclr(self) -> crate::common::Reg<regs::Int, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0308usize) as _) }
        }
        #[doc = "Enable interrupt"]
        #[inline(always)]
        pub const fn nmienset(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0324usize) as _) }
        }
        #[doc = "Disable interrupt"]
        #[inline(always)]
        pub const fn nmienclr(self) -> crate::common::Reg<regs::Nmi, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0328usize) as _) }
        }
        #[doc = "Run status"]
        #[inline(always)]
        pub const fn runstatus(self) -> crate::common::Reg<regs::Runstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0400usize) as _) }
        }
        #[doc = "Request status"]
        #[inline(always)]
        pub const fn reqstatus(self) -> crate::common::Reg<regs::Reqstatus, crate::common::R> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0404usize) as _) }
        }
        #[doc = "Counter reload value"]
        #[inline(always)]
        pub const fn crv(self) -> crate::common::Reg<u32, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0504usize) as _) }
        }
        #[doc = "Enable register for reload request registers"]
        #[inline(always)]
        pub const fn rren(self) -> crate::common::Reg<regs::Rren, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0508usize) as _) }
        }
        #[doc = "Configuration register"]
        #[inline(always)]
        pub const fn config(self) -> crate::common::Reg<regs::Config, crate::common::RW> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x050cusize) as _) }
        }
        #[doc = "Task stop enable"]
        #[inline(always)]
        pub const fn tsen(self) -> crate::common::Reg<regs::Tsen, crate::common::W> {
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0520usize) as _) }
        }
        #[doc = "Description collection: Reload request n"]
        #[inline(always)]
        pub const fn rr(self, n: usize) -> crate::common::Reg<regs::Rr, crate::common::W> {
            assert!(n < 8usize);
            unsafe { crate::common::Reg::from_ptr(self.ptr.add(0x0600usize + n * 4usize) as _) }
        }
    }
    pub mod regs {
        #[doc = "Configuration register"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Config(pub u32);
        impl Config {
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is sleeping"]
            #[inline(always)]
            pub const fn sleep(&self) -> super::vals::Sleep {
                let val = (self.0 >> 0usize) & 0x01;
                super::vals::Sleep::from_bits(val as u8)
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is sleeping"]
            #[inline(always)]
            pub fn set_sleep(&mut self, val: super::vals::Sleep) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val.to_bits() as u32) & 0x01) << 0usize);
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[inline(always)]
            pub const fn halt(&self) -> super::vals::Halt {
                let val = (self.0 >> 3usize) & 0x01;
                super::vals::Halt::from_bits(val as u8)
            }
            #[doc = "Configure WDT to either be paused, or kept running, while the CPU is halted by the debugger"]
            #[inline(always)]
            pub fn set_halt(&mut self, val: super::vals::Halt) {
                self.0 = (self.0 & !(0x01 << 3usize)) | (((val.to_bits() as u32) & 0x01) << 3usize);
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub const fn stopen(&self) -> bool {
                let val = (self.0 >> 6usize) & 0x01;
                val != 0
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub fn set_stopen(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 6usize)) | (((val as u32) & 0x01) << 6usize);
            }
        }
        impl Default for Config {
            #[inline(always)]
            fn default() -> Config {
                Config(0)
            }
        }
        impl core::fmt::Debug for Config {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Config")
                    .field("sleep", &self.sleep())
                    .field("halt", &self.halt())
                    .field("stopen", &self.stopen())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Config {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Config {
                    sleep: super::vals::Sleep,
                    halt: super::vals::Halt,
                    stopen: bool,
                }
                let proxy = Config {
                    sleep: self.sleep(),
                    halt: self.halt(),
                    stopen: self.stopen(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Int(pub u32);
        impl Int {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Int {
            #[inline(always)]
            fn default() -> Int {
                Int(0)
            }
        }
        impl core::fmt::Debug for Int {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Int")
                    .field("timeout", &self.timeout())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Int {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Int {
                    timeout: bool,
                    stopped: bool,
                }
                let proxy = Int {
                    timeout: self.timeout(),
                    stopped: self.stopped(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Disable interrupt"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Nmi(pub u32);
        impl Nmi {
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub const fn timeout(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event TIMEOUT"]
            #[inline(always)]
            pub fn set_timeout(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub const fn stopped(&self) -> bool {
                let val = (self.0 >> 1usize) & 0x01;
                val != 0
            }
            #[doc = "Write '1' to disable interrupt for event STOPPED"]
            #[inline(always)]
            pub fn set_stopped(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 1usize)) | (((val as u32) & 0x01) << 1usize);
            }
        }
        impl Default for Nmi {
            #[inline(always)]
            fn default() -> Nmi {
                Nmi(0)
            }
        }
        impl core::fmt::Debug for Nmi {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Nmi")
                    .field("timeout", &self.timeout())
                    .field("stopped", &self.stopped())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Nmi {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Nmi {
                    timeout: bool,
                    stopped: bool,
                }
                let proxy = Nmi {
                    timeout: self.timeout(),
                    stopped: self.stopped(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Request status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Reqstatus(pub u32);
        impl Reqstatus {
            #[doc = "Request status for RR\\[0\\] register"]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Request status for RR\\[0\\] register"]
            #[inline(always)]
            pub fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Reqstatus {
            #[inline(always)]
            fn default() -> Reqstatus {
                Reqstatus(0)
            }
        }
        impl core::fmt::Debug for Reqstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Reqstatus")
                    .field(
                        "rr",
                        &[
                            self.rr(0usize),
                            self.rr(1usize),
                            self.rr(2usize),
                            self.rr(3usize),
                            self.rr(4usize),
                            self.rr(5usize),
                            self.rr(6usize),
                            self.rr(7usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Reqstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Reqstatus {
                    rr: [bool; 8usize],
                }
                let proxy = Reqstatus {
                    rr: [
                        self.rr(0usize),
                        self.rr(1usize),
                        self.rr(2usize),
                        self.rr(3usize),
                        self.rr(4usize),
                        self.rr(5usize),
                        self.rr(6usize),
                        self.rr(7usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Description collection: Reload request n"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rr(pub u32);
        impl Rr {
            #[doc = "Reload request register"]
            #[inline(always)]
            pub const fn rr(&self) -> super::vals::Rr {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Rr::from_bits(val as u32)
            }
            #[doc = "Reload request register"]
            #[inline(always)]
            pub fn set_rr(&mut self, val: super::vals::Rr) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Rr {
            #[inline(always)]
            fn default() -> Rr {
                Rr(0)
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rr").field("rr", &self.rr()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rr {
                    rr: super::vals::Rr,
                }
                let proxy = Rr { rr: self.rr() };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Enable register for reload request registers"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Rren(pub u32);
        impl Rren {
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[inline(always)]
            pub const fn rr(&self, n: usize) -> bool {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                let val = (self.0 >> offs) & 0x01;
                val != 0
            }
            #[doc = "Enable or disable RR\\[0\\] register"]
            #[inline(always)]
            pub fn set_rr(&mut self, n: usize, val: bool) {
                assert!(n < 8usize);
                let offs = 0usize + n * 1usize;
                self.0 = (self.0 & !(0x01 << offs)) | (((val as u32) & 0x01) << offs);
            }
        }
        impl Default for Rren {
            #[inline(always)]
            fn default() -> Rren {
                Rren(0)
            }
        }
        impl core::fmt::Debug for Rren {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Rren")
                    .field(
                        "rr",
                        &[
                            self.rr(0usize),
                            self.rr(1usize),
                            self.rr(2usize),
                            self.rr(3usize),
                            self.rr(4usize),
                            self.rr(5usize),
                            self.rr(6usize),
                            self.rr(7usize),
                        ],
                    )
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rren {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Rren {
                    rr: [bool; 8usize],
                }
                let proxy = Rren {
                    rr: [
                        self.rr(0usize),
                        self.rr(1usize),
                        self.rr(2usize),
                        self.rr(3usize),
                        self.rr(4usize),
                        self.rr(5usize),
                        self.rr(6usize),
                        self.rr(7usize),
                    ],
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Run status"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Runstatus(pub u32);
        impl Runstatus {
            #[doc = "Indicates whether or not WDT is running"]
            #[inline(always)]
            pub const fn runstatuswdt(&self) -> bool {
                let val = (self.0 >> 0usize) & 0x01;
                val != 0
            }
            #[doc = "Indicates whether or not WDT is running"]
            #[inline(always)]
            pub fn set_runstatuswdt(&mut self, val: bool) {
                self.0 = (self.0 & !(0x01 << 0usize)) | (((val as u32) & 0x01) << 0usize);
            }
        }
        impl Default for Runstatus {
            #[inline(always)]
            fn default() -> Runstatus {
                Runstatus(0)
            }
        }
        impl core::fmt::Debug for Runstatus {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Runstatus")
                    .field("runstatuswdt", &self.runstatuswdt())
                    .finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Runstatus {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Runstatus {
                    runstatuswdt: bool,
                }
                let proxy = Runstatus {
                    runstatuswdt: self.runstatuswdt(),
                };
                defmt::write!(f, "{}", proxy)
            }
        }
        #[doc = "Task stop enable"]
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq)]
        pub struct Tsen(pub u32);
        impl Tsen {
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub const fn tsen(&self) -> super::vals::Tsen {
                let val = (self.0 >> 0usize) & 0xffff_ffff;
                super::vals::Tsen::from_bits(val as u32)
            }
            #[doc = "Allow stopping WDT"]
            #[inline(always)]
            pub fn set_tsen(&mut self, val: super::vals::Tsen) {
                self.0 = (self.0 & !(0xffff_ffff << 0usize))
                    | (((val.to_bits() as u32) & 0xffff_ffff) << 0usize);
            }
        }
        impl Default for Tsen {
            #[inline(always)]
            fn default() -> Tsen {
                Tsen(0)
            }
        }
        impl core::fmt::Debug for Tsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                f.debug_struct("Tsen").field("tsen", &self.tsen()).finish()
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsen {
            fn format(&self, f: defmt::Formatter) {
                #[derive(defmt :: Format)]
                struct Tsen {
                    tsen: super::vals::Tsen,
                }
                let proxy = Tsen { tsen: self.tsen() };
                defmt::write!(f, "{}", proxy)
            }
        }
    }
    pub mod vals {
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Halt {
            #[doc = "Pause WDT while the CPU is halted by the debugger"]
            PAUSE = 0x0,
            #[doc = "Keep WDT running while the CPU is halted by the debugger"]
            RUN = 0x01,
        }
        impl Halt {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Halt {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Halt {
            #[inline(always)]
            fn from(val: u8) -> Halt {
                Halt::from_bits(val)
            }
        }
        impl From<Halt> for u8 {
            #[inline(always)]
            fn from(val: Halt) -> u8 {
                Halt::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Rr(pub u32);
        impl Rr {
            #[doc = "Value to request a reload of the watchdog timer"]
            pub const RELOAD: Self = Self(0x6e52_4635);
        }
        impl Rr {
            pub const fn from_bits(val: u32) -> Rr {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Rr {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("RELOAD"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Rr {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "RELOAD"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Rr {
            #[inline(always)]
            fn from(val: u32) -> Rr {
                Rr::from_bits(val)
            }
        }
        impl From<Rr> for u32 {
            #[inline(always)]
            fn from(val: Rr) -> u32 {
                Rr::to_bits(val)
            }
        }
        #[repr(u8)]
        #[derive(Copy, Clone, Debug, Eq, PartialEq, Ord, PartialOrd)]
        #[cfg_attr(feature = "defmt", derive(defmt::Format))]
        pub enum Sleep {
            #[doc = "Pause WDT while the CPU is sleeping"]
            PAUSE = 0x0,
            #[doc = "Keep WDT running while the CPU is sleeping"]
            RUN = 0x01,
        }
        impl Sleep {
            #[inline(always)]
            pub const fn from_bits(val: u8) -> Sleep {
                unsafe { core::mem::transmute(val & 0x01) }
            }
            #[inline(always)]
            pub const fn to_bits(self) -> u8 {
                unsafe { core::mem::transmute(self) }
            }
        }
        impl From<u8> for Sleep {
            #[inline(always)]
            fn from(val: u8) -> Sleep {
                Sleep::from_bits(val)
            }
        }
        impl From<Sleep> for u8 {
            #[inline(always)]
            fn from(val: Sleep) -> u8 {
                Sleep::to_bits(val)
            }
        }
        #[repr(transparent)]
        #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd)]
        pub struct Tsen(pub u32);
        impl Tsen {
            #[doc = "Value to allow stopping WDT"]
            pub const ENABLE: Self = Self(0x6e52_4635);
        }
        impl Tsen {
            pub const fn from_bits(val: u32) -> Tsen {
                Self(val & 0xffff_ffff)
            }
            pub const fn to_bits(self) -> u32 {
                self.0
            }
        }
        impl core::fmt::Debug for Tsen {
            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
                match self.0 {
                    0x6e52_4635 => f.write_str("ENABLE"),
                    other => core::write!(f, "0x{:02X}", other),
                }
            }
        }
        #[cfg(feature = "defmt")]
        impl defmt::Format for Tsen {
            fn format(&self, f: defmt::Formatter) {
                match self.0 {
                    0x6e52_4635 => defmt::write!(f, "ENABLE"),
                    other => defmt::write!(f, "0x{:02X}", other),
                }
            }
        }
        impl From<u32> for Tsen {
            #[inline(always)]
            fn from(val: u32) -> Tsen {
                Tsen::from_bits(val)
            }
        }
        impl From<Tsen> for u32 {
            #[inline(always)]
            fn from(val: Tsen) -> u32 {
                Tsen::to_bits(val)
            }
        }
    }
}
